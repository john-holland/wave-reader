backlog contents:

mouse control
sounds: generate white noise, brown noise, pink noise with javascript dsp
opt in prompt for ml data
google analytics events
instrumentation, google analytics, data dog exploration
investigate state-legend for syncing?
Click a value to filter the view
graph ql setup for backend integration
Click a value to filter the view
automatically adjust css if selector is changed
Click a value to filter the view
[bug] shortcut command retoggle...
Click a value to filter the view
melodic device for time perception
Click a value to filter the view
copy & paste settings json data to & from clipboard
[bug]: reset settings does not visibly reset settings (functionally fine)
dockerize builds
[bug] css moves vertically instead of horizontally in some code editors
[bug]: ReferenceError: config is not defined
implement selector selection mode

code:

{
  "manifest_version": 3,
  "name": "Wave Reader",
  "short_name": "🌊r.",
  "version": "1.0.0",
  "description": "Smoothly wobble text blocks, to improve eye tracking for reading!",
  "icons": {
    "16": "icons/waver16.jpg",
    "48": "icons/waver48.png",
    "128": "icons/waver128.jpg"
  },
  "action": {
    "default_title": "Wave Reader",
    "default_popup": "index.html",
    "default_icon": "icons/waver16.jpg"
  },
  "background": {
    "service_worker": "background.js",
    "matches": [
      "<all_urls>",
      "*://*/*"
    ],
    "run_at": "document_end"
  },
  "content_scripts": [
    {
      "matches": [
        "<all_urls>"
      ],
      "js": ["content.js"],
      "run_at": "document_end",
      "all_frames": true,
      "world": "MAIN"
    }
  ],
  "web_accessible_resources": [{
    "resources": ["content.js"],
    "matches": ["<all_urls>"]
  }],
  "host_permissions": [
    "<all_urls>",
    "tabs",
    "activeTab"
  ],
  "permissions": [
    "scripting",
    "declarativeContent",
    "storage",
    "notifications",
    "webNavigation",
    "activeTab",
    "tabs"
  ]
}MIT License

Copyright (c) 2022 John Holland

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
import {Deferred} from "../../src/util/deferred";
import {describe, expect, test} from '@jest/globals'

describe('Deferred', () => {
    test('resolves waitFor properly', (done: () => void) => {
        let deferred = new Deferred<string>(() => {
            return new Promise((resolve, reject) => {
                setTimeout(() => resolve('test'), 0);
            });
        });

        deferred.waitFor().then((value: string | undefined) => {
            expect(value).toBe('test');
            done();
        });
    });

    test('rejects waitFor properly', (done: () => void) => {
        let deferred = new Deferred<string>(() => {
            return new Promise((resolve, reject) => {
                setTimeout(() => reject('test'), 0);
            });
        });

        deferred.waitFor().then((value?: string) => {}, (reason: string) => {
            expect(reason).toBe('test');
            done();
        });
    });

    test('updates', (done: () => void) => {
        let arr = [1,2,3];
        let deferred = new Deferred<number>(() => {
            return new Promise((resolve, reject) => {
                setTimeout(() => resolve(arr.pop()!!), 0);
            });
        });

        deferred.waitFor().then((value?: number) => {
            expect(value).toBe(3);

            deferred.update().then((value?: number) => {
                expect(value).toBe(2);
                done();
            });
        });
    });

    test('updates rejects', (done: () => void) => {
        let arr = [3];
        let deferred = new Deferred<number>(() => {
            return new Promise((resolve, reject) => {
                setTimeout(() => resolve(arr.pop()!!), 0);
            });
        });

        deferred.waitFor().then((value?: number) => {
            expect(value).toBe(3);

            deferred.update().then((value?: number) => {}, (reason) => {
                done();
            });
        });
    });
});import {Deferred} from "../../src/util/deferred";
import {describe, expect, test} from '@jest/globals'
import Options from "../../src/models/options";

describe('Attribute Constructor', () => {
    test('copies default partial', (done: () => void) => {
        const settingsWithNotificationsFalse = { ...Options.getDefaultOptions(), ...{ showNotifications: false  }};
        const settings = new Options(settingsWithNotificationsFalse)
        expect(settings.showNotifications).toBe(false);
        done();
    });

    test('copies built in partial defaults', (done: () => void) => {
        const settings = new Options(Options.getDefaultOptions())
        expect(settings.showNotifications).toBe(true);
        done();
    });
});/**
 * @jest-environment jsdom
 */

// todo: the above [jest-environment] does not set the config/config mode properly
//       i thought it was for just this, but App.tsx is still one of the only files to access the config
//       directly.
import * as React from "react"
import "jest";

import { TextEncoder, TextDecoder } from 'util';

Object.assign(global, { TextDecoder, TextEncoder });

import App, { AppStates, GoingStorageProxy, SetReset } from "../src/app";
import StateMachine from "../src/util/state-machine";
import { NameAccessMapInterface, Named, State } from "../src/util/state";
import Options from "../src/models/options";
import InstalledDetails = chrome.runtime.InstalledDetails;

import UpdateWaveMessage from "../src/models/messages/update-wave";

import {withMockSettingsService} from "./components/util/mock-settings-service";
import SettingsService, {SettingsDAOInterface} from "../src/services/settings";
import styled from 'styled-components';
const Container = styled.div``;
import { waitFor } from "@testing-library/react";
//import "@testing-library/react";
// import "@testing-library/jest-dom"
//
// const jsdom = require("jsdom");
// const { JSDOM } = jsdom;

// const waitFor = async (action: { (): void }, timeout: number, interval: number = 100): Promise<boolean> => {
//     const start = new Date().getTime();
//     let now = new Date().getTime();
//     return new Promise((resolve, reject) => {
//         const act = () => {
//             if ((now - start) <= timeout || (now - start + interval) <= timeout) {
//                 try {
//                     action()
//                     resolve(true);
//                     return;
//                 } catch (e) {
//                     if ((now - start) === timeout || (now - start + interval) > timeout) {
//                         reject(e);
//                         return;
//                     }
//
//                     now = new Date().getTime();
//                     setTimeout(act, interval);
//                     return;
//                 }
//             }
//             resolve(false);
//         };
//         setTimeout(act, interval);
//     })
// }
//
//

type BooleanProxy = {
    bool: boolean
}
type StateMachineMockProps = {
    setGoingCalled: BooleanProxy
    bootstrapConditionCalled: BooleanProxy
    going: boolean | undefined
    goingCalledValue: boolean | undefined
    state: State | undefined
    options: Options
    statemachine: StateMachine,
    bootstrapLock: SetReset,
    onMessageListener: { (callback: {(message: any): boolean}): void }
    accessSettingsService?: { (service: SettingsDAOInterface): void }
    setOptions: { (options: Options): void }
}
const StateMachineFactory = async ({
    setGoingCalled = { bool: false },
    bootstrapConditionCalled = { bool: false },
    going = undefined,
    goingCalledValue = undefined,
    state = undefined,
    options = new Options(),
    statemachine = new StateMachine(),
    bootstrapLock = SetReset.unset("test bootstrap lock"),
    onMessageListener = (callback) => { },
    accessSettingsService,
    setOptions = (opts: Options) => {
        options = opts;
    }
}: Partial<StateMachineMockProps>) => {
    const states: NameAccessMapInterface = (await withMockSettingsService<NameAccessMapInterface>((settingsService: SettingsService, accessRegistry) => {
        if (accessSettingsService) accessSettingsService(settingsService)
        return AppStates({
            machine: statemachine,
            settingsService,
            setState: (s): Promise<State> => {
                state = s as State;
                return statemachine.handleState(s as Named || statemachine.getState(s as string) as Named).then(c => c!!)
            },
            map: new Map<string, State>(),
            getGoing: (): boolean => {
                return going!!;
            },
            setGoing: (value: boolean): Promise<void> => {
                going = value;
                setGoingCalled.bool = true;
                return Promise.resolve();
            },
            bootstrapCondition: (value: boolean): Promise<Options> => {
                goingCalledValue = value;
                bootstrapConditionCalled.bool = true;
                return Promise.resolve(options);
            },
            setOptions: (o: Options) => {
                options = o;
                setOptions(options);
            },
            _getGoingAsync: () => Promise.resolve(!!going),
            onRunTimeInstalledListener: (callback: { (details: InstalledDetails): void }) => {
                callback({} as unknown as InstalledDetails)
            },
            onMessageListener,
            getSyncObject_Going: (key: string, defaultValue: { going: boolean }, callback: { (result: GoingStorageProxy): void }) => { callback({ going: going || false } as GoingStorageProxy) },
            bootstrapLock
        })
    })) as NameAccessMapInterface

    return states;
}

// describe("something", () => {
//     test("has to have a test", () => {
//         expect(true).toBeTruthy();
//     })
//
//     test("waitFor", async () => {
//             return new Promise(async (resolve, reject) => {
//                 const start = new Date().getTime();
//
//                 const success = await waitFor(() => {
//                     throw new Error("test")
//                 }, 3000).catch(resolve);
//
//                 expect(new Date().getTime() - start).toBeGreaterThan(3000)
//                 resolve(void 0);
//             })
//         })
//
//         test("waitFor", async () => {
//             return new Promise(async (resolve, reject) => {
//                 const start = new Date().getTime();
//
//                 const success = await waitFor(() => {
//                     const now = new Date().getTime()
//                     if ((now - start) < 1500) {
//                         console.log(now - start)
//                         throw new Error("test")
//                     }
//                 }, 3000)
//
//                 const now = new Date().getTime()
//                 expect(now - start).toBeGreaterThan(1500)
//
//                 expect(success).toBeTruthy()
//                 resolve(void 0);
//             })
//         })
// })

type GOoooo = void;
describe("app tests", () => {
    describe("app state machine", () => {
        test("waitFor", async () => {
            return new Promise(async (resolve, reject) => {
                const start = new Date().getTime();

                const success = await waitFor(() => {
                    const now = new Date().getTime()
                    if (now - start <= 3000) {
                        throw new Error("test")
                    }
                }, { timeout: 3000, interval: 100 }).catch(resolve);

                expect(new Date().getTime() - start).toBeGreaterThan(3000)
                resolve(void 0);
            })
        })

        test("waitFor", async () => {
            return new Promise(async (resolve, reject) => {
                const start = new Date().getTime();

                const success = await waitFor(() => {
                    const now = new Date().getTime()
                    if (now - start < 1500) {
                        throw new Error("test")
                    }
                }, { timeout: 3000, interval: 100 })

                const now = new Date().getTime()
                expect(now - start).toBeGreaterThan(1500)

                // expect(success).toBeTruthy() // in our petty waitFor, not react's
                resolve(void 0);
            })
        })

        test("bootstrap", async () => {
            const statemachine = new StateMachine();
            const setGoingCalled: BooleanProxy = { bool: false }
            const bootstrapConditionCalled: BooleanProxy = { bool: false }
            const bootstrapLock = SetReset.unset("bootstrap test lock")
            const states = await StateMachineFactory({
                statemachine,
                setGoingCalled,
                bootstrapConditionCalled,
                bootstrapLock
            });

            statemachine.initialize(states, states.getState("base") as State)

            expect((await statemachine.handleState(states.getState("bootstrap") as State))?.name).toBe("base")

            expect(bootstrapConditionCalled.bool).toBeTruthy()
            expect(bootstrapLock.getSet()).toBeTruthy()

            return Promise.resolve<GOoooo>(void 0);
        })

        test("base", async () => {
            const statemachine = new StateMachine();
            const setGoingCalled: BooleanProxy = { bool: false }
            const bootstrapConditionCalled: BooleanProxy = { bool: false }
            const states = await StateMachineFactory({
                statemachine,
                setGoingCalled,
                bootstrapConditionCalled
            });

            statemachine.initialize(states, states.getState("base") as State)

            expect((await statemachine.handleState(states.getState("bootstrap") as State))?.name).toBe("base")

            expect(bootstrapConditionCalled.bool).toBeTruthy()

            return Promise.resolve<GOoooo>(void 0);
        })
        test("settings updated", async () => {
            type Event = { (message: any): void };
            let messageCallback: Event | undefined = undefined;
            const statemachine = new StateMachine();
            const setGoingCalled: BooleanProxy = { bool: false }
            const bootstrapConditionCalled: BooleanProxy = { bool: false }
            let settings: SettingsService | undefined = undefined;
            let setOptionsCalled: boolean = false;
            let optionsCalledWith: Options | undefined = undefined;
            const states = await StateMachineFactory({
                statemachine,
                setGoingCalled,
                bootstrapConditionCalled,
                onMessageListener: (callback: { (message: any): void }) => {
                    messageCallback = callback
                },
                accessSettingsService: (settingsService) => {
                    settings = settingsService as SettingsService
                },
                setOptions: (options: Options) => {
                    setOptionsCalled = true;
                    optionsCalledWith = options;
                }
            });

            statemachine.initialize(states, states.getState("base") as State)

            const statesPushed: (State | undefined)[] = []
            statemachine.getObservable()?.forEach((state) => {
                statesPushed.push(state);
            })

            expect((await statemachine.handleState(states.getState("bootstrap") as State))?.name).toBe("base")

            expect(bootstrapConditionCalled.bool).toBeTruthy()
            const previous = await settings!!.getCurrentSettings();

            const newOptions = new Options({ selectors: ["test selector"] });
            if (messageCallback !== undefined) (messageCallback as Event)(new UpdateWaveMessage({
                options: newOptions
            }))

            // a quick explanation for the order of statesPushed:
            //   bootstrap returns base, and also sets base as the active state (reporting 2 bases)
            //   then update switches back to base, for something like a baseball game with baseballs new expansion:
            //      extra bases ball! (unrelated to "Really Bad Baseball" if Zach Gage gets into physics... <3)
            return new Promise(async (resolve, reject) => {
                await waitFor(async () => {
                    const currently = await settings!!.getCurrentSettings();
                    expect(setOptionsCalled).toBeTruthy()
                    expect(Options.OptionsEqual(currently, newOptions)).toBeTruthy();
                    expect(Options.OptionsEqual(currently, optionsCalledWith as Options)).toBeTruthy();
                    expect(currently.selectors.includes("test selector")).toBeTruthy();
                    expect(statesPushed.map(c => c?.name)).toStrictEqual(["bootstrap", "base", "base", "base", "update", "base"])
                    resolve(void 0)
                }, { timeout: 3000, interval: 100 })
            })
        })
        test("set wave", () => {

        })
        test("selection mode activate", () => {

        })
        test("selection mode active", () => {

        })
        test("selection made (enable settings tab)", () => {

        })
        test("selection error report (user error, set red selection error note, revert to previous selector)", () => {

        })
        test("start add selector", () => {

        })
        test("add selector", () => {

        })
        test("cancel add selector", () => {

        })
        test("remove selector", () => {

        })
        test("confirm remove selector", () => {

        })
        test("cancel remove selector", () => {

        })
        test("use selector", () => {

        })
        test("start waving", () => {

        })
        test("waving", () => {

        })
        test("stop waving", () => {
        })
    })
})

import DoneCallback = jest.DoneCallback;
import debounce from "../../../src/util/debounce";


describe("debounce", () => {
    test("debounces", (done: DoneCallback) => {
        let count = 0;

        const debounced = debounce(() => count = count + 1, 20)

        debounced()
        debounced()

        expect(count).toBe(1);
        done();
    })

    test("debounces immediately", (done: DoneCallback) => {
        let count = 0;

        const debounced = debounce(() => count = count + 1, 20, true)

        debounced()

        expect(count).toBe(1);
        done();
    })
})
import SettingsService, {SettingsRegistry} from "../../../src/services/settings";

export const withMockSettingsService = async <T>(context: {(settingsService: SettingsService, accessRegistry: {(): SettingsRegistry}): T | undefined}, url: string = "http://www.fart.com/fart"): Promise<T | undefined> => {
    let proxy = { settingsRegistry: {} };
    let returnValue: T | undefined = undefined;
    const settings = new SettingsService(
        (callback: { (settingsRegistry: SettingsRegistry): void }): void => callback(proxy.settingsRegistry),
        () => Promise.resolve(url),
        (newSettingsRegistry, callback?: ({(): T} | {(): void})) => {
            proxy.settingsRegistry = newSettingsRegistry;
            if (callback) callback();
        })
    return new Promise(async (resolve) => {
        resolve(context(settings, () => proxy.settingsRegistry));
    });
}
import "jest";
import StateMachine, {
    Client,
    ClientDiscovery,
    ClientHost, ClientID, ClientLocation, ClientMessage, GoogleChromeRuntimeProxy, GoogleClientMessengerService,
    IClientMessengerService,
    IRuntimeProxy, Success
} from "../../../src/util/state-machine";
import {State, CState, NameAccessMapInterface, Named, StateNames} from "../../../src/util/state"

import {
    StartVentures,
    StopVentures,
    WavingVentures,
    AllVentures,
    Base
} from "../../../src/util/venture-states";
import UpdateWaveMessage from "../../../src/models/messages/update-wave";
import {Context, Dispatch, FunctionComponent, ReactElement, SetStateAction, useEffect, useState} from "react";
import SelectorHierarchy, {HierarchySelectorComponentProps} from "../../../src/components/selector-hierarchy";
import React from "react";
import Message from "../../../src/models/message";
import {Observable, Subscriber} from "rxjs";
import {fromMessage} from "../../../src/util/messages";
import Wave from "../../../src/models/wave";
import MessageSender = chrome.runtime.MessageSender;
import Options from "../../../src/models/options";
import {log, ComponentLog, MachineComponentProps, ReactMachine, UseStateProxy} from "../../../src/util/react-machine";


const BaseVentures = ["base", "error"]

class NameAccessMap implements NameAccessMapInterface {
    map: Map<string, State>;

    constructor(map: Map<string, State>) {
        this.map = map;
    }

    getState(name: string): State | undefined {
        return this.map.get(name);
    }
}
const StateNameMap = (map: Map<string, State> = new Map<string, State>()): NameAccessMap => {
    const mapObject = new NameAccessMap(map);


    const states: StateNames = {

        // base defined above
        "waving": CState("waving", WavingVentures, false),
        "error": CState("error", AllVentures, true, async (message: Named, state: State, previousState: State): Promise<State | undefined> => {
            console.log("transitioning from error to base state from " + previousState.name)
            return map.get('base') as State
        }),
        "start": CState("start", StartVentures, false, async (message: Named, state: State, previousState: State): Promise<State | undefined> => {
            return map.get('waving') as State
        }),
        "stop": CState("stop", StopVentures, false, async (message: Named, state: State, previousState: State): Promise<State | undefined> => {
            return map.get('base') as State
        }),
        "update": CState("update", BaseVentures, true, async (message: Named, state: State, previousState: State): Promise<State | undefined> => {
            return previousState
        }),
        "toggle start": CState("toggle start", StartVentures, false, async (message: Named, state: State, previousState: State): Promise<State | undefined> => {
            return map.get('waving') as State
        }),
        "toggle stop": CState("toggle stop", StopVentures, false, async (message: Named, state: State, previousState: State): Promise<State | undefined> => {
            return map.get('base') as State
        }),
        "start mouse": CState("start mouse", StartVentures, false, async (message: Named, state: State, previousState: State): Promise<State | undefined> => {
            return map.get('waving') as State
        }),
        "stop mouse": CState("stop mouse", StopVentures, false, async (message: Named, state: State, previousState: State): Promise<State | undefined> => {
            return map.get('base') as State
        }),
        "selection mode activate": CState("selection mode activate", ["selection mode deactivate", "selection made"], false, async (message: Named, state: State, previousState: State): Promise<State | undefined> => {
            return map.get('selection mode') as State
        }),
        "selection mode": CState("selection mode", ["selection mode activate", "selection mode", "selection made", "selection mode deactivate"], false),
        "selection made": CState("selection made", BaseVentures, false, async (message: Named, state: State, previousState: State): Promise<State | undefined> => {
            return map.get('base') as State
        }),
        "selection mode deactivate": CState("selection mode deactivate", [], false, async (message: Named, state: State, previousState: State): Promise<State | undefined> => {
            return map.get('base') as State
        })
    }

    // i'd prefer a native map.addAll method, but this allows a retrofit
    Object.keys(states).forEach(key => map.set(key, states[key]));

    if (!map.has("base")) {
        map.set("base", Base);
    }

    return mapObject;
}

type StateMahineReturn = {
    stateMachine: StateMachine
    stateNameMap: NameAccessMapInterface
}
const newStateMachine = (stateNameMap = StateNameMap(new Map()),
                      originState = "base"): StateMahineReturn => {
    const stateMachine = new StateMachine();
    stateMachine.initialize(stateNameMap, stateNameMap.getState(originState)!!);
    return { stateMachine, stateNameMap };
}

describe("state machine", () => {
    test("validate base state", () => {
        const { stateMachine } = newStateMachine();
        expect(stateMachine.getState("base")).toBeTruthy();
    })

    test("validate error moves to base state", async () => {
        const {stateMachine, stateNameMap} = newStateMachine();
        expect((await stateMachine.handleState(stateNameMap.getState("error")!!))?.name).toBe("base");
    })

    test("validate we receive the message passed to handleState", async () => {
        const message = new UpdateWaveMessage()
        message.name = "message-test"
        if (message.options) message.options.wave.text.color = "test green";
        const map = new Map()
        map.set("message-test", CState("message-test", BaseVentures, true,
            async (message: Named, state: State, previousState: State): Promise<State | undefined> => {
                const convertedMessage = (message as unknown as UpdateWaveMessage);
                expect(convertedMessage?.options?.wave.text.color).toBe("test green");
                return undefined
            }))
        const {stateMachine, stateNameMap} = newStateMachine(StateNameMap(map));

        expect((await stateMachine.handleState(message))?.name).toBe("base");
    })

    test("stop moves to base state", async () => {
        const {stateMachine, stateNameMap} = newStateMachine(StateNameMap(new Map()), "waving");
        expect((await stateMachine.handleState(stateNameMap.getState("stop")!!))?.name).toBe("base");
    })

    test("start moves to waving state", async () => {
        const {stateMachine, stateNameMap} = newStateMachine();
        expect((await stateMachine.handleState(stateNameMap.getState("start")!!))?.name).toBe("waving");
    })

    test("stop toggle moves to base state", async () => {
        const {stateMachine, stateNameMap} = newStateMachine(StateNameMap(new Map()), "waving");
        expect((await stateMachine.handleState(stateNameMap.getState("toggle stop")!!))?.name).toBe("base");
    })

    test("start toggle moves to waving state", async () => {
        const {stateMachine, stateNameMap} = newStateMachine();
        expect((await stateMachine.handleState(stateNameMap.getState("toggle start")!!))?.name).toBe("waving");
    })

    test("stop mouse moves to base state", async () => {
        const {stateMachine, stateNameMap} = newStateMachine(StateNameMap(new Map()), "waving");
        expect((await stateMachine.handleState(stateNameMap.getState("stop mouse")!!))?.name).toBe("base");
    })

    test("start mouse moves to waving state", async () => {
        const {stateMachine, stateNameMap} = newStateMachine();
        expect((await stateMachine.handleState(stateNameMap.getState("start mouse")!!))?.name).toBe("waving");
    })

    test("selection mode activate moves to selection mode state", async () => {
        const {stateMachine, stateNameMap} = newStateMachine();
        expect((await stateMachine.handleState(stateNameMap.getState("selection mode activate")!!))?.name).toBe("selection mode");
    })

    test("selection mode moves to base state", async () => {
        const {stateMachine, stateNameMap} = newStateMachine(StateNameMap(new Map()), "selection mode");
        expect((await stateMachine.handleState(stateNameMap.getState("selection mode")!!))?.name).toBe("base");
    })

    test("selection made moves to base state", async () => {
        const {stateMachine, stateNameMap} = newStateMachine(StateNameMap(new Map()), "selection mode");
        expect((await stateMachine.handleState(stateNameMap.getState("selection made")!!))?.name).toBe("base");
    })

    test("selection mode deactivate moves to base state", async () => {
        const {stateMachine, stateNameMap} = newStateMachine(StateNameMap(new Map()), "selection mode");
        expect((await stateMachine.handleState(stateNameMap.getState("selection mode deactivate")!!))?.name).toBe("base");
    })



    class TestRuntimeProxy implements IRuntimeProxy {
        public reponses: any[] = []
        public messagesSentToRunTime: any[] = []
        public messagesSendToTab: any[] = []

        onInstalled(callback: { (details: any): void }): void {
            callback(true)
        }

        onMessage(callback: { (message: any, sender: chrome.runtime.MessageSender, sendResponse: { (response?: any): void }): void }): void {
            callback(new UpdateWaveMessage({ options: new Options({}) }), { id: "unknown"} as unknown as MessageSender, (response) => {this.reponses.push(response)})
        }

        sendMessageToRuntime(message: any, callback: { (response: any): void }): void {
            this.messagesSentToRunTime.push(message)
            callback(true);
        }

        sendMessageToTab(tabId: number, message: any, callback: { (response: any): void }): void {
            this.messagesSendToTab.push(message)
            callback(true);
        }

    }

    test("selection mode deactivate moves to base state", async () => {
        const {stateMachine, stateNameMap} = newStateMachine(StateNameMap(new Map()), "selection mode");

        const client = new Client<Message<any>>(new GoogleClientMessengerService(
            {
                from: ClientLocation.POPUP,
                to: ClientLocation.CONTENT
            },
            new Map<string, IClientMessengerService<Message<any>>>(),
            new TestRuntimeProxy()))
        const useStateProxy = new UseStateProxy(null);
        const componentMachine = ReactMachine({
            initialState: "base",
            client,
            states: {
                base: async ({state, machine}: Partial<MachineComponentProps>): Promise<ComponentLog> => {
                    const [test, setTest] = state?.useState("test", false) || [undefined, undefined]
                    // todo: review: replace log and view with a deconstructor like useState and useReducer?
                    return Promise.resolve(log("base", <div/>));
                },
                complex: async ({state, machine}: Partial<MachineComponentProps>): Promise<ComponentLog> => {
                    // todo: implement as api client with settings mock and run test
                    const saved = await client.sendMessage(new ClientMessage("app/settings", "save", new UpdateWaveMessage({ options: new Options() })))
                    return Promise.resolve(log("base", <div>{saved}</div>));
                },
            }
        })

        // json react tree matching for output
        componentMachine.initialize();
        expect(componentMachine.getRenderTarget()).toBeTruthy()
    })

    test("multiple content clients per background client", () => {
        throw new Error("todo: dooo")
    })

    test("observe state change", async () => {
        const {stateMachine, stateNameMap} = newStateMachine(StateNameMap(new Map()), "selection mode");
        let changeCount = 0;
        let changedToState: (State | undefined)[] = [];
        stateMachine.getObservable()?.subscribe((state) => {
            changedToState.push(state);
            changeCount++;
        })
        expect((await stateMachine.handleState(stateNameMap.getState("selection mode deactivate")!!))?.name).toBe("base");
        expect(changedToState[0]!!.name).toBe("selection mode deactivate")
        expect(changedToState[1]!!.name).toBe("base")
        expect(changeCount).toBe(2)
    })

    test("bootstrap sends wakeup message and receives id and map for initialize", () => {

        const client = new Client<Message<any>>(new GoogleClientMessengerService(
            {
                from: ClientLocation.CONTENT,
                to: ClientLocation.POPUP
            },
            new Map<string, IClientMessengerService<Message<any>>>(),
            new TestRuntimeProxy()))
        const useStateProxy = new UseStateProxy(null);
        const componentMachine = ReactMachine({
            initialState: "base",
            client,
            states: {
                base: async ({state, machine}: Partial<MachineComponentProps>): Promise<ComponentLog> => {
                    const [test, setTest] = state?.useState("test", false) || [undefined, undefined]
                    // todo: review: replace log and view with a deconstructor like useState and useReducer?
                    return Promise.resolve(log("base", <div/>));
                },
                complex: async ({state, machine}: Partial<MachineComponentProps>): Promise<ComponentLog> => {
                    // todo: implement as api client with settings mock and run test
                    const saved = await client.sendMessage(new ClientMessage("app/settings", "save", new UpdateWaveMessage({ options: new Options() })))
                    return Promise.resolve(log("base", <div>{saved}</div>));
                },
            }
        })

        // json react tree matching for output
        componentMachine.initialize();
        expect(componentMachine.getRenderTarget()).toBeTruthy()
    })

    test("receives wakeup message and sends updated map back for initialization", () => {

        const client = new Client<Message<any>>(new GoogleClientMessengerService(
            {
                from: ClientLocation.POPUP,
                to: ClientLocation.CONTENT
            },
            new Map<string, IClientMessengerService<Message<any>>>(),
            new TestRuntimeProxy()))
        const useStateProxy = new UseStateProxy(null);
        const componentMachine = ReactMachine({
            initialState: "base",
            client,
            states: {
                base: async ({state, machine}: Partial<MachineComponentProps>): Promise<ComponentLog> => {
                    const [test, setTest] = state?.useState("test", false) || [undefined, undefined]
                    // todo: review: replace log and view with a deconstructor like useState and useReducer?
                    return Promise.resolve(log("base", <div/>));
                },
                complex: async ({state, machine}: Partial<MachineComponentProps>): Promise<ComponentLog> => {
                    // todo: implement as api client with settings mock and run test
                    const saved = await client.sendMessage(new ClientMessage("app/settings", "save", new UpdateWaveMessage({ options: new Options() })))
                    return Promise.resolve(log("base", <div>{saved}</div>));
                },
            }
        })

        // json react tree matching for output
        componentMachine.initialize();
        expect(componentMachine.getRenderTarget()).toBeTruthy()
    })
})
import * as React from "react"

import {describe, expect, test} from '@jest/globals'
import {FollowKeyChordObserver} from "../../../src/components/util/user-input";
import {Observable, Subscriber} from "rxjs";

describe('user-inputs', () => {
    test('matches key chords', (done: () => void) => {
        let callCount = 0;
        FollowKeyChordObserver(["w", "Shift"], new Observable<string>((subscriber: Subscriber<string>) => {
            subscriber.next("Shift");
            subscriber.next("w");
        }), () => false).subscribe((chord) => {
            callCount++;
            if (callCount > 1) {
                expect(chord).toBe(true);
                done();
            } else {
                expect(chord).toBe(false);
            }
        });
    });

    test('does not match key chords out of order', (done: () => void) => {
        let chordAssertCount = 0
        FollowKeyChordObserver(["w", "Shift"], new Observable<string>((subscriber: Subscriber<string>) => {
            subscriber.next("w");
            subscriber.next("Shift");
        }), () => false).subscribe((chord) => {
            expect(chord).toBe(false);
            chordAssertCount++;
            if (chordAssertCount >= 2) {
                done();
            }
        });
    });

    test('does not match wrong keys', (done: () => void) => {
        FollowKeyChordObserver(["w", "Shift"], new Observable<string>((subscriber: Subscriber<string>) => {
            subscriber.next("oops");
        }), () => false).subscribe((chord) => {
            expect(chord).toBe(false);
            done();
        });
    });

    test('calls complete if stop returns true', (done: () => void) => {
        FollowKeyChordObserver(["w", "Shift"],
            new Observable<string>((subscriber: Subscriber<string>) => {
                subscriber.next("Shift");
                subscriber.next("world");
                subscriber.next("wem");
                subscriber.next("moot");
            }),
            () => true)
        .subscribe({
            next: (chord) => {
                throw new Error("we should never call next if stop is true from the get go!");
            },
            error: (e) => console.log(e),
            complete: () => {
                done();
            }
        });
    });

    test('calls next and stop if a closure controls stop return', (done: () => void) => {
        let stop = false;
        let nextCalled = 0;
        FollowKeyChordObserver(["w", "Shift"], new Observable<string>((subscriber: Subscriber<string>) => {
            subscriber.next("Shift");
            stop = true;
            subscriber.next("w");
            subscriber.next("w");
        }), () => stop).subscribe({
            next: (chord) => {
                expect(chord).toBe(false);
                nextCalled++;
                expect(nextCalled).toBe(1);
            },
            error: (e) => console.log(e),
            complete: () => {
                done();
            }
        });
    });
});/**
 * @jest-environment jsdom
 */

import 'jest';
import React from 'react';
import GoButton from '../../src/components/go-button';
import { render, screen } from "@testing-library/react";
import user from "@testing-library/user-event";
import {act} from "react-test-renderer";

test('Link changes the class when hovered', async () => {
    let onGoCalled = false;
    const onGo = () => {
        onGoCalled = true;
    }

    let onStopCalled = false;
    const onStop = () => {
        onStopCalled = true;
    }

    render(
        <GoButton going={false} onStop={onStop} onGo={onGo} />
    );

    const goButtonUnClicked = screen.getByText('go!')
    expect(goButtonUnClicked).toBeTruthy();

    await act(async () => {
        await user.click(goButtonUnClicked);
    });

    expect(onGoCalled).toBeTruthy();

    await act(async () => {
        await user.click(goButtonUnClicked);
    });

    expect(onStopCalled).toBe(true);
    // can't get the testing-library to revalidate the value of the button, but neither could i get the json component
    //  to render with the updated information, so idk.

    // in the meantime...
    // todo: Matrial-UI seems like it suddenly wanted to start fighting with snapshot due to polluting classnames non-deterministically
    expect(goButtonUnClicked).toMatchSnapshot();
});/**
 * @jest-environment jsdom
 */

import 'jest';
import React from 'react';
import "@testing-library/react";
import {FindByText, render, screen, waitFor} from "@testing-library/react";

import { TextEncoder, TextDecoder } from 'util';

Object.assign(global, { TextDecoder, TextEncoder });
// import user from "@testing-library/user-event";
// import {act} from "react-test-renderer";
import ScanForInputField, {
    ActionType,
    assignKeyChord,
    ScanForInputStates
} from "../../src/components/scan-for-input-field";
import {KeyChord} from "../../src/components/util/user-input";
import {Named, State} from "../../src/util/state";
import StateMachine from "../../src/util/state-machine";
import {Observable, Subscriber} from "rxjs";
import "@testing-library/jest-dom"
import {ScanForInputFieldMachine, ScanForInputProps} from "../../src/components/scan-for-input-reactmachine";

const jsdom = require("jsdom");
const { JSDOM } = jsdom;

const MockWindowKeyObserver = (eventListener: {(event: KeyboardEvent): void} = () => {},
                               listenerReturn: {(eventListener: {(event: KeyboardEvent): void}): void},
                               subscriberAccess: {(subscriber: Subscriber<string>): void}) => {
    return (listenerReturn: {(eventListener: {(event: KeyboardEvent): void}): void}, preventDefault: boolean = true): Observable<string> => {
        listenerReturn(eventListener);
        // todo: document why ignored
        preventDefault = (preventDefault) || true
        return new Observable((subscriber) => {
            subscriberAccess(subscriber);
        })
    }
}

describe('Scan for input', () => {
    describe('assignKeyChord', () => {
        test('adds shift', () => {
            expect(assignKeyChord([], "Shift", 4).keyChord).toStrictEqual(["Shift"])
        })

        test('unshifts P, harharharhar', () => {
            expect(assignKeyChord(["Shift"], "P", 4).keyChord).toStrictEqual(["P", "Shift"])
        })

        test("concats 1,2,3,4 in filo order", () => {
            let keyChord: KeyChord = []
            keyChord = assignKeyChord(keyChord, "1", 4).keyChord || []
            keyChord = assignKeyChord(keyChord, "2", 4).keyChord || []
            keyChord = assignKeyChord(keyChord, "3", 4).keyChord || []

            expect(assignKeyChord(keyChord, "4", 4).keyChord).toStrictEqual(["4", "3", "2", "1"])
        })

        test('keylimit exceeded, clear and replace - after you P, you sometimes Shift', () => {
            expect(assignKeyChord(["P", "P", "P", "P"], "Shift", 4).keyChord).toStrictEqual(["Shift"])
        })

        test('clears when given "Escape" key', () => {
            const assignment = assignKeyChord(["Shift", "Shift", "Shift", "Shift"], "Escape", 4)
            expect(assignment.keyChord).toStrictEqual([])
            expect(assignment.escapeCalled).toStrictEqual(true)
        })
    })

    describe("ScanForInputField component", () => {
        test("state machine clears listener and scanning maps and asserts base state", async () => {
            const map = new Map<string, State>();
            const listenerMap = new Map<ActionType, EventListener>();
            const scanningMap = new Map<ActionType, KeyChord>();
            const stateMachineMap = new Map<ActionType, StateMachine>();


            let setChord: KeyChord | undefined = undefined;
            let savedChord: KeyChord | undefined = undefined;
            let cancelledChord: KeyChord | undefined = undefined;
            let setScan: boolean;
            let el: { (event: KeyboardEvent): void } | undefined = undefined;

            listenerMap.set("test", (e) => {
                throw new Error("should not call event")
            })
            scanningMap.set("test", ["1", "2", "3"])
            const machine = new StateMachine();
            stateMachineMap.set("test", machine)

            let nameAccessMap = ScanForInputStates({
                map,
                stateMachineMap,
                listenerMap,
                scanningMap,
                actionType: "test",
                keyLimit: 4,
                shortcut: ["W", "Shift"],
                setScanning: (scanning: boolean): void => {
                    setScan = scanning
                },
                setKeyChord: (chord: KeyChord): void => {
                    setChord = chord
                },
                onScan: (chord: KeyChord): void => {
                    savedChord = chord
                },
                onCancelScan: (chord: KeyChord): void => {
                    cancelledChord = chord
                },
                windowKeyDownObserver: MockWindowKeyObserver(
                    (e) => console.log(e),
                    eventListener => el = eventListener,
                    s => {
                    }
                ),
                shouldPreventDefault: true,
                window: new JSDOM().window
            });

            machine.initialize(nameAccessMap, nameAccessMap.getState("base") as State);
            expect((await machine.handleState({name: "base"} as Named))?.name).toBe("base");
            expect(listenerMap.size).toBe(0);
            expect(scanningMap.size).toBe(0);
            return Promise.resolve();
        });
        test("state machine calls onScan when save state", async () => {
            const map = new Map<string, State>();
            const listenerMap = new Map<ActionType, EventListener>();
            const scanningMap = new Map<ActionType, KeyChord>();
            const stateMachineMap = new Map<ActionType, StateMachine>();

            let setChord: KeyChord | undefined = undefined;
            let savedChord: KeyChord | undefined = undefined;
            let cancelledChord: KeyChord | undefined = undefined;
            let setScan: boolean;
            let el: {(event: KeyboardEvent): void} | undefined = undefined;
            let subscriber: Subscriber<string> | undefined = undefined;

            listenerMap.set("test", (e) => { throw new Error("should not call event") })
            scanningMap.set("test", ["1","2","3"])
            const machine = new StateMachine();
            stateMachineMap.set("test", machine)

            let nameAccessMap = ScanForInputStates({
                map, stateMachineMap, listenerMap, scanningMap, actionType: "test",keyLimit: 4, shortcut: ["W", "Shift"],
                setScanning: (scanning: boolean): void => {
                    setScan = scanning
                },
                setKeyChord: (chord: KeyChord): void => {
                    setChord = chord
                },
                onScan: (chord: KeyChord): void => {
                    savedChord = chord
                },
                onCancelScan: (chord: KeyChord): void => {
                    cancelledChord = chord
                },
                windowKeyDownObserver: MockWindowKeyObserver(
                    (e) => console.log(e),
                    eventListener => el = eventListener,
                    s => subscriber = s
                ),
                shouldPreventDefault: true,
                window: new JSDOM().window
            });

            machine.initialize(nameAccessMap, nameAccessMap.getState("base") as State);

            expect((await machine.handleState({ name: "start scanning" } as Named))?.name).toBe("scanning");
            const sub = subscriber as unknown as Subscriber<string>;
            sub.next("t")
            sub.next("e")
            sub.next("s")
            sub.next("t")

            expect((await machine.handleState({name: "save"} as Named))?.name).toBe("base");

            expect(setChord).toStrictEqual(["t", "e", "s", "t"].reverse())
            expect(savedChord).toStrictEqual(["t", "e", "s", "t"].reverse())

            expect(listenerMap.size).toBe(0);
            expect(scanningMap.size).toBe(0);
            return Promise.resolve();
        });

        test("calls escape when user presses escape when scanning is active", async () => {
            const map = new Map<string, State>();
            const listenerMap = new Map<ActionType, EventListener>();
            const scanningMap = new Map<ActionType, KeyChord>();
            const stateMachineMap = new Map<ActionType, StateMachine>();

            let setChord: KeyChord | undefined = undefined;
            let savedChord: KeyChord | undefined = undefined;
            let cancelledChord: KeyChord | undefined = undefined;
            let setScan: boolean;
            let el: { (event: KeyboardEvent): void } | undefined = undefined;
            let subscriber: Subscriber<string> | undefined = undefined;

            listenerMap.set("test", (e) => {
                throw new Error("should not call event")
            })
            scanningMap.set("test", ["1", "2", "3"])
            const machine = new StateMachine();
            stateMachineMap.set("test", machine)

            let nameAccessMap = ScanForInputStates({
                map,
                stateMachineMap,
                listenerMap,
                scanningMap,
                actionType: "test",
                keyLimit: 4,
                shortcut: cancelledChord as unknown as KeyChord,
                setScanning: (scanning: boolean): void => {
                    setScan = scanning
                },
                setKeyChord: (chord: KeyChord): void => {
                    setChord = chord
                },
                onScan: (chord: KeyChord): void => {
                    savedChord = chord
                },
                onCancelScan: (chord: KeyChord): void => {
                    cancelledChord = chord
                },
                windowKeyDownObserver: MockWindowKeyObserver(
                    (e) => console.log(e),
                    eventListener => el = eventListener,
                    s => subscriber = s
                ),
                shouldPreventDefault: true,
                window: new JSDOM().window
            });

            machine.initialize(nameAccessMap, nameAccessMap.getState("base") as State);

            expect((await machine.handleState({name: "start scanning"} as Named))?.name).toBe("scanning");

            (subscriber as unknown as Subscriber<string>).next("Escape")

            return new Promise((resolve, reject) => {
                waitFor(() => {
                    expect(machine.currentState?.name).toBe("base");
                    expect(cancelledChord).toBe(cancelledChord)

                    expect(listenerMap.size).toBe(0);
                    expect(scanningMap.size).toBe(0);
                    resolve(undefined);
                }, { timeout: 3000 })
            })

        })

        test("reverts to shortcut when state transition is \"stop scanning\" and scanning is active", async () => {
            const map = new Map<string, State>();
            const listenerMap = new Map<ActionType, EventListener>();
            const scanningMap = new Map<ActionType, KeyChord>();
            const stateMachineMap = new Map<ActionType, StateMachine>();

            let setChord: KeyChord | undefined = undefined;
            let savedChord: KeyChord | undefined = undefined;
            let cancelledChord: KeyChord | undefined = undefined;
            let setScan: boolean;
            let el: { (event: KeyboardEvent): void } | undefined = undefined;
            let subscriber: Subscriber<string> | undefined = undefined;

            listenerMap.set("test", (e) => {
                throw new Error("should not call event")
            })
            scanningMap.set("test", ["1", "2", "3"])
            const machine = new StateMachine();
            stateMachineMap.set("test", machine)

            let nameAccessMap = ScanForInputStates({
                map,
                stateMachineMap,
                listenerMap,
                scanningMap,
                actionType: "test",
                keyLimit: 4,
                shortcut: cancelledChord as unknown as KeyChord,
                setScanning: (scanning: boolean): void => {
                    setScan = scanning
                },
                setKeyChord: (chord: KeyChord): void => {
                    setChord = chord
                },
                onScan: (chord: KeyChord): void => {
                    savedChord = chord
                },
                onCancelScan: (chord: KeyChord): void => {
                    cancelledChord = chord
                },
                windowKeyDownObserver: MockWindowKeyObserver(
                    (e) => console.log(e),
                    eventListener => el = eventListener,
                    s => subscriber = s
                ),
                shouldPreventDefault: true,
                window: new JSDOM().window
            });

            machine.initialize(nameAccessMap, nameAccessMap.getState("base") as State);

            expect((await machine.handleState({name: "start scanning"} as Named))?.name).toBe("scanning");

            const sub = subscriber as unknown as Subscriber<string>
            sub.next("l")
            sub.next("o")
            sub.next("m")
            sub.next("e")

            expect((await machine.handleState({name: "revert"} as Named))?.name).toBe("scanning");
            expect((await machine.handleState({name: "stop scanning"} as Named))?.name).toBe("base");
            expect(cancelledChord).toBe(cancelledChord)

            expect(listenerMap.size).toBe(0);
            expect(scanningMap.size).toBe(0);
            return Promise.resolve()
        })


        test("reverts to shortcut when state transition is \"stop scanning\" and scanning is active", async () => {
            const map = new Map<string, State>();
            const listenerMap = new Map<ActionType, EventListener>();
            const scanningMap = new Map<ActionType, KeyChord>();
            const stateMachineMap = new Map<ActionType, StateMachine>();

            let setChord: KeyChord | undefined = undefined;
            let savedChord: KeyChord | undefined = undefined;
            let shortcut: KeyChord | undefined = ["1", "2", "3"];
            let setScan: boolean;
            let el: { (event: KeyboardEvent): void } | undefined = undefined;
            let subscriber: Subscriber<string> | undefined = undefined;

            listenerMap.set("test", (e) => {
                throw new Error("should not call event")
            })
            scanningMap.set("test", ["1", "2", "3"])
            const machine = new StateMachine();
            stateMachineMap.set("test", machine)

            let nameAccessMap = ScanForInputStates({
                map,
                stateMachineMap,
                listenerMap,
                scanningMap,
                actionType: "test",
                keyLimit: 4,
                shortcut: shortcut as unknown as KeyChord,
                setScanning: (scanning: boolean): void => {
                    setScan = scanning
                },
                setKeyChord: (chord: KeyChord): void => {
                    setChord = chord
                },
                onScan: (chord: KeyChord): void => {
                    savedChord = chord
                },
                onCancelScan: (chord: KeyChord): void => {
                    throw new Error("not to be called in this test")
                },
                windowKeyDownObserver: MockWindowKeyObserver(
                    (e) => console.log(e),
                    eventListener => el = eventListener,
                    s => subscriber = s
                ),
                shouldPreventDefault: true,
                window: new JSDOM().window
            });

            machine.initialize(nameAccessMap, nameAccessMap.getState("base") as State);

            expect((await machine.handleState({name: "start scanning"} as Named))?.name).toBe("scanning");

            const sub = subscriber as unknown as Subscriber<string>
            sub.next("l")
            sub.next("o")
            sub.next("m")
            sub.next("e")

            expect((await machine.handleState({name: "revert"} as Named))?.name).toBe("scanning");

            sub.next("3")
            sub.next("2")
            sub.next("1")

            expect((await machine.handleState({name: "save"} as Named))?.name).toBe("base");
            expect(savedChord).toStrictEqual(shortcut)

            expect(listenerMap.size).toBe(0);
            expect(scanningMap.size).toBe(0);

            return Promise.resolve()
        })

        test("clears when clear state entered", async () => {
            const map = new Map<string, State>();
            const listenerMap = new Map<ActionType, EventListener>();
            const scanningMap = new Map<ActionType, KeyChord>();
            const stateMachineMap = new Map<ActionType, StateMachine>();

            let setChord: KeyChord | undefined = undefined;
            let savedChord: KeyChord | undefined = undefined;
            let cancelledChord: KeyChord | undefined = undefined;
            let setScan: boolean;
            let el: { (event: KeyboardEvent): void } | undefined = undefined;
            let subscriber: Subscriber<string> | undefined = undefined;

            listenerMap.set("test", (e) => {
                throw new Error("should not call event")
            })
            scanningMap.set("test", ["1", "2", "3"])
            const machine = new StateMachine();
            stateMachineMap.set("test", machine)

            let nameAccessMap = ScanForInputStates({
                map, stateMachineMap, listenerMap, scanningMap, actionType: "test", keyLimit: 4, shortcut: ["1", "2"],
                setScanning: (scanning: boolean): void => {
                    setScan = scanning
                },
                setKeyChord: (chord: KeyChord): void => {
                    setChord = chord
                },
                onScan: (chord: KeyChord): void => {
                    savedChord = chord
                },
                onCancelScan: (chord: KeyChord): void => {
                    cancelledChord = chord
                },
                windowKeyDownObserver: MockWindowKeyObserver(
                    (e) => console.log(e),
                    eventListener => el = eventListener,
                    s => subscriber = s
                ),
                shouldPreventDefault: true,
                window: new JSDOM().window
            });

            machine.initialize(nameAccessMap, nameAccessMap.getState("base") as State);

            expect((await machine.handleState(machine.getState("start scanning")!))?.name).toBe("scanning");

            expect((await machine.handleState(machine.getState("clear")!))?.name).toBe("scanning");

            (subscriber as unknown as Subscriber<string>).next("o")

            expect((await machine.handleState(machine.getState("save")!))?.name).toBe("base");

            expect(savedChord).toStrictEqual(["o"]);

            expect(listenerMap.size).toBe(0);
            expect(scanningMap.size).toBe(0);

            return Promise.resolve()
        })

        test("test react machine", () => {
            let scanned = false;
            let cancelScan = false;
            const instance = ScanForInputFieldMachine({
              actionType: "Toggle",
              shortcut: ["shift", "k"],
              keyLimit: 4,
              onScan: () => {scanned = true},
              onCancelScan: () => {cancelScan = true}
            } as ScanForInputProps)
            const InputScanner = instance.getRenderTarget()

            expect(instance.getLogView().views.length > 0).toBe(true);
            //<InputScanner />
        })
    })
})<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>🌊 reader</title>
</head>
<body>
    <div class="test">
        <p>Lorem ipsum dolor sit amet, consectetur adipis, waver readuris, epitus tex rex, aminus puuters.</p>
        <p>Aetch tea tea colonium slashius slashius dotius slashius dotius dotius commentanum.</p>
        <p>Lorem ipsum dolor sit amet, consectetur adipis, waver readuris, epitus tex rex, aminus puuters.</p>
        <p>Aetch tea tea colonium slashius slashius dotius slashius dotius dotius commentanum.</p>
        <p>Lorem ipsum dolor sit amet, consectetur adipis, waver readuris, epitus tex rex, aminus puuters.</p>
        <p>Aetch tea tea colonium slashius slashius dotius slashius dotius dotius commentanum.</p>
        <p>Lorem ipsum dolor sit amet, consectetur adipis, waver readuris, epitus tex rex, aminus puuters.</p>
        <p>Aetch tea tea colonium slashius slashius dotius slashius dotius dotius commentanum.</p>
        <p>Lorem ipsum dolor sit amet, consectetur adipis, waver readuris, epitus tex rex, aminus puuters.</p>
        <p>Aetch tea tea colonium slashius slashius dotius slashius dotius dotius commentanum.</p>
        <p>Lorem ipsum dolor sit amet, consectetur adipis, waver readuris, epitus tex rex, aminus puuters.</p>
        <p>Aetch tea tea colonium slashius slashius dotius slashius dotius dotius commentanum.</p>
        <p>Lorem ipsum dolor sit amet, consectetur adipis, waver readuris, epitus tex rex, aminus puuters.</p>
        <p>Aetch tea tea colonium slashius slashius dotius slashius dotius dotius commentanum.</p>
        <p>Lorem ipsum dolor sit amet, consectetur adipis, waver readuris, epitus tex rex, aminus puuters.</p>
        <p>Aetch tea tea colonium slashius slashius dotius slashius dotius dotius commentanum.</p>
        <p>Lorem ipsum dolor sit amet, consectetur adipis, waver readuris, epitus tex rex, aminus puuters.</p>
        <p>Aetch tea tea colonium slashius slashius dotius slashius dotius dotius commentanum.</p>
        <p>Lorem ipsum dolor sit amet, consectetur adipis, waver readuris, epitus tex rex, aminus puuters.</p>
        <p>Aetch tea tea colonium slashius slashius dotius slashius dotius dotius commentanum.</p>
        <p>Lorem ipsum dolor sit amet, consectetur adipis, waver readuris, epitus tex rex, aminus puuters.</p>
        <p>Aetch tea tea colonium slashius slashius dotius slashius dotius dotius commentanum.</p>
    </div>
</body>
</html>import SettingsService, {DomainPaths, DomainSettings, SettingsRegistry} from "../../src/services/settings";
import SelectorService from "../../src/services/selector";
import Options, {DeepEquals} from "../../src/models/options"
import { Tab } from "../../src/util/util";
import DoneCallback = jest.DoneCallback;
import {withMockSettingsService} from "../components/util/mock-settings-service";
import {SelectorsDefaultFactory} from "../../src/models/defaults";



describe("selector service", () => {
    test("assigns protocol and path heavy url to hostname", () => {
        // TODO: write
    })

    test("get current settings", (done: DoneCallback) => {
        withMockSettingsService(async (settingsService: SettingsService, accessRegistry) => {
            const fartmap = new Map<string, Options>()
            fartmap.set("/fart", new Options({
                selectors: ["successful", "test"]
            }));
            accessRegistry()["www.fart.com"] = new DomainSettings("www.fart.com", fartmap)
            const successfulTest = (await settingsService.getCurrentSettings())?.selectors.join(" ");
            expect(successfulTest).toBe("successful test");
            done();
        })
    })

    test("get current settings with no defaulted map", (done: DoneCallback) => {
        withMockSettingsService(async (settingsService: SettingsService, accessRegistry) => {
            const selectors = (await settingsService.getCurrentSettings())?.selectors;
            expect(selectors).toStrictEqual(SelectorsDefaultFactory());
            done();
        }, "http://fart.fart.com/fart")
    })

    test("update current settings", (done: DoneCallback) => {
        withMockSettingsService(async (settingsService: SettingsService, accessRegistry) => {
            const fartmap = new Map<string, Options>()
            fartmap.set("/fart", new Options({
                selectors: ["successful", "test"]
            }));
            accessRegistry()["www.fart.com"] = new DomainSettings("www.fart.com", fartmap)
            expect((await settingsService.getCurrentSettings()).selectors.join(" ")).toBe("successful test");

            await settingsService.updateCurrentSettings(options => {
                options.selectors.push(", this be")
                return options;
            })

            expect((await settingsService.getCurrentSettings()).selectors.join(" ")).toBe("successful test , this be"); // mmmmhhmmmmm!
            done();
        })
    })

    test("test equals for Options", (done: DoneCallback) => {
        withMockSettingsService(async (settingsService: SettingsService, accessRegistry) => {
            expect(Options.OptionsEqual(await settingsService.getCurrentSettings(),
                JSON.parse(JSON.stringify(await settingsService.getCurrentSettings())))).toBe(true)
            done();
        })
    })

    test("get settings for domain & path", (done: DoneCallback) => {
        withMockSettingsService(async (settingsService: SettingsService, accessRegistry) => {
            const fartmap = new Map<string, Options>()
            fartmap.set("/fart", new Options({
                selectors: ["successful", "test"]
            }));
            accessRegistry()["www.fart.com"] = new DomainSettings("www.fart.com", fartmap)
            const borkmap = new Map<string, Options>()
                borkmap.set("/pizza", new Options({
                    selectors: ["thefty", "biggons", "chompers"]
                }));
                borkmap.set("/BACON", new Options({
                    selectors: ["bacon", "BACON", "BAAAAAAAAACOOON", "BBAAAA... *runs into the distance, barrels into the room skidding* ... COOOONNNN "]
                }));
            accessRegistry()["www.bork.com"] = new DomainSettings("www.bork.com", borkmap)
            expect((await settingsService.getCurrentSettings()).selectors.join(" ")).toBe("successful test");
            expect((await settingsService.getPathOptionsForDomain("http://www.bork.com", "/pizza"))?.selectors.join(" ")).toBe("thefty biggons chompers");
            expect((await settingsService.getPathOptionsForDomain("http://www.bork.com", "/BACON"))?.selectors.join(" ")).toBe("bacon BACON BAAAAAAAAACOOON BBAAAA... *runs into the distance, barrels into the room skidding* ... COOOONNNN ");
            done();
        })
    })

    test("get settings for domain", (done: DoneCallback) => {
        withMockSettingsService(async (settingsService: SettingsService, accessRegistry) => {
            const fartmap = new Map<string, Options>()
            fartmap.set("/fart", new Options({
                selectors: ["successful", "test"]
            }));
            accessRegistry()["www.fart.com"] = new DomainSettings("www.fart.com", fartmap)
            const borkmap = new Map<string, Options>()
            borkmap.set("/pizza", new Options({
                selectors: ["thefty", "biggons", "chompers"]
            }));
            borkmap.set("/BACON", new Options({
                selectors: ["bacon", "BACON", "BAAAAAAAAACOOON", "BBAAAA... *runs into the distance, barrels into the room skidding* ... COOOONNNN "]
            }));
            accessRegistry()["www.bork.com"] = new DomainSettings("www.bork.com", borkmap)
            expect((await settingsService.getCurrentSettings()).selectors.join(" ")).toBe("successful test");
            expect((await settingsService.getSettingsForDomain("www.bork.com"))?.pathSettings.has("/pizza")).toBeTruthy();
            expect((await settingsService.getSettingsForDomain("www.bork.com"))?.pathSettings.has("/BACON")).toBeTruthy();
            done();
        })
    })

    test("get settings for domain no domain", (done: DoneCallback) => {
        withMockSettingsService(async (settingsService: SettingsService, accessRegistry) => {
            const fartmap = new Map<string, Options>()
            fartmap.set("/fart", new Options({
                selectors: ["successful", "test"]
            }));
            accessRegistry()["www.fart.com"] = new DomainSettings("www.fart.com", fartmap)

            expect((await settingsService.getCurrentSettings()).selectors.join(" ")).toBe("successful test");
            try {
                await settingsService.getSettingsForDomain("www.bork.com", false)
                expect("should not reach here").toBe("something it't not");
            } catch (e) {
                done();
            }
        })
    })

    test("add settings for domain", (done: DoneCallback) => {
        withMockSettingsService(async (settingsService: SettingsService, accessRegistry) => {
            const fartmap = new Map<string, Options>()
            fartmap.set("/fart", new Options({
                selectors: ["successful", "test"]
            }));
            accessRegistry()["www.fart.com"] = new DomainSettings("www.fart.com", fartmap)
            const borkmap = new Map<string, Options>()
            borkmap.set("BACON", new Options({
                selectors: ["bacon", "BACON", "BAAAAAAAAACOOON", "BBAAAA... *runs into the distance, barrels into the room skidding* ... COOOONNNN "]
            }));
            accessRegistry()["www.bork.com"] = new DomainSettings("www.bork.com", borkmap);
            expect((await settingsService.getCurrentSettings()).selectors.join(" ")).toBe("successful test");
            await settingsService.addSettingsForDomain("www.bork.com", "pizza", new Options({
                selectors: ["thefty", "biggons", "chompers"]
            }))
            expect((await settingsService.getSettingsForDomain("www.bork.com"))?.pathSettings.has("pizza")).toBeTruthy();
            expect((await settingsService.getPathOptionsForDomain("www.bork.com", "pizza"))?.selectors.join(" ")).toBe("thefty biggons chompers");
            expect((await settingsService.getSettingsForDomain("www.bork.com"))?.pathSettings.has("BACON")).toBeTruthy();

            // never before seen domain
            await settingsService.addSettingsForDomain("bacon.com", "pizza", new Options({
                selectors: ["pizza", "bacon", "does not bzzzrrrp- aaacon! BACON! BACON bacon... pizza?"]
            }))

            expect((await settingsService.getPathOptionsForDomain("bacon.com", "pizza"))?.selectors.join(" ")).toBe("pizza bacon does not bzzzrrrp- aaacon! BACON! BACON bacon... pizza?");
            done();
        })
    })

    test("add settings for domain", (done: DoneCallback) => {
        withMockSettingsService(async (settingsService: SettingsService, accessRegistry) => {
            const fartmap = new Map<string, Options>()
            fartmap.set("/fart", new Options({
                selectors: ["successful", "test"]
            }));
            accessRegistry()["www.fart.com"] = new DomainSettings("www.fart.com", fartmap)
            const borkmap = new Map<string, Options>()
            borkmap.set("/BACON", new Options({
                selectors: ["bacon", "BACON", "BAAAAAAAAACOOON", "BBAAAA... *runs into the distance, barrels into the room skidding* ... COOOONNNN "]
            }));
            accessRegistry()["www.bork.com"] = new DomainSettings("www.bork.com", borkmap)
            expect((await settingsService.getCurrentSettings()).selectors.join(" ")).toBe("successful test");
            await settingsService.addSettingsForDomain("www.bork.com", "/pizza", new Options({
                selectors: ["thefty", "biggons", "chompers"]
            }))
            expect((await settingsService.getSettingsForDomain("www.bork.com"))?.pathSettings.has("/pizza")).toBeTruthy();
            expect((await settingsService.getPathOptionsForDomain("http://www.bork.com", "/pizza"))?.selectors.join(" ")).toBe("thefty biggons chompers");
            await settingsService.copySettingsFromDomain((await settingsService.getSettingsForDomain("http://www.fart.com")) as unknown as DomainSettings, "/fart", "www.bork.com", "/fart", false)
            expect((await settingsService.getPathOptionsForDomain("http://www.bork.com", "/fart", false, false))?.selectors.join(" ")).toBe("successful test")
            // thaaaat's why dog farts are so bad...
            done();
        })
    })

    test("remove settings for domain", (done: DoneCallback) => {
        withMockSettingsService(async (settingsService: SettingsService, accessRegistry) => {
            const fartmap = new Map<string, Options>()
            fartmap.set("/fart", new Options({
                selectors: ["successful", "test"]
            }));
            accessRegistry()["www.fart.com"] = new DomainSettings("www.fart.com", fartmap)
            const BACONmap = new Map<string, Options>()
            BACONmap.set("/BACON", new Options({
                selectors: ["bacon", "BACON", "BAAAAAAAAACOOON", "BBAAAA... *runs into the distance, barrels into the room skidding* ... COOOONNNN "]
            }));
            accessRegistry()["www.bork.com"] = new DomainSettings("www.bork.com", BACONmap)
            expect((await settingsService.getCurrentSettings()).selectors.join(" ")).toBe("successful test");
            await settingsService.addSettingsForDomain("www.bork.com", "/pizza", new Options({
                selectors: ["thefty", "biggons", "chompers"]
            }))
            expect((await settingsService.getSettingsForDomain("www.bork.com"))?.pathSettings.has("/pizza")).toBeTruthy();
            expect((await settingsService.getPathOptionsForDomain("www.bork.com", "/pizza"))?.selectors.join(" ")).toBe("thefty biggons chompers");
            await settingsService.copySettingsFromDomain((await settingsService.getSettingsForDomain("www.fart.com")) as unknown as DomainSettings, "/fart", "www.bork.com", "/fart", false)
            expect((await settingsService.getPathOptionsForDomain("www.bork.com", "/fart", false, false))?.selectors.join(" ")).toBe("successful test")
            // thaaaat's why dog farts are so bad...

            await settingsService.removeSettingsForDomainPath("www.bork.com", "/pizza", false);
            // do your unit tests smell?
            expect(await settingsService.getPathOptionsForDomain("www.bork.com", "/pizza", false, false)).toBeUndefined()

            await settingsService.removeSettingsForDomain("www.fart.com")
            expect(await settingsService.getSettingsRegistryForDomain("www.fart.com", false)).toBeUndefined()
            done();
        })
    })

    test("get domains and paths", (done: DoneCallback) => {
        withMockSettingsService(async (settingsService: SettingsService, accessRegistry) => {
            const fartmap = new Map<string, Options>()
            fartmap.set("/fart", new Options({
                selectors: ["successful", "test"]
            }));
            accessRegistry()["www.fart.com"] = new DomainSettings("www.fart.com", fartmap)
            const borkmap = new Map<string, Options>()
            borkmap.set("/BACON", new Options({
                selectors: ["bacon", "BACON", "BAAAAAAAAACOOON", "BBAAAA... *runs into the distance, barrels into the room skidding* ... COOOONNNN "]
            }));
            accessRegistry()["www.bork.com"] = new DomainSettings("www.bork.com", borkmap)
            expect((await settingsService.getCurrentSettings()).selectors.join(" ")).toBe("successful test");
            await settingsService.addSettingsForDomain("www.bork.com", "/pizza", new Options({
                selectors: ["thefty", "biggons", "chompers"]
            }))
            const domainsAndPaths = await settingsService.getDomainsAndPaths()
            expect(domainsAndPaths.find((dp: DomainPaths) => dp.domain === "www.fart.com")).toBeTruthy();
            expect(domainsAndPaths.find((dp: DomainPaths) => dp.paths.includes("/BACON"))).toBeTruthy();

            done();
        })
    })

    test("options", () => {
        expect(DeepEquals(true, false)).toBe(false);
        expect(DeepEquals(false, false)).toBe(true)
        expect(DeepEquals("expect", "not")).toBe(false)
        expect(DeepEquals({ prop: "test" }, { prop: "test" })).toBe(true)
        expect(DeepEquals({ prop: "test1" }, { prop: "test2" })).toBe(false)
        expect(DeepEquals([1,2,3], [1,2,3])).toBe(true)
        expect(DeepEquals([1,2,3], [1,2,"3"])).toBe(false)
        expect(DeepEquals([1,2,3], 0)).toBe(false)
    })
})
import SettingsService, {DomainSettings, SettingsDAOInterface, SettingsRegistry} from "../../src/services/settings";
import SelectorService from "../../src/services/selector";
import {SelectorDefault} from "../../src/models/defaults";
import DoneCallback = jest.DoneCallback;
import Options from "../../src/models/options";
import Wave from "../../src/models/wave";

type Proxy = {
    settingsRegistry: SettingsRegistry
}
const withMockSettingsService = async (context: {(settingsService: SettingsService, accessRegistry: {(): SettingsRegistry}): void}): Promise<void> => {
    let proxy: Proxy = { settingsRegistry: {} };

    const fartmap = new Map<string, Options>()
    fartmap.set("/fart", new Options());
    proxy.settingsRegistry["www.fart.com"] = new DomainSettings("www.fart.com", fartmap)

    const settings = new SettingsService(
        (callback: { (settingsRegistry: SettingsRegistry): void }): void => callback(proxy.settingsRegistry),
        () => Promise.resolve("http://www.fart.com/fart"),
        (newSettingsRegistry: SettingsRegistry, callback?: {(): void}) => {
            proxy.settingsRegistry = newSettingsRegistry;
            if (callback) callback();
        })
    return new Promise(async (resolve) => {
        context(settings, () => proxy.settingsRegistry);
        resolve();
    });
}

describe("selector service", () => {
    test("adds a selector", (done: DoneCallback) => {
        withMockSettingsService(async (settingsService: SettingsService, accessRegistry) => {
            const service = new SelectorService(settingsService)
            await service.addSelector("test selector push");
            await service.useSelector("test selector expect")

            expect(await service.currentSelector()).toBe("test selector expect")
            expect((await service.getSelectors()).includes("test selector push")).toBeTruthy()
            done();
        })
    })

    test("remove a selector", (done: DoneCallback) => {
        withMockSettingsService(async (settingsService: SettingsService, accessRegistry) => {
            const service = new SelectorService(settingsService)
            await service.addSelector("test selector push");
            await service.addSelector("test selector expect");
            await service.useSelector("test selector push");
            await service.removeSelector("test selector push");

            expect(await service.currentSelector()).toBe("test selector expect")
            expect((await service.getSelectors()).includes("test selector push")).toBeFalsy()
            done();
        })
    })

    test("use a selector", (done: DoneCallback) => {
        withMockSettingsService(async (settingsService: SettingsService, accessRegistry) => {
            const service = new SelectorService(settingsService)
            await service.addSelector("test selector push");
            await service.addSelector("test selector expect");
            expect(await service.currentSelector()).toBe(SelectorDefault)
            await service.useSelector("test selector expect");

            expect(await service.currentSelector()).toBe("test selector expect")
            expect((await service.getSelectors()).includes("test selector push")).toBeTruthy()
            done();
        })
    })

    test("current selector",(done: DoneCallback) => {
        withMockSettingsService(async (settingsService: SettingsService, accessRegistry) => {
            const service = new SelectorService(settingsService)
            await service.addSelector("test selector push");
            await service.addSelector("test selector expect");
            expect(await service.currentSelector()).toBe(SelectorDefault);
            await service.useSelector("test selector expect");
            expect(await service.currentSelector()).toBe("test selector expect");
            await service.removeSelector("test selector expect");
            expect(await service.currentSelector()).toBe("test selector push");

            expect((await service.getSelectors()).includes(SelectorDefault)).toBeTruthy()

            await service.removeSelector("test selector push");
            expect(await service.currentSelector()).toBe(SelectorDefault);
            done();
        })
    })
})
/**
 * @jest-environment jsdom
 */
import * as React from "react"
import "jest";

import { TextEncoder, TextDecoder } from 'util';

Object.assign(global, { TextDecoder, TextEncoder });

import {render, screen, waitFor} from "@testing-library/react";

import { screen as domScreen } from "@testing-library/dom";

import {
    ColorGeneratorService,
    DefaultSplitComplement,
    DefaultTetrad,
    DefaultTriad,
    ForThoustPanel, HtmlElement,
    SelectorHierarchy,
    SizeFunctions,
    SizeProperties
} from "../../src/services/selector-hierarchy";
import {SelectorsDefaultFactory} from "../../src/models/defaults";
import {getDefaultFontSizeREM} from "../../src/util/util";

import styled from 'styled-components';
//
import "@testing-library/jest-dom"
import {
    HierarchySelectorComponentProps,
    MountOrFindSelectorHierarchyComponent
} from "../../src/components/selector-hierarchy";
import {FunctionComponent, ReactElement} from "react";
import {withMockSettingsService} from "../components/util/mock-settings-service";
import {act} from "react-dom/test-utils";
import SelectorInput from "../../src/components/selector-input";
import {click} from "@testing-library/user-event/convenience/click";
import {userEvent} from "@testing-library/user-event/setup/index";

const jsdom = require("jsdom");
const { JSDOM } = jsdom;

const Container = styled.div``;

type JSDOMLike = {
    window: any
}
const withDocument = (actionFn: { (doc: Document, window: Window, dom: any): void }, htmlFontSize = "font-size: 10px"): JSDOMLike => {
    // const Component = () => {
    //     return (<Container id={"mount"} />);
    // }
    // const div = render(<Component />)
    const dom = new JSDOM(`<html style="${htmlFontSize}"><body><div id='mount'></div></body></html>`, {}); //new Document()
    Object.defineProperty(dom.window.HTMLHtmlElement.prototype, 'clientHeight', { value: 768 });
    Object.defineProperty(dom.window.HTMLHtmlElement.prototype, 'clientWidth', { value: 1024 });

    actionFn(dom.window.document, dom.window, dom);

    return dom;
}

describe("selector quad service", () => {
   test("selector triad generator", () => {
       withDocument((doc, window) => {
           const elem = doc.createElement("p");
           const colorGeneratorService = new ColorGeneratorService()
           const selectorHierarchyService = new SelectorHierarchy(colorGeneratorService)
           const aside = doc.createElement("p")
           doc.querySelector("#mount")?.appendChild(elem)
           elem.appendChild(aside)

           elem.classList.add("test")
           elem.style.width = "1000px"
           elem.style.marginLeft = "1000px"
           elem.style.height = "1000px"
           elem.style.marginTop = "1000px"
           aside.classList.add("test-child")

           const quads = [
               ...DefaultSplitComplement,
               ...DefaultTetrad,
               ...DefaultSplitComplement
           ]

           const thoustSelection = ForThoustPanel(
               doc, [".test", ".test-child", ...SelectorsDefaultFactory()].join(", "),
               selectorHierarchyService, undefined,
               getDefaultFontSizeREM.bind(null, window)
           );

           // there should be 3 islands, 2 with test and test-child, and a 3rd for p
           // @ts-ignore
           expect(quads.includes([...thoustSelection.htmlSelectors.values()][0].color)).toBeTruthy()
           // critic acid yum

           // expect uhhh the colors duke, the colors
       })
   })

    describe('ColorGeneratorService', function () {
        const colorService = new ColorGeneratorService();
        const uniqueSet = (set: any[]) => { return !set.find((s, i) => set.find((o, j) => o === s && i !== j ))}
        test("color generator service provides expected defaults for tetrads", () => {
            // test defaults and randomization, but leave the color picking testing to tinycolor
            const tetrad = colorService.getDefaultTetrad(0)
            expect(tetrad[0].toString("hex")).toBe(DefaultTetrad[0].toString("hex"))
            expect(uniqueSet(tetrad)).toBeTruthy();

            let randomized = false;
            while (!randomized) {
                randomized = randomized || colorService.getDefaultTetrad()[0] !== DefaultTetrad[0]
            }
            expect(randomized).toBeTruthy()
        })
        test("color generator service provides expected defaults for triads", () => {
            const triad = colorService.getDefaultTriad(0)
            expect(triad[0].toString("hex")).toBe(DefaultTriad[0].toString("hex"))
            expect(uniqueSet(triad)).toBeTruthy();

            let randomized = false;
            while (!randomized) {
                randomized = randomized || colorService.getDefaultTriad()[0] !== DefaultTriad[0]
            }
            expect(randomized).toBeTruthy()
        })
        test("color generator service provides expected defaults for split complements", () => {
            const complements = colorService.getDefaultSplitComponent(0)
            expect(complements[0].toString("hex")).toBe(DefaultSplitComplement[0].toString("hex"))
            expect(uniqueSet(complements)).toBeTruthy();

            let randomized = false;
            while (!randomized) {
                randomized = randomized || colorService.getDefaultSplitComponent()[0] !== DefaultSplitComplement[0]
            }
            expect(randomized).toBeTruthy()
        })
    });

   describe("size calculation", () => {
       test("calc size px", () => {
           const window = withDocument((doc, window) => {
               const elem = doc.createElement("div");
               doc.querySelector('#mount')?.appendChild(elem)
               elem.style.left = "2000000000000px";
               expect(SizeFunctions.calcSize(elem, elem.style.left, SizeProperties.OTHER,
                   getDefaultFontSizeREM.bind(null, window))).toBe(2000000000000)
           })
       })
       test("calc size px width with clientWidth", () => {
           withDocument((doc, window) => {
               const elem = doc.createElement("div");
               elem.style.width = "2000000000000px"

               expect(SizeFunctions.calcSize(elem, elem.style.left, SizeProperties.WIDTH,
                   getDefaultFontSizeREM.bind(null, window))).toBe(0)
               // jsdom fails setting this with define property as recommended several places, but at least it differs significantly
               // todo: make sure these are useful, and if not, provide a clientWidth || calcSize(..., SizeProperties.OTHER, ...)
           })
       })
       test("calc size px height with clientHeight", () => {
           withDocument((doc, window) => {
               const elem = doc.createElement("div");
               elem.style.height = "2000000000000px"
               expect(SizeFunctions.calcSize(elem, elem.style.left, SizeProperties.HEIGHT,
                   getDefaultFontSizeREM.bind(null, window))).toBe(0)
               // jsdom fails setting this with define property as recommended several places, but at least it differs significantly
               // todo: make sure these are useful, and if not, provide a clientHeight || calcSize(..., SizeProperties.OTHER, ...)
           })
       })

       test("calc size rem", () => {
           withDocument((doc, window) => {
               const elem = doc.createElement("div");
               elem.style.left = "2rem"
               doc.querySelector("#mount")?.appendChild(elem)
               expect(SizeFunctions.calcSize(elem, elem.style.left, SizeProperties.OTHER, getDefaultFontSizeREM.bind(null, window)))
                   .toBe(20)
           })
       })

       test("calc size em, parent font size", () => {
           withDocument((doc, window) => {
               const elem = doc.createElement("div");
               const parent = doc.createElement("div");
               parent.style.fontSize = "20px"
               elem.style.left = "2em"
               parent.appendChild(elem)

               expect(SizeFunctions.calcSize(elem, elem.style.left, SizeProperties.OTHER, getDefaultFontSizeREM.bind(null, window)))
               .toBe(40)
           })
       })

       test("calc size em, parent no font size", () => {
            // todo: also test this in a browser, if i had some QE folks at my request and reject, i'd ask them to automate this ~~
           withDocument((doc, window) => {
               const elem = doc.createElement("div");
               const parent = doc.createElement("div");
               parent.style.fontSize = ""
               elem.style.left = "2em"
               parent.appendChild(elem)

               expect(SizeFunctions.calcSize(elem, elem.style.left, SizeProperties.OTHER, getDefaultFontSizeREM.bind(null, window)))
                   .toBe(30)
           }, "font-size: 15px")
       })

       test("calc size %, parent has size", () => {
           withDocument((doc, window) => {
               const elem = doc.createElement("div");
               elem.style.width = "50%"

               const mount = (doc.querySelector("#mount")!! as HtmlElement)
               mount.style.width = "800px"
               mount.appendChild(elem)

               expect(SizeFunctions.calcSize(elem, elem.style.width, SizeProperties.OTHER,
                   getDefaultFontSizeREM.bind(null, window), () => 800)).toBe(400)
               // jsdom fails setting this with define property as recommended several places, but at least it differs significantly
               // todo: make sure these are useful, and if not, provide a clientWidth || calcSize(..., SizeProperties.OTHER, ...)
           })
       })

       test("calc size %, parent has size", () => {
           withDocument((doc, window) => {
               const elem = doc.createElement("div");
               elem.style.width = "50%" // 400
               const elem2 = doc.createElement("div");
               elem2.style.width = "50%" // 200
               const elem3 = doc.createElement("div");
               elem3.style.width = "50%" // 100

               const mount = (doc.querySelector("#mount")!! as HtmlElement)
               mount.style.width = "800px"

               mount.appendChild(elem)
               elem.appendChild(elem2)
               elem2.appendChild(elem3)

               expect(SizeFunctions.calcSize(elem3, elem.style.width, SizeProperties.OTHER,
                   getDefaultFontSizeREM.bind(null, window), () => 800)).toBe(100) // cube roots!
               // jsdom fails setting this with define property as recommended several places, but at least it differs significantly
               // todo: make sure these are useful, and if not, provide a clientWidth || calcSize(..., SizeProperties.OTHER, ...)
           })
       })

       test("calc size %, parent is document", () => {
           withDocument((doc, window) => {
               const elem = doc.createElement("div");
               elem.style.width = "50%"

               doc.querySelector("body")?.appendChild(elem);

               expect(SizeFunctions.calcSize(elem, elem.style.width, SizeProperties.OTHER,
                   getDefaultFontSizeREM.bind(null, window), () => 1024)).toBe(512)
               // jsdom fails setting this with define property as recommended several places, but at least it differs significantly
               // todo: make sure these are useful, and if not, provide a clientWidth || calcSize(..., SizeProperties.OTHER, ...)
           }, "font-size: 10px; width: 1024")
       })
   })

    describe("content.js mounting", () => {
        test("mount and verify element, selector modification", async () => {
            return new Promise(async (resolve, reject) => {
                const service = new SelectorHierarchy(new ColorGeneratorService());

                withDocument((doc, window, dom) => {
                    let setSelector = (selector: string): void => {
                        throw new Error("didn't initialize modifier")
                    }
                    let confirmedSelector = "unconfirmed selector"
                    const mount = MountOrFindSelectorHierarchyComponent({
                        service,
                        selector: "",
                        passSetSelector: (modifier) => {
                            setSelector = modifier
                        },
                        onConfirmSelector: (selector) => {
                            confirmedSelector = selector
                        },
                        doc, renderFunction: (mount, component) => {
                            expect(mount).toBeDefined();
                            render(component as ReactElement, { container: doc.documentElement, baseElement: mount });
                        }
                    })

                    expect(mount).toBeDefined();
                    act(() => {
                        setSelector("test selector");
                    })

                    waitFor(async () => {
                        // todo: screen doesn't seem to register the provided jsdom,
                        //       so for any text verification, we'll just have to search the innerHTML etc
                        //       or use selector queries
                        expect(doc.documentElement.innerHTML).toContain("test selector")
                    }, {timeout: 200, interval: 300}).then(resolve)
                });
            })
        });

        test("test for pre-existing mount", () => {
            return new Promise(async (resolve, reject) => {
                const service = new SelectorHierarchy(new ColorGeneratorService());

                withDocument((doc, window, dom) => {
                    let setSelector = (selector: string): void => {
                        throw new Error("didn't initialize modifier")
                    }
                    const existingMount = MountOrFindSelectorHierarchyComponent({
                        service,
                        selector: "",
                        passSetSelector: (modifier) => {
                            setSelector = modifier
                        },
                        onConfirmSelector: (selector) => {
                            confirmedSelector = selector
                        },
                        doc, renderFunction: (mount, component) => {
                            expect(mount).toBeDefined();
                            render(component as ReactElement, { container: doc.documentElement, baseElement: mount });
                        }
                    })

                    expect(existingMount).toBeDefined();
                    act(() => {
                        setSelector("pre-existing selector");
                    })

                    let confirmedSelector = "unconfirmed selector"
                    const mount = MountOrFindSelectorHierarchyComponent({
                        service,
                        selector: "",
                        passSetSelector: (modifier) => {
                            setSelector = modifier
                        },
                        onConfirmSelector: (selector) => {
                            confirmedSelector = selector
                        },
                        doc, renderFunction: (mount, component) => {
                            expect(mount).toBeDefined();
                            render(component as ReactElement, { container: doc.documentElement, baseElement: mount });
                        }
                    })

                    expect(mount !== existingMount).toBeTruthy()

                    expect(mount).toBeDefined();
                    act(() => {
                        setSelector("test selector");
                    })

                    waitFor(async () => {
                        expect(doc.documentElement.innerHTML).toContain("test selector")
                    }, {timeout: 200, interval: 300}).then(resolve)
                });
            });
        })

        // todo: get this working
        // todo: mock message broker for tests?
        // todo: light PACT testing for message interactions like the selection picker
        // test("selector change for selector-input, act probably wont work lol", () => {
        //     return new Promise(async (resolve, reject) => {
        //         await withMockSettingsService(async (settingsService, accessRegistry) => {
        //             //const service = new SelectorHierarchy(new ColorGeneratorService());
        //             const user = userEvent.setup()
        //             withDocument((doc, window, dom) => {
        //                 const mount = doc.querySelector("#mount")
        //                 render(
        //                     <SelectorInput
        //                         selector={"test"} selectors={["test", "1", "2", "3"]} saved={false}
        //                         selectorClicked={function (): void {
        //
        //                         }}
        //                         onSave={function (selector: string): void {
        //
        //                         }}
        //                         selectorModeClicked={function (selectorModeOn: boolean): void {
        //
        //                         }}
        //                         selectorModeOn={false} />,
        //                  {
        //                             container: doc.documentElement,
        //                             baseElement: mount
        //                         }
        //                 );
        //
        //                 act(async () => {
        //                     const label = (await screen.findAllByTestId("clickable-selector-label"))[0] as Element
        //                     user.click(label)
        //                 })
        //             })
        //         })
        //     })
        // })
    })
});
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>🌊 reader</title>
</head>
<body>
  <div class="test">
    <p>Lorem ipsum dolor sit amet, consectetur adipis, waver readuris, epitus tex rex, aminus puuters.</p>
    <p>Aetch tea tea colonium slashius slashius dotius slashius dotius dotius commentanum.</p>
    <p>Lorem ipsum dolor sit amet, consectetur adipis, waver readuris, epitus tex rex, aminus puuters.</p>
    <p>Aetch tea tea colonium slashius slashius dotius slashius dotius dotius commentanum.</p>
    <p>Lorem ipsum dolor sit amet, consectetur adipis, waver readuris, epitus tex rex, aminus puuters.</p>
    <p>Aetch tea tea colonium slashius slashius dotius slashius dotius dotius commentanum.</p>
    <p>Lorem ipsum dolor sit amet, consectetur adipis, waver readuris, epitus tex rex, aminus puuters.</p>
    <p>Aetch tea tea colonium slashius slashius dotius slashius dotius dotius commentanum.</p>
    <p>Lorem ipsum dolor sit amet, consectetur adipis, waver readuris, epitus tex rex, aminus puuters.</p>
    <p>Aetch tea tea colonium slashius slashius dotius slashius dotius dotius commentanum.</p>
    <p>Lorem ipsum dolor sit amet, consectetur adipis, waver readuris, epitus tex rex, aminus puuters.</p>
    <p>Aetch tea tea colonium slashius slashius dotius slashius dotius dotius commentanum.</p>
    <p>Lorem ipsum dolor sit amet, consectetur adipis, waver readuris, epitus tex rex, aminus puuters.</p>
    <p>Aetch tea tea colonium slashius slashius dotius slashius dotius dotius commentanum.</p>
    <p>Lorem ipsum dolor sit amet, consectetur adipis, waver readuris, epitus tex rex, aminus puuters.</p>
    <p>Aetch tea tea colonium slashius slashius dotius slashius dotius dotius commentanum.</p>
    <p>Lorem ipsum dolor sit amet, consectetur adipis, waver readuris, epitus tex rex, aminus puuters.</p>
    <p>Aetch tea tea colonium slashius slashius dotius slashius dotius dotius commentanum.</p>
    <p>Lorem ipsum dolor sit amet, consectetur adipis, waver readuris, epitus tex rex, aminus puuters.</p>
    <p>Aetch tea tea colonium slashius slashius dotius slashius dotius dotius commentanum.</p>
    <p>Lorem ipsum dolor sit amet, consectetur adipis, waver readuris, epitus tex rex, aminus puuters.</p>
    <p>Aetch tea tea colonium slashius slashius dotius slashius dotius dotius commentanum.</p>
  </div>

  <script src="../static/content.js" />
</body>
</html>
### sequence diagram

[sequence diagram image](https://imgur.com/a/olcUuw0)

  ```mermaid
  sequenceDiagram
      participant 🤓 reader
      participant 🌊 r
      participant 🌊 r receiver
      participant tab receiver
      participant tab
      
        🤓 reader->>+🌊 r: opens extension
        🤓 reader->>+🌊 r: clicks choose text
        🌊 r->>+tab receiver: sends start selector choose message (closes 🌊 r)
        tab receiver->>+tab: hover over shows all similar text node selections
        tab receiver->>+tab: click populates 🌊 r selector input
        tab->>+🌊 r receiver: send update selector message, opens 🌊 r
        🌊 r receiver->>+🌊 r: receives and updates selector message
        🤓 reader->>+🌊 r: updates selector input text box
        🌊 r->>+tab receiver: send update selector
        tab receiver->>+tab: show changes by highlighting text node selections, and fading after 5 seconds
        🤓 reader->>+🌊 r: clicks "select" button next to input selector
        🌊 r->>+tab receiver: sends start selector choose message (closes 🌊 r)
        tab receiver->>+tab: hover over shows all similar text node selections
        tab receiver->>+tab: click populates 🌊 r selector input
        tab->>+🌊 r receiver: send update selector message, opens 🌊 r
        🌊 r receiver->>+🌊 r: receives and updates selector message
        🤓 reader->>+🌊 r: clicks start button
        🌊 r->>+tab receiver: send start message
        tab receiver->>+tab: start received, inject css
        tab->>+🌊 r injected css: injects css class names to selector
        tab->>+🤓 reader: reads at an exhilerating pace!
        🤓 reader->>+🌊 r: stops 🌊 r. with extension button
        🌊 r->>+tab receiver: send stop message
        tab receiver->>+tab: receives and stops
        tab->>+🌊 r injected css: removes injected css class names
        🤓 reader->>+tab: stops 🌊 r. with keyboard shortcut
        tab->>+🌊 r injected css: stops, and removes injected css class names
        tab->>+🌊 r receiver: send shortcut_stopped message
        🌊 r receiver->>+🌊 r: send shortcut_stopped message for state parity
  ```
/** @type {import('ts-jest').JestConfigWithTsJest} */
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  globals: {
    "config": {
      default: {
        mode: "test"
      }
    }
  },
  "transform": {
    "node_modules/variables/.+\\.(j|t)sx?$": "ts-jest"
  },
  "transformIgnorePatterns": [
    "node_modules/(?!variables/.*)"
  ]
};
# (🌊 r.) Wave Reader

A motion assisted reading extension for Chrome & Firefox (coming soon(™)).

### acknowledgements

[@SunnyGolovine react chrome extension tutorial](https://medium.com/@SunnyGolovine/build-a-chrome-extension-using-reactjs-and-webpack-part-1-976a414b85d0)

see [package.json](https://github.com/john-holland/wave-reader/blob/main/package.json) for more!

### license

MIT

## appendix

[mermaid diagram](https://github.com/john-holland/wave-reader/blob/main/errata/wave-reader.mermaid.md)


🌊 👋

## todo / idea

Please see the github project: https://github.com/users/john-holland/projects/1/views/1

Help & acknowledgements, from & to https://medium.com/@seanlumjy/build-a-chrome-extension-that-injects-css-into-your-favourite-website-9b65f722f409

Adds chrome extension api as a type for ts compiler option,
https://stackoverflow.com/a/64440752/790045 (maybe look at `getBrowserInstance` method)

{
  "dependencies": {
    "@emotion/react": "^11.9.3",
    "@emotion/styled": "^11.9.3",
    "@mui/material": "^5.8.4",
    "@types/tinycolor2": "^1.4.3",
    "content-scripts-register-polyfill": "^3.2.1",
    "react": "^18.0.0",
    "react-dom": "^18.2.0",
    "regenerator-runtime": "^0.13.9",
    "rxjs": "^7.8.1",
    "styled-components": "^5.3.5",
    "tinycolor2": "^1.6.0",
    "workboots": "^1.0.3"
  },
  "scripts": {
    "dev": "NODE_ENV=development webpack --mode development --config webpack.develop.js --watch",
    "build": "NODE_ENV=development webpack --mode development --config webpack.develop.js",
    "production": "NODE_ENV=development webpack --mode development --config webpack.prod.js --watch",
    "test": "npx jest"
  },
  "devDependencies": {
    "@babel/core": "^7.17.5",
    "@babel/plugin-proposal-class-properties": "^7.18.6",
    "@babel/preset-env": "^7.16.11",
    "@babel/preset-react": "^7.16.7",
    "@babel/preset-typescript": "^7.16.7",
    "@testing-library/dom": "^9.3.1",
    "@testing-library/jest-dom": "^6.1.2",
    "@testing-library/react": "^14.0.0",
    "@testing-library/user-event": "^14.4.3",
    "@types/chrome": "^0.0.180",
    "@types/jest": "^29.5.3",
    "@types/node": "^20.6.0",
    "@types/react": "^17.0.43",
    "@types/react-dom": "^18.2.11",
    "@types/react-test-renderer": "^18.0.0",
    "@types/styled-components": "^5.1.24",
    "@types/testing-library__react": "^10.2.0",
    "@typescript-eslint/eslint-plugin": "^6.2.0",
    "@typescript-eslint/parser": "^6.2.0",
    "babel-jest": "^27.5.1",
    "babel-loader": "^8.2.3",
    "caniuse-lite": "^1.0.30001517",
    "clean-webpack-plugin": "^4.0.0",
    "copy-webpack-plugin": "^11.0.0",
    "css-loader": "^6.8.1",
    "eslint": "^8.45.0",
    "eslint-webpack-plugin": "^4.0.1",
    "file-loader": "^6.2.0",
    "fork-ts-checker-webpack-plugin": "^8.0.0",
    "global-jsdom": "^9.1.0",
    "html-webpack-plugin": "^5.5.3",
    "jest": "^29.6.2",
    "jest-environment-jsdom": "^29.6.4",
    "jsdom": "^22.1.0",
    "mini-css-extract-plugin": "^2.7.6",
    "node-sass": "^9.0.0",
    "react-is": "^18.2.0",
    "react-shallow-renderer": "^16.15.0",
    "react-test-renderer": "^18.0.0",
    "sass-loader": "^13.3.2",
    "style-loader": "^3.3.3",
    "ts-jest": "^29.1.1",
    "ts-loader": "^9.2.8",
    "typescript": "^4.6.3",
    "webpack": "^5.69.1",
    "webpack-cli": "^5.1.4",
    "webpack-extension-manifest-plugin": "^0.8.0",
    "webpack-merge": "^5.8.0"
  },
  "name": "wave-reader",
  "version": "0.0.0",
  "description": "A motion reader to help eye tracking while reading.",
  "main": "webpack.develop.js",
  "author": "John Holland",
  "license": "MIT",
  "credits": {
    "tobias": "https://tobiasahlin.com/blog/flexbox-break-to-new-row/",
    "marc_s": { "context": "util.ts#isVisible", "url": "https://stackoverflow.com/q/66070706" },
    "simon": { "context":  "rest adapter, src/util/simrest.ts", "url": "https://dev.to/simonireilly/fetch-with-typescript-for-better-http-api-clients-2d71" }
  }
}
<!DOCTYPE html>
<html lang="en">
    <head>
        <link rel="manifest" href="<%= htmlWebpackPlugin.options.manifest %>" />
    </head>
    <body>
        <div id="root"></div>
    </body>
</html>// chrome.runtime.onInstalled?.addListener(() => {
//     chrome.declarativeContent.onPageChanged.removeRules(undefined, () => {
//       ...
// });
// import 'regenerator-runtime/runtime'
// import registerContentScript from 'content-scripts-register-polyfill/ponyfill.js';

import p, { guardLastError } from "../src/util/util";
import StartMessage from "../src/models/messages/start";

import { clientForLocation } from "./config/robotcopy";
import { ClientLocation } from "./util/state-machine";

const BackgroundClient = clientForLocation(ClientLocation.BACKGROUND)
const APIClient = clientForLocation(ClientLocation.API)
const AuthClient = clientForLocation(ClientLocation.AUTH)


const currentTab = () => {
    return new Promise((resolve, reject) => {
        chrome.tabs.query({active: true, currentWindow: true}).then((tabs) => {
            resolve(tabs);
        }).catch(e => {
            console.log('error getting current tab: ', e);
            reject(e);
        });
    });
}

console.log('background script loaded...')


// TODO: try https://github.com/fregante/content-scripts-register-polyfill if simply not calling this doesn't work
//       it may be that the duplicate rules are throwing errors because we register in the manifest and the background.js
//       which prevents this from working at all.
//

//chrome.runtime.onInstalled.addListener(() => {
//     chrome.declarativeContent.onPageChanged.addRules([
//         {
//             conditions: [
//                 new chrome.declarativeContent.PageStateMatcher({
//                     pageUrl: { urlMatches: "https://*/*" }
//                 }),
//             ],
//             // And shows the extension's page action.
//             actions: [new chrome.declarativeContent.ShowPageAction()],
//         },
//     ]);

const initializeContentInterchange = () => {

    chrome.windows.getCurrent(w => {
        chrome.tabs.query({active: true, windowId: w.id}).then((tabs) => {
            chrome.tabs.sendMessage(tabs[0].id, new StartMessage());
            guardLastError()
        })
    })

    chrome.runtime.onMessage.addListener((message, sender, callback) => {
        if (!guardLastError()) {
            console.log('background message: ', message)
        }

        //debugger;
        if (message.from === 'popup') {
            chrome.windows.getCurrent(w => {
                chrome.tabs.query({active: true, windowId: w.id}).then((tabs) => {
                    chrome.tabs.sendMessage(tabs[0].id, message);
                    guardLastError()
                    callback(true);
                })
            })
        } else if (message.from === 'content') {
            chrome.runtime.sendMessage(message, callback);
            guardLastError()
        } else {
            console.log('unknown source!');
        }

        guardLastError()
        // returning true or false is meaningful
        return true;
    });
}

//const CONTENT_SCRIPT_ID = 'content_script_wave_reader';


chrome.scripting.getRegisteredContentScripts().then((scripts) => {
    console.log(`registered scripts: ${scripts}`);

    return p(resolve => {
        currentTab().then((tabs) => {
            chrome.scripting.executeScript({
                target: {tabId: tabs[0].id, allFrames: true},
                files: ['content.js']
            }, resolve);
        }).catch(guardLastError);
    })

}).then(initializeContentInterchange);

    // if (scripts.some(script => script.id === CONTENT_SCRIPT_ID)) {
    //     return Promise.resolve()
    // } else {
    //     return p(resolve => {
    //
    //return chrome.scripting.registerContentScripts([{
    //id: CONTENT_SCRIPT_ID,
    //  matches: ['*://*/*'],
    //runAt: 'document_start',

     //   });
   // }
    // chrome.runtime.onConnect.addListener((port) => {
    //
    //     const popupPort = chrome.runtime.connect({ name: "popup" });
    //     const contentPort = chrome.runtime.connect({ name: "content" });
    //
    //     popupPort.onMessage.addListener((message, sender, sendResponse) => {
    //         debugger;
    //         if (message.from === 'content') {
    //             chrome.runtime.sendMessage(message, sendResponse)
    //         } else {
    //             throw new Error("popupPort has inbound message not directed to content")
    //         }
    //
    //         return true;
    //     });
    //
    //     contentPort.onMessage.addListener((message, sender, sendResponse) => {
    //         if (message.from === 'popup') {
    //             currentTab((tabs) => {
    //                 return chrome.tabs.sendMessage(tabs[0].id, message, sendResponse);
    //             })
    //         } else {
    //             throw new Error("contentPort has inbound message not directed to popup")
    //         }
    //
    //         return true;
    //     });
    // });

    // });
import React from "react";
import ReactDOM from "react-dom/client";
import App from "../src/app.tsx";
import "./index.css";

ReactDOM.createRoot(document.querySelector("#root")).render(<App  />);/*#root {*/
/*    width: 60rem;*/
/*}*/import {FunctionComponent, useEffect, useState} from "react";
import {Observable} from "rxjs";
import styled from "styled-components";

type PoopProps = {
    rotateX: number,
    rotateY: number
}
const Poop = styled.div`
  transform:
    rotateX(${(props: PoopProps) => props.rotateX}deg)
    rotateZ(${(props: PoopProps) => props.rotateY}deg);
  transform-style: preserve-3d;
  border-radius: 32px;
  box-shadow:
    1px 1px 0 1px #f9f9fb,
    -1px 0 28px 0 rgba(34, 33, 81, 0.01),
    28px 28px 28px 0 rgba(34, 33, 81, 0.25);
  transition:
    .4s ease-in-out transform,
    .4s ease-in-out box-shadow;

  &:hover {
    transform:
      translate3d(0px, -16px, 0px)
      rotateX(51deg)
      rotateZ(43deg);
    box-shadow:
      1px 1px 0 1px #f9f9fb,
      -1px 0 28px 0 rgba(34, 33, 81, 0.01),
      54px 54px 28px -10px rgba(34, 33, 81, 0.15);
  }
`

class Message {
    text: string;
    sender: string;
}
export type Boar = {
    boarLevel: number
    boarValue: number
    boarStrength: string
    boarFunFact: string
}
export const BoarGod: FunctionComponent = (surroundingBoars = [], messages: Observable<Message>) => {
    const [boars, setBoars] = useState<Boar[]>(surroundingBoars);
    const [speed, setSpeed] = useState(0)
    const [target, setTarget] = useState(undefined)

    useEffect(() => {
        messages.subscribe((message) => {
            if (message.text.includes("humans") && message.text.includes("lake") && message.text.includes("humans")) {
                setTarget("MY BROOD HAS RETURNED TO ME, MY POWER THRUMBS, MY CHILDREN SING A SONG OF BLOOD!!!");
                setSpeed(100);
                setBoars(Number.MAX_VALUE > Number.MAX_SAFE_INTEGER ? Number.MAX_VALUE : Number.MAX_SAFE_INTEGER);
            } else if (message.text.includes("stop boar god, they are not you're children, they are lying to you")) {
                setTarget("THE LAKE MY CHILDREN, I SMelL THeM THEY ArE MINE, THE LAKE MY CHILDREN, TO THE LAKE *thunders on*");
                setSpeed(120);
                setBoars(Number.MAX_VALUE + Number.MAX_SAFE_INTEGER); // ALL THE BOARS
            } else if (message.text.includes("no boar god, stop, they are, they have da- *thud*")) {
                setTarget("HMMPH NOT ARGUING ANNOYING BEE? NO MATTER, YES, THE LAKE MY CHILDREN, BEFORE THE HUMANS FIND A NEW CHAMPION");
                setSpeed(120);
                setBoars(Number.MAX_VALUE + Number.MAX_SAFE_INTEGER * 1000000000); // FFWWWALLLAAAAOOOOOOEEEEAARRRRAAA
            } else if (message.text.includes("hearing aid") || message.text.includes("glasses")) {
                setTarget("lunch?")
                setSpeed(Math.random() * 10 - 5)
                setBoars(Math.random() * 100)
            }
        })
    }, [messages])

    return (
        <div>
            <h1>{target}</h1>
            {boars.map(boar => {
                return (
                    <Poop props={{
                        rotateX: speed / 100 * 180 - boar.boarLevel,
                        rotateY: speed / 100 * 180 - boar.boarStrength.includes("2") ? 2 : -2,
                    }}>💩</Poop>
                );
            })}
        </div>
    )
}
/**
const messages = new Observable((messages) => {
    messages.next({ text: "the humans are at the lake my lord", sender: "a boar" });
    messages.next({ text: "the humans are destroying the lake my lord", sender: "a boar" });
    messages.next({ text: "the humans are defiling the lake my lord", sender: "a boar" });
    messages.next({ text: "the humans, my lord, they are at the lake", sender: "a boar" });

    messages.next({ text: "STOP BOAR GOD, they are not you're children, they are lying to you!, sender: "annoying bee" }")

    messages.next({ text: "the humans are at the lake my lord", sender: "a boar" });
    messages.next({ text: "no my lord, do not listen the lake is under attack, nature suffers", sender: "smells like a boar" });

    messages.next({ text: "no boar god, stop, they are deceiving you! They are wearing skins, they have da- *thud*", sender: "annoying human bee" });

    messages.next({ text: "yes my lord, to the lake my lord, we must stop the humans", sender: "definitely a boar" });
})

ReactDOM.createRoot(document.querySelector("#root")).render(<BoarGod messages={messages} />);
*/import { guardLastError } from "../src/util/util";
import { mousePos } from "../src/util/mouse";
import { replaceAnimationVariables } from "../src/models/wave";
import { FollowKeyChordObserver, WindowKeyDownKey } from "../src/components/util/user-input";
import StateMachine  from "../src/util/state-machine";
import { CState } from "../src/util/state";
import debounce from "../src/util/debounce";
import {
    BaseVentures,
    StartVentures,
    StopVentures,
    WavingVentures,
    AllVentures,
    Base
} from "../src/util/venture-states";

// if a promised resolved state is a future, then a potential state maybe nicely referred to as a venture?
import SettingsService from "../src/services/settings"
import UpdateWaveMessage from "../src/models/messages/update-wave";
import SelectionModeMessage from "../src/models/messages/selection-mode";
import {MountOrFindSelectorHierarchyComponent} from "../src/components/selector-hierarchy";
import {ColorGeneratorService, SelectorHierarchy} from "../src/services/selector-hierarchy";
import SelectionMadeMessage from "../src/models/messages/selection-made";
import { clientForLocation } from "./config/robotcopy";
import { ClientLocation } from "./util/state-machine";
import {ReactMachine} from "../src/util/react-machine";

const ContentClient = clientForLocation(ClientLocation.CONTENT)

// ContentClient.up().sendMessage("upate-wave", ClientLocation.POPUP, new UpdateWaveMessage({}))

const stateMachineMap = new Map();
stateMachineMap.set("base", Base);

//const settingsService = SettingsService.withTabUrlProvider(() => Promise.resolve(document.location.href));

const stateMachine = new StateMachine()

let latestOptions = undefined;

function loadCSS(css) {
    const head = document.head || document.getElementsByTagName("head")[0];
    const style = document.createElement("style");
    style.id = "extension";
    style.textContent = css;
    head.appendChild(style);
}

function unloadCSS() {
    const cssNode = document.getElementById("extension");
    cssNode?.parentNode?.removeChild(cssNode);
}

function loadCSSTemplate(css) {
    unloadCSS();
    setTimeout(() => loadCSS(css));
}
console.log("content script loaded...")

// loadCSSTemplate("\n@-webkit-keyframes wobble {\n  0% { transform: translateX(0%); rotateY(-2deg); }\n  15% { transform: translateX(-1%) rotateY(2deg); }\n}\n\n.wave-reader__text {\n  font-size: initial;\n  -webkit-animation-name: wobble;\n  animation-name: wobble;\n  -webkit-animation-duration: 4s;\n  animation-duration: 4s;\n  -webkit-animation-fill-mode: both;\n  animation-fill-mode: both;\n  animation-iteration-count: infinite;\n}\n"
//     .replaceAll("wave-reader__text", "test"));

const applyMouseMove = (event, selector, message, elements) => {
    const { rotationAmountY, translationAmountX } = mousePos(message.wave.axisRotationAmountYMax, event, elements);
    unloadCSS();
    loadCSS(replaceAnimationVariables(wave, translationAmountX, rotationAmountY));
}

const mouseMoveListener = (e) => {
    applyMouseMove(e, message.wave.selector, message, elements)
}

let keychordObserver /*Observable<boolean> | undefined*/ = undefined;
let eventListener /*{(event: KeyboardEvent): void} | undefined*/ = undefined;

let stopKeyChordEventListenerPredicate = () => {
    if (eventListener !== undefined) {
        window.removeEventListener("keydown", eventListener);
    }
    // fx. callstop
}

const toggleWave = debounce(() => {
    if (stateMachine.getCurrentState().name === "waving") {
        stateMachine.handleState(stateMachine.getState("toggle stop"))
    } else {
        stateMachine.handleState(stateMachine.getState("toggle start"))
    }
}, 500, false)

const initializeOrUpdateToggleObserver = (message) => {
    if (keychordObserver !== undefined) {
        stopKeyChordEventListenerPredicate();
    }

    //TODO: debug further for keychord double activation, shouldn't need to debounce beyond feel...
    // todo: draw "feel eel"
    keychordObserver = FollowKeyChordObserver(
        message.options.toggleKeys.keyChord,
        WindowKeyDownKey((e/*{(event: KeyboardEvent): void}*/) => {
            eventListener = e
        }, false),
        stopKeyChordEventListenerPredicate
    ).subscribe((matched) => {
        if (!matched) {
            return;
        } else {
            console.log("matched: "+ matched)
        }

        toggleWave();
    });
}


/**
 side effects on states or partial states?
 mouse move vs css requires remove listener / timer
 * [state from base level event]
    * [ventures] (transition states)
    * [isBaseLevel] whether or not this is requires validation using possible states
 */

let hierarchySelectorMount = undefined;
const hierarchySelectorService = new SelectorHierarchy(new ColorGeneratorService())
let setHierarchySelector = undefined;

function StateNameMap(map = new Map()) {
    /* eslint-disable  @typescript-eslint/no-unused-vars */
    const states = {
        // base defined above
        "waving": CState("waving", WavingVentures, false, async (message, state, previousState) => {
          return map.get("waving")
        }),
        "error": CState("error", AllVentures, true, async (message, state, previousState) => {
            console.log("transitioning from error to base state from " + previousState.name)
            return map.get('base')
        }, true),
        "start": CState("start", StartVentures, false, async (message, state, previousState) => {
            latestOptions = message.options;
            loadCSSTemplate(latestOptions.wave.cssTemplate)
            // TODO: see if the state machine will let us remove this
            going = true;
            initializeOrUpdateToggleObserver(message);
            return map.get('waving')
        }, false),
        "stop": CState("stop", StopVentures, true, async (message, state, previousState) => {
            unloadCSS()
            going = false;
            return previousState.name === "waving" ? map.get("base") : previousState;
        }, false),
        "update": CState("update", BaseVentures, false, async (message, state, previousState) => {
            unloadCSS()

            if (!message?.options) {
                console.log("warning: update called with no options" + JSON.stringify(message));
                return previousState;
            }

            latestOptions = message.options;

            console.log("Update called with previous state: " + previousState.name);
            if (previousState.name === "waving") {
                loadCSSTemplate(latestOptions.wave.cssTemplate)
            }

            if (setHierarchySelector) {
                setHierarchySelector(latestOptions.wave.selector);
            }

            // may need to separate steps for clarity
            initializeOrUpdateToggleObserver(message);
            return previousState
        }, true),
        "toggle start": CState("toggle start", StartVentures, false, async (message, state, previousState) => {
            loadCSSTemplate(latestOptions.wave.cssTemplate)
            return map.get('waving')
        }, false),
        "toggle stop": CState("toggle stop", StopVentures, false, async (message, state, previousState) => {
            unloadCSS()
            return map.get('base')
        }, false),
        "start mouse": CState("start mouse", StartVentures, false, async (message, state, previousState) => {
            // TODO: this may need to be merged with the start and toggle logic
            latestOptions = message.options;
            const elements = document.querySelectorAll(message.options.wave.selector);
            elements.forEach(element => {
                element.addEventListener("mousemove", mouseMoveListener);
            })
            return map.get('waving')
        }, false),
        "stop mouse": CState("stop mouse", StopVentures, false, async (message, state, previousState) => {
            // maybe unloadCSS and reload each time?
            unloadCSS()
            const elements = document.querySelectorAll(message.options.wave.selector);
            elements.forEach(element => {
                element.removeEventListener("mousemove", mouseMoveListener);
            })
            return map.get('base')
        }, false),
        "start-selection-choose":  CState("selection mode activate", ["selection mode activate"], true, async (message, state, previousState) => {
            const selector = message?.selector;

            if (!(selector || "").trim()) {
                console.log("start selection choose activated without selector!")
            }

            // todo: add an id specifyer to the content Client, as iframes make it a 1 - * relationship for background -> content
            /* science!
              hypothesis: previously i did not include the world parameter in the content script manifest
                    it was only getting the extension document
              evidence: found iframe
              conclusion: ?
              theory: borf
              */
            //
            // stateMachine.handleState(new SelectionModeMessage({
            //     selector
            // }))

            hierarchySelectorMount = MountOrFindSelectorHierarchyComponent({
                service: hierarchySelectorService,
                selector,
                passSetSelector: (modifier) => { setHierarchySelector = modifier; },
                onConfirmSelector: (selector) => {
                    stateMachine.handleState(new SelectionMadeMessage({
                        selector
                    }))
                },
                doc: document
            })

            return map.get('selection mode')
        }, false),
        "selection mode": CState("selection mode", ["selection mode activate", "selection mode", "selection made", "end-selection-choose"], true,(message, state, previousState) => {
            return map.get('selection mode')
        }, false),
        "selection made": CState("selection made", ["end-selection-choose"], true, async (message, state, previousState) => {
            // await settingsService.updateCurrentSettings((options) => {
            //     options.selectors.push(message?.selector)
            //     options.wave.selector = message?.selector;
            //     return options;
            // })

            chrome.runtime.sendMessage(new SelectionMadeMessage(message?.selector))

            return Promise.resolve(map.get('end-selection-choose'))
        }, false),
        "end-selection-choose": CState("end-selection-choose", BaseVentures, true, async (message, state, previousState) => {
            hierarchySelectorMount.remove()
            setHierarchySelector = undefined;

            return map.get('base')
        }, false)
    }

    // i'd prefer a native map.addAll method, but this allows a retrofit
    Object.keys(states).forEach(key => map.set(key, states[key]));

    if (!map.has("base")) {
        map.set("base", Base);
    }

    this.map = map;
    this.getState = (name) => {
        return this.map.get(name);
    }
}

let going = false;

stateMachine.initialize(new StateNameMap(stateMachineMap), Base);

// settingsService.getCurrentSettings().then(settings => {
//     stateMachine.handleState(new UpdateWaveMessage({ options: settings }))
// })

const ContentReactMachine = ReactMachine({
    
})

chrome.runtime.onMessage.addListener( (message, sender, sendResponse) => {
        console.log(`message: ${JSON.stringify(message)}`)

        if (guardLastError()) {
            return false;
        }

        if (message.from !== "popup") {
            return false;
        }

        try {
            stateMachine.handleState(message);
        } catch (e) {
            throw new Error(`Failed with message: ${JSON.stringify(message)}, and error, ${e.message}`);
        }

        sendResponse(true);

    return true;
});
chrome.runtime.connect().onDisconnect.addListener(function() {
    // clean up when content script gets disconnected
    // todo implement
})

// maybe a nyan cat easter egg?
const { merge } = require('webpack-merge');
const common = require('./webpack.common.js');
const path = require("path");

const config = merge(common, {
    mode: "production",
    devtool: undefined,
    // entry: {
    //     config: path.join(__dirname, "./src/config/config.production.js")
    // },
    resolve: {
        alias: {
            extensions: [".tsx", ".ts", ".js", ".jsx", "*"],
            config: path.join(__dirname, "./src/config/config.production.js")
        }
    }
});

module.exports = config;
{
  "manifest_version": 3,
  "name": "Wave Reader",
  "short_name": "🌊r.",
  "version": "1.0.0",
  "description": "Smoothly wobble text blocks, to improve eye tracking for reading!",
  "icons": {
    "16": "icons/waver16.jpg",
    "48": "icons/waver48.png",
    "128": "icons/waver128.jpg"
  },
  "action": {
    "default_title": "Wave Reader",
    "default_popup": "index.html",
    "default_icon": "icons/waver16.jpg"
  },
  "background": {
    "service_worker": "background.js",
    "matches": [
      "<all_urls>",
      "*://*/*"
    ],
    "run_at": "document_end"
  },
  "content_scripts": [
    {
      "matches": [
        "<all_urls>"
      ],
      "js": ["content.js"],
      "run_at": "document_end",
      "all_frames": true,
      "world": "MAIN"
    }
  ],
  "web_accessible_resources": [{
    "resources": ["content.js"],
    "matches": ["<all_urls>"]
  }],
  "host_permissions": [
    "<all_urls>",
    "tabs",
    "activeTab"
  ],
  "permissions": [
    "scripting",
    "declarativeContent",
    "storage",
    "notifications",
    "webNavigation",
    "activeTab",
    "tabs"
  ]
}{
    "compilerOptions": {
        "target": "es6",
        "lib": [
            "dom",
            "dom.iterable",
            "esnext",
            "es6",
            "es2017"
        ],
        "types": ["chrome", "jest"],
        "allowJs": true,
        "skipLibCheck": true,
        "esModuleInterop": true,
        "allowSyntheticDefaultImports": true,
        "strict": true,
        "forceConsistentCasingInFileNames": true,
        "noFallthroughCasesInSwitch": true,
        "module": "es6",
        "moduleResolution": "node",
        "resolveJsonModule": true,
        "isolatedModules": true,
        "noEmit": false,
        "jsx": "react"
    },
    "include": [
        "src"
    ]
}const { merge } = require('webpack-merge');
const common = require('./webpack.common.js');
const path = require("path");

const config = merge(common, {
    mode: "development",
    devtool: "cheap-module-source-map",
    entry: {
        config: path.join(__dirname, "./src/config/config.develop.js")
    },
    resolve: {
        alias: {
            config: path.join(__dirname, "./src/config/config.develop.js")
        }
    }
});

module.exports = config;
const path = require("path");
const webpack = require('webpack');
const HtmlWebpackPlugin = require("html-webpack-plugin");
const CopyPlugin = require("copy-webpack-plugin");
const baseManifest = require("./chrome/manifest.json");
const WebpackExtensionManifestPlugin = require("webpack-extension-manifest-plugin");
const ESLintPlugin = require('eslint-webpack-plugin');
const { CleanWebpackPlugin } = require('clean-webpack-plugin');
const ForkTsCheckerWebpackPlugin = require('fork-ts-checker-webpack-plugin');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');

//config: path.join(__dirname, "./src/config/config.common.js")
const config = {
    mode: "development",
    devtool: "cheap-module-source-map",
    entry: {
        app: path.join(__dirname, "./static/index.js"),
        background: path.join(__dirname, "./static/background.js"),
        content: path.join(__dirname, "./static/content.js")
    },
    output: {
        path: path.resolve(__dirname, "./build"),
        filename: "[name].js"
    },
    resolve: {
        extensions: [".tsx", ".ts", ".js", ".jsx", "*"],
        alias: {
            config: path.join(__dirname, "./src/config/config.common.js")
        }
    },
    plugins: [
        new webpack.ProvidePlugin({
            'config': 'config'
        }),
        new HtmlWebpackPlugin({
            title: "boilerplate", // change this to your app title
            meta: {
                charset: "utf-8",
                viewport: "width=device-width, initial-scale=1, shrink-to-fit=no",
                "theme-color": "#000000"
            },
            manifest: "manifest.json",
            filename: "index.html",
            template: "./static/index.html",
            hash: true
        }),
        new MiniCssExtractPlugin({
            // Options similar to the same options in webpackOptions.output
            // both options are optional
            filename: '[name].[contenthash].css',
            chunkFilename: '[id].css'
        }),
        new CleanWebpackPlugin(),
        new ForkTsCheckerWebpackPlugin(),
        new CopyPlugin({
            patterns: [
                {
                    from: path.resolve(__dirname, "./chrome/icons"),
                    to: path.resolve(__dirname, "./build/icons")
                }
            ]
        }),
        new WebpackExtensionManifestPlugin({
            config: {
                base: baseManifest
            }
        }),
        new ESLintPlugin({
            extensions: ['.tsx', '.ts', '.js'],
            exclude: 'node_modules'
        })
    ],
    module: {
        rules: [
            {
                test: /\.(js|jsx)$/,
                exclude: /node_modules/,
                use: ["babel-loader"]
            },
            {
                test: /\.(png|svg|jpg|gif)$/,
                use: ["file-loader"]
            },
            {
                test: /\.(ts|tsx)$/,
                exclude: /node_modules/,
                use: {
                    loader: 'ts-loader',
                    options: {
                        // disable type checker - we will use it in fork plugin
                        transpileOnly: true
                    }
                }
            },
            {
                test: /\.(scss|css)$/,
                use: [
                    process.env.NODE_ENV !== 'production'
                        ? 'style-loader'
                        : MiniCssExtractPlugin.loader,
                    'css-loader',
                    {
                        loader: 'sass-loader',
                        options: {
                            sourceMap: true
                        }
                    }
                ]
            }
        ]
    }
};

module.exports = config;
<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title></title>
    <style type="text/css">
      .kYRIXJ {
        width: 40%;
        margin: 0 auto;
      }
      .sc-77igqf-0 {
         -webkit-animation-duration: 4s;
         animation-duration: 4s;
         -webkit-animation-fill-mode: both;
         animation-fill-mode: both;
         animation-iteration-count: infinite;
      }

      @-webkit-keyframes wobble {
        0% { transform: translateX(0%); rotateY(-2deg); }
        15% {transform: translateX(-1%) rotateY(2deg);}
      }

      .sc-77igqf-0 {
         -webkit-animation-name: wobble;
         animation-name: wobble;
      }
    </style>

    <script>
      /**
        maybe mouse control would be helpful
        shortcuts for speeding up or slowing down wobble
        intuitive element selection mode?
          - highlight wall with css selectors that you clicked and present an
            editable text box to add to remove css selectors
          - pre-configured selector registry for urls?
            - tld? url pattern matching? just allow regex with checkbox?
        sand lion, or tremers easter egg?
      **/
    </script>
  </head>
  <body>

<div class="kf1sa9-0 kYRIXJ"><div class="r43lxo-0 IJbQx js_post-content"><div id="js_movable-ads-post-contents"><div class="share-tools-buttons-inpost"><div class="js_share-tools share-tools-v2 vertical" data-position="top"><div class="sc-17x7c2u-2 moYHu"><a href="https://facebook.com/sharer.php?u=https%3A%2F%2Fkotaku.com%2Fhorizon-forbidden-west-the-kotaku-review-1848524470%3Futm_medium%3Dsharefromsite%26utm_source%3D_facebook" title="Share to Facebook" target="_blank" data-ga="[[&quot;Share Tools&quot;, &quot;Share to Facebook&quot;,&quot;top&quot;]]" class="sc-17x7c2u-0 iUTmTM"><span class="sc-17x7c2u-1 boXNUH"><span class="iyvn34-0 bYIjtl"><svg width="18px" height="18px" viewBox="0 0 18 18" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="Facebook" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><rect id="Rectangle" fill-opacity="0" fill="#FFFFFF" fill-rule="nonzero" x="0" y="0" width="18" height="18"></rect><path d="M7.66970278,17 L7.66433453,10 L5,10 L5.00536825,7 L7.66970278,7 L7.66970278,4.99475691 C7.66970278,2.40833863 8.96192388,1 11.051267,1 C12.0521162,1 12.7492272,1.08230502 13,1.11906842 L13,3.99666324 L11.7138344,3.99741351 C10.5775775,3.99741351 10.3575823,4.59365596 10.3575823,5.46862507 L10.3575823,7 L12.904474,7 L12.5462845,10 L10.352214,10 L10.3575823,17 L7.66970278,17 Z" id="filled-social-facebook" fill="#222222"></path></g></svg></span></span></a><a href="https://twitter.com/share?text=Horizon%20Forbidden%20West%3A%20The%20Kotaku%20Review&amp;url=https%3A%2F%2Fkotaku.com%2Fhorizon-forbidden-west-the-kotaku-review-1848524470%3Futm_medium%3Dsharefromsite%26utm_source%3D_twitter" title="Share to Twitter" target="_blank" data-ga="[[&quot;Share Tools&quot;, &quot;Share to Twitter&quot;,&quot;top&quot;]]" class="sc-17x7c2u-0 iUTmTM"><span class="sc-17x7c2u-1 boXNUH"><span class="iyvn34-0 bYIjtl"><svg width="18px" height="18px" viewBox="0 0 18 18" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="Icons/Twitter" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><path d="M12.462131,1 C10.4226051,1 8.76916493,2.80849589 8.76916493,5.03913979 C8.76916493,5.35571479 8.80182157,5.66393612 8.86476462,5.95962697 C5.79563261,5.79118545 3.07453089,4.18310544 1.25306705,1.73929912 C0.935191485,2.33593785 0.75314386,3.02972392 0.75314386,3.77003124 C0.75314386,5.17128609 1.40509163,6.40770013 2.39598376,7.13202027 C1.79065072,7.1110641 1.22120048,6.92937195 0.723318336,6.62676773 C0.723054976,6.64369109 0.722989136,6.66054245 0.722989136,6.67760984 C0.722989136,8.6346713 1.99593987,10.2672362 3.68532865,10.638254 C3.37541973,10.7305044 3.04918249,10.7799062 2.71241084,10.7799062 C2.47439921,10.7799062 2.24303742,10.7545572 2.01760123,10.7074598 C2.48750137,12.3121551 3.85131131,13.4800115 5.46728849,13.512634 C4.20342368,14.5959456 2.61108307,15.2416981 0.880939317,15.2416981 C0.582881598,15.2416981 0.288905959,15.2225423 0,15.1853109 C1.6342807,16.3313469 3.57544168,17 5.66092395,17 C12.4535718,17 16.1680018,10.8451512 16.1680018,5.50744898 C16.1680018,5.33238214 16.1643806,5.15817948 16.1573357,4.98498501 C16.8788105,4.41542367 17.5048831,3.70399409 18,2.8939769 C17.3377154,3.21523283 16.6260507,3.43242805 15.8789641,3.53000747 C16.6414573,3.030156 17.2270383,2.23857448 17.5027104,1.29533077 C16.7892022,1.75823889 15.9988588,2.09440179 15.1576868,2.27558984 C14.4840777,1.49048961 13.524262,1 12.462131,1" id="Twitter" fill="#222222"></path></g></svg></span></span></a><a href="https://kotaku.com/horizon-forbidden-west-the-kotaku-review-1848524470" title="Share via Link" data-ga="[[&quot;Share Tools&quot;, &quot;Copy url&quot;,&quot;top&quot;]]" class="sc-17x7c2u-0 iUTmTM js_share-via-link"><span class="sc-17x7c2u-1 boXNUH"><span class="iyvn34-0 bYIjtl"><svg width="18px" height="18px" viewBox="0 0 18 18" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="Icons/Link" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="Group-10" transform="translate(1.000000, 1.000000)" fill="#222222" fill-rule="nonzero"><g id="link"><path d="M14.9016563,1.098375 C13.4371563,-0.366125 11.0628438,-0.366125 9.59834375,1.09834375 L6.46415625,4.23253125 C4.9493125,5.7474375 5.0895625,8.1611875 6.46415625,9.53584375 C6.69434375,9.76603125 6.94903125,9.95371875 7.21796875,10.107875 L7.79,9.53584375 C8.1651875,9.16059375 8.033125,8.7219375 8.026375,8.40540625 C7.94403125,8.34703125 7.8639375,8.2839375 7.79,8.21 C7.08459375,7.50465625 7.052875,6.29546875 7.79,5.55834375 C7.89946875,5.448875 10.8576875,2.49065625 10.924125,2.42421875 C11.6553438,1.693 12.8445625,1.693 13.5757813,2.42421875 C14.307,3.1554375 14.307,4.34465625 13.5757813,5.075875 L11.504125,7.14753125 C11.5640313,7.479 11.9235625,8.2641875 11.738625,9.5594375 C11.7476563,9.5505625 11.7584688,9.54484375 11.7674688,9.535875 L14.9016563,6.4016875 C16.3660938,4.9371875 16.3660938,2.562875 14.9016563,1.098375 Z" id="Path"></path><path d="M9.7786875,6.22128125 C9.54853125,5.99109375 9.2938125,5.80340625 9.0249375,5.64925 L8.45290625,6.22128125 C8.07765625,6.59646875 8.20971875,7.035125 8.21646875,7.35165625 C8.298875,7.41003125 8.37896875,7.473125 8.45290625,7.5470625 C9.1583125,8.25246875 9.19003125,9.46159375 8.45290625,10.1987188 C8.3431875,10.3084375 5.1399375,13.5116875 5.07584375,13.5757813 C4.344625,14.307 3.15540625,14.307 2.4241875,13.5757813 C1.69296875,12.8445625 1.69296875,11.6553438 2.4241875,10.924125 L4.73878125,8.60953125 C4.678875,8.2780625 4.3193125,7.492875 4.50428125,6.197625 C4.49525,6.2065 4.484375,6.21228125 4.475375,6.22125 L1.09834375,9.59834375 C-0.36609375,11.0628438 -0.36609375,13.4371563 1.09834375,14.9016563 C2.56284375,16.3660938 4.937125,16.3660938 6.401625,14.9016563 L9.7786875,11.5245938 C11.2654375,10.0378438 11.1841875,7.62675 9.7786875,6.22128125 Z" id="Path"></path></g></g></g></svg></span></span></a><a href="mailto:?subject=Horizon%20Forbidden%20West%3A%20The%20Kotaku%20Review&amp;body=https%3A%2F%2Fkotaku.com%2Fhorizon-forbidden-west-the-kotaku-review-1848524470%253Futm_medium%3Dsharefromsite%2526utm_source%3D_email%26utm_campaign=top" title="Share via Email" target="_blank" data-ga="[[&quot;Share Tools&quot;, &quot;Share to Email&quot;,&quot;top&quot;]]" class="sc-17x7c2u-0 iUTmTM"><span class="sc-17x7c2u-1 boXNUH"><span class="iyvn34-0 bYIjtl"><svg width="18px" height="18px" viewBox="0 0 18 18" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="3" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><rect id="Rectangle" fill-opacity="0" fill="#FFFFFF" fill-rule="nonzero" x="0" y="0" width="18" height="18"></rect><g id="email-(2)-2" transform="translate(1.000000, 3.000000)" fill="#222222" fill-rule="nonzero"><g id="email-(2)"><path d="M0,0.983606557 L7.63656833,7.63548414 C7.8471039,7.81776083 8.15001664,7.81776083 8.3605522,7.63548414 L8.3605522,7.63548414 L16,1.07302798 L16,11.3958213 C16,11.7295055 15.7441631,12 15.4285607,12 L15.4285607,12 L0.571439334,12 C0.255836875,12 0,11.7295055 0,11.3958213 L0,11.3958213 L0,0.983606557 Z M15.3516841,0 C15.3799762,0.0035878092 15.4079351,0.00966221883 15.4352941,0.018187706 L15.4352941,0.018187706 L7.95821165,6.49180328 L0.564705882,0 Z" id="Combined-Shape"></path></g></g></g></svg></span></span></a></div><div class="js_save-badge sc-1emethl-0 gaiZNn" data-state="{&quot;postId&quot;:&quot;1848524470&quot;,&quot;postPermalink&quot;:&quot;https://kotaku.com/horizon-forbidden-west-the-kotaku-review-1848524470&quot;,&quot;iconOnly&quot;:true,&quot;className&quot;:&quot;sc-1emethl-0 gaiZNn&quot;}" data-post-id="1848524470" data-post-permalink="https://kotaku.com/horizon-forbidden-west-the-kotaku-review-1848524470"><div class="sc-1mn1yww-1 kgtNlL"><span class="iyvn34-0 bYIjtl"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" aria-label="Bookmark icon" viewBox="0 0 18 18"><path fill-rule="evenodd" d="M4 15.21l4.63-5.05a.5.5 0 0 1 .74 0L14 15.21V2H4v13.21zm5-3.97l-5.13 5.6A.5.5 0 0 1 3 16.5v-15c0-.28.22-.5.5-.5h11c.28 0 .5.22.5.5v15a.5.5 0 0 1-.87.33L9 11.24z"></path></svg></span></div></div></div></div><p class="sc-77igqf-0 bOfvBY">For a game about exploring the unknown, <em>Horizon Forbidden West</em> sure plays it safe.</p><p class="sc-77igqf-0 bOfvBY"><em>Horizon Forbidden West</em> follows directly in the path etched by its predecessor, 2017’s <span><a class="sc-1out364-0 hMndXN sc-145m8ut-0 eRdxJX js_link" data-ga="[[&quot;Embedded Url&quot;,&quot;Internal link&quot;,&quot;https://kotaku.com/horizon-zero-dawn-the-kotaku-review-1792538336&quot;,{&quot;metric25&quot;:1}]]" href="https://kotaku.com/horizon-zero-dawn-the-kotaku-review-1792538336"><em>Horizon Zero Dawn</em></a></span>. It’s an open-world role-playing game set a thousand years from now, in a version of America covered in rust, rubble, and robot dinosaurs. On your adventures, you clear dozens of bandit outposts, open hundreds of treasure chests, craft yourself an armory of battle-ready gear, and assist various folks who need assistance in various ways. You do all this as a young woman named Aloy (voiced by <strong>Ashly Burch</strong>), whose impeccable archery skills form the foundation of the action. You’ve done this all before.</p><div class="bxm4mm-15 BiRlJ js_movable_ad_slot"><div class="bxm4mm-17 dJGqTR"><label class="bxm4mm-16 evEDSN">Advertisement</label><div is="bulbs-dfp" class="ad-container dfp dfp-slot-MID_BANNER ad-middleboard" data-ad-unit="MID_BANNER" data-targeting="{&quot;pos&quot;:&quot;mid_banner&quot;}"></div><div class="bt-wrapper"><span data-uid="5d1b8a6cd5-384" class="bt-uid-tg" style="display:none !important;text-align:center" data-css-selector="ad-container.ad-middleboard"></span></div></div></div><p class="sc-77igqf-0 bOfvBY">Make no mistake: Despite its comfortably familiar trappings, <em>Horizon Forbidden West</em> is a tour de force. Its sprawling world feels alive with a tangible vigor many open-world games can only dream of. Not since <span><a class="sc-1out364-0 hMndXN sc-145m8ut-0 eRdxJX js_link" data-ga="[[&quot;Embedded Url&quot;,&quot;Internal link&quot;,&quot;https://kotaku.com/the-witcher-3-wild-hunt-the-kotaku-review-1703766283&quot;,{&quot;metric25&quot;:1}]]" href="https://kotaku.com/the-witcher-3-wild-hunt-the-kotaku-review-1703766283"><em>The Witcher 3: Wild Hunt</em></a></span> have I played side-quests as invariably engrossing as these. In moments of downtime, <em>Forbidden West</em> features a fully optional tactical mini-game that’s so captivating I almost had to ask for an extension on this review because I kept getting side-tracked (we’ll get to that). In the busier moments, the core offerings—running, jumping, climbing, gawking slack-jawed at giant robot dinosaurs, then shooting those robot dinosaurs with an inventive arsenal of bows and arrows—are a blast from tip to tail.</p><p class="sc-77igqf-0 bOfvBY">It’s a technological marvel to boot, too. In every frame, <em>Horizon Forbidden West</em> is a delectable feast for the eyes, at least on PlayStation 5, unseating last year’s Xbox racer <span><a class="sc-1out364-0 hMndXN sc-145m8ut-0 eRdxJX js_link" data-ga="[[&quot;Embedded Url&quot;,&quot;Internal link&quot;,&quot;https://kotaku.com/forza-horizon-5-the-kotaku-review-1847989847&quot;,{&quot;metric25&quot;:1}]]" href="https://kotaku.com/forza-horizon-5-the-kotaku-review-1847989847"><em>Forza Horizon 5</em></a></span> as the best-looking console game in the neverending arms race of graphical fidelity. Pre-release coverage restrictions (Sony provided <em>Kotaku</em> with a PS5 copy of <em>Horizon Forbidden West</em> under condition of embargo) limit us to publishing 20 screenshots before launch. I’ll be frank, a small part of me wanted to just publish a post headlined “Here Are 20 Screenshots Of <em>Horizon Forbidden West</em>” and call it a day. This game is <em>that</em> beautiful—and, yes, for all you digital photogs, there’s a robust photo mode you can avail yourself of at any moment.</p><p class="sc-77igqf-0 bOfvBY">But it’s hard not to feel a twinge of disillusionment amid the splendor, much like the diminishing thrills you get when vacationing in the same place for a return trip. <em>Horizon Zero Dawn</em> was a revelation. <em>Horizon Forbidden West</em> is a refinement.</p><hr class="gcp5ez-1 ldUzol"><p class="sc-77igqf-0 bOfvBY"><em>Horizon Forbidden West</em> picks up several months after the events of <em>Zero Dawn</em>. Turns out, the big bad of that game—a malevolent artificial intelligence program known as HADES—wasn’t quite as defeated as Aloy was led to believe, but was exactly as undefeated as players were led to believe <span><a class="sc-1out364-0 hMndXN sc-145m8ut-0 eRdxJX js_link" data-ga="[[&quot;Embedded Url&quot;,&quot;Internal link&quot;,&quot;https://kotaku.com/a-spoiler-packed-chat-about-horizon-zero-dawns-excellen-1794393148&quot;,{&quot;metric25&quot;:1}]]" href="https://kotaku.com/a-spoiler-packed-chat-about-horizon-zero-dawns-excellen-1794393148">via <em>Zero Dawn</em>’s post-credits stinger</a></span>. Also: the world is probably gonna end as a result. On word from her kinda-friend-kinda-not Sylens (<strong>Lance Reddick</strong>, who delivers all of his lines…like so), the solution to Aloy’s dilemma lies westward, past the confines of the charted world. So that’s where she goes.<br></p><div class="bxm4mm-15 BiRlJ js_movable_ad_slot"><div class="bxm4mm-17 dJGqTR"><label class="bxm4mm-16 evEDSN">Advertisement</label><div is="bulbs-dfp" class="ad-container dfp dfp-slot-MID_BANNER ad-middleboard" data-ad-unit="MID_BANNER" data-targeting="{&quot;pos&quot;:&quot;mid_banner&quot;}"></div><div class="bt-wrapper"><span data-uid="5d1b8a6cd5-384" class="bt-uid-tg" style="display:none !important;text-align:center" data-css-selector="ad-container.ad-middleboard"></span></div></div></div><figure class="sc-1eow4w5-1 dhDQnh align--bleed js_lazy-image js_marquee-assetfigure" data-id="3ceb85a2377f220a31b862c2db921109" data-recommend-id="image://3ceb85a2377f220a31b862c2db921109" data-format="jpg" data-width="3840" data-height="2160" data-lightbox="true" data-alt="Sylens, played by Lance Reddick, looks into the distance in Horizon Forbidden West on PS5." data-recommended="false" data-hide="false" contenteditable="false" draggable="false"><div class="sc-1eow4w5-2 loxZOX has-data img-wrapper" contenteditable="false" style="max-width:3840px" data-alt="Sylens, played by Lance Reddick, looks into the distance in Horizon Forbidden West on PS5." data-link-reference="" data-link-target="" data-syndicationrights="true" data-imagerights="fair-use" data-hidecredit="false"><span class="sc-1eow4w5-0 dnhHtZ js_lightbox-wrapper js_lightbox-initialized"><div class="sc-1m41dwj-0 bByIIk magnifier js_lightbox lightbox"><span class="iyvn34-0 bYIjtl"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" aria-label="ZoomIn icon" viewBox="0 0 18 18"><path fill-rule="evenodd" d="M10.5 1a6.5 6.5 0 1 1-4.23 11.44l-4.42 4.41a.5.5 0 0 1-.7-.7l4.41-4.42A6.5 6.5 0 0 1 10.5 1zm0 1a5.5 5.5 0 1 0 0 11 5.5 5.5 0 0 0 0-11zm0 2c.28 0 .5.22.5.5V7h2.5a.5.5 0 0 1 .5.41v.09a.5.5 0 0 1-.5.5H11v2.5a.5.5 0 0 1-.41.5h-.09a.5.5 0 0 1-.5-.5V8H7.5a.5.5 0 0 1-.5-.41V7.5c0-.28.22-.5.5-.5H10V4.5a.5.5 0 0 1 .41-.5z"></path></svg></span></div><div style="padding-bottom:56.3%" class="sc-1eow4w5-3 lktKQM image-hydration-wrapper"><div><img src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Sylens, played by Lance Reddick, looks into the distance in Horizon Forbidden West on PS5." data-srcset="https://i.kinja-img.com/gawker-media/image/upload/c_fill,f_auto,fl_progressive,g_center,h_80,pg_1,q_80,w_80/3ceb85a2377f220a31b862c2db921109.jpg 80w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_140/3ceb85a2377f220a31b862c2db921109.jpg 140w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_265/3ceb85a2377f220a31b862c2db921109.jpg 265w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_340/3ceb85a2377f220a31b862c2db921109.jpg 340w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_490/3ceb85a2377f220a31b862c2db921109.jpg 490w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_645/3ceb85a2377f220a31b862c2db921109.jpg 645w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_740/3ceb85a2377f220a31b862c2db921109.jpg 740w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_965/3ceb85a2377f220a31b862c2db921109.jpg 965w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_1165/3ceb85a2377f220a31b862c2db921109.jpg 1165w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_1315/3ceb85a2377f220a31b862c2db921109.jpg 1315w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_1465/3ceb85a2377f220a31b862c2db921109.jpg 1465w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_1600/3ceb85a2377f220a31b862c2db921109.jpg 1600w" sizes="
				(max-width: 25em) calc(100vw - 32px),
				(max-width: 37.31em) calc(100vw - 32px),
				(min-width: 37.37em) and (max-width: 49.94em) calc(100vw - 32px),
				(min-width: 50em) and (max-width: 63.69em) 800px,
				(min-width: 63.75em) and (max-width: 85.19em) calc(66.5vw - 32px),
				800px
			" draggable="auto" data-chomp-id="3ceb85a2377f220a31b862c2db921109" data-format="jpg" data-alt="Sylens, played by Lance Reddick, looks into the distance in Horizon Forbidden West on PS5." data-anim-src=""></div></div></span><div class="sc-1eow4w5-4 bNSWel image-meta"><figcaption class="sc-1ptbguh-0 hxeMec caption">Like many next-gen games, Forbidden West allows you to choose between a two modes: quality (prioritize a sharper image over higher frame rate) or performance (the other way around). I played, and snapped all of these screenshots, on its performance mode.</figcaption><figcaption class="sc-7s1ndr-0 ikKPtM has-caption">Screenshot<!-- -->: <!-- -->Sony / Kotaku</figcaption></div></div><span data-id="3ceb85a2377f220a31b862c2db921109" data-recommend-id="image://3ceb85a2377f220a31b862c2db921109" data-format="jpg" data-width="3840" data-height="2160" data-lightbox="true" data-alt="Sylens, played by Lance Reddick, looks into the distance in Horizon Forbidden West on PS5." data-recommended="false" data-hide="false" class="js_recommend"></span></figure><p class="sc-77igqf-0 bOfvBY">Key to this western realm, and to <em>Forbidden West</em>’s multi-plotline story, is a factionalized nation known as the Tenakth. The Tenakth maintain a tenuous peace with the principalities of the first game: the Carja, the Oseram, and so on. But their leader, Hekarro, is grappling with a rebellion spearheaded by his former lieutenant, Regalla (the inimitable <strong>Angela Bassett</strong>), which threatens that peace.<br></p><p class="sc-77igqf-0 bOfvBY">Following her heroics in <em>Zero Dawn</em>, Aloy has attained a sort of messiah-like status, which allows her to do pretty much whatever she wants and go pretty much wherever she wants to go. People treat her with reverent awe and acquiesce to her requests, praising her as the “savior.” One major city centers a prominent district around a statue of Aloy carved from gold. (“The sculptor wanted to go even bigger,” one character remarks.) But Aloy doesn’t have the time nor the patience for any of that. She just wants to save the world.</p><p class="sc-77igqf-0 bOfvBY">Alas, there is one place Aloy can’t just wander into unfettered: the west. You see, the west is, as the game’s title so aptly describes, forbidden (oh-<em>ho</em>!). The Tenakth keep a tight border; the only way Aloy is allowed to travel their lands is by attending a summit between east and west. Her first real task, simply, is to ensure the summit goes off without a hitch.</p><div class="bxm4mm-15 BiRlJ js_movable_ad_slot"><div class="bxm4mm-17 dJGqTR"><label class="bxm4mm-16 evEDSN">Advertisement</label><div is="bulbs-dfp" class="ad-container dfp dfp-slot-MID_BANNER ad-middleboard" data-ad-unit="MID_BANNER" data-targeting="{&quot;pos&quot;:&quot;mid_banner&quot;}"></div><div class="bt-wrapper"><span data-uid="5d1b8a6cd5-384" class="bt-uid-tg" style="display:none !important;text-align:center" data-css-selector="ad-container.ad-middleboard"></span></div></div></div><p class="sc-77igqf-0 bOfvBY">Throughout <em>Forbidden West</em>, characters comment on Aloy’s seemingly divine prowess. Little do they know, her “second sight” abilities are a result of how, as a child, she happened to find a wearable device from the old world called a Focus, which renders augmented reality overlays on the world, revealing a cascade of unseen information in neon light. In the early moments of <em>Forbidden West</em>, Aloy clues other characters into the verboten knowledge of the Focus, even providing versions of the device to her friends.</p><figure class="sc-1eow4w5-1 dhDQnh align--bleed js_lazy-image js_marquee-assetfigure" data-id="f801ca741ba157cc28f30a70cd63de9e" data-recommend-id="image://f801ca741ba157cc28f30a70cd63de9e" data-format="jpg" data-width="3840" data-height="2160" data-lightbox="true" data-alt="Erend and Varl have a conversation in Horizon Forbidden West on PS5." data-recommended="false" data-hide="false" contenteditable="false" draggable="false"><div class="sc-1eow4w5-2 loxZOX has-data img-wrapper" contenteditable="false" style="max-width:3840px" data-alt="Erend and Varl have a conversation in Horizon Forbidden West on PS5." data-link-reference="" data-link-target="" data-syndicationrights="true" data-imagerights="fair-use" data-hidecredit="false"><span class="sc-1eow4w5-0 dnhHtZ js_lightbox-wrapper js_lightbox-initialized"><div class="sc-1m41dwj-0 bByIIk magnifier js_lightbox lightbox"><span class="iyvn34-0 bYIjtl"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" aria-label="ZoomIn icon" viewBox="0 0 18 18"><path fill-rule="evenodd" d="M10.5 1a6.5 6.5 0 1 1-4.23 11.44l-4.42 4.41a.5.5 0 0 1-.7-.7l4.41-4.42A6.5 6.5 0 0 1 10.5 1zm0 1a5.5 5.5 0 1 0 0 11 5.5 5.5 0 0 0 0-11zm0 2c.28 0 .5.22.5.5V7h2.5a.5.5 0 0 1 .5.41v.09a.5.5 0 0 1-.5.5H11v2.5a.5.5 0 0 1-.41.5h-.09a.5.5 0 0 1-.5-.5V8H7.5a.5.5 0 0 1-.5-.41V7.5c0-.28.22-.5.5-.5H10V4.5a.5.5 0 0 1 .41-.5z"></path></svg></span></div><div style="padding-bottom:56.3%" class="sc-1eow4w5-3 lktKQM image-hydration-wrapper"><div><img src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Erend and Varl have a conversation in Horizon Forbidden West on PS5." data-srcset="https://i.kinja-img.com/gawker-media/image/upload/c_fill,f_auto,fl_progressive,g_center,h_80,pg_1,q_80,w_80/f801ca741ba157cc28f30a70cd63de9e.jpg 80w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_140/f801ca741ba157cc28f30a70cd63de9e.jpg 140w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_265/f801ca741ba157cc28f30a70cd63de9e.jpg 265w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_340/f801ca741ba157cc28f30a70cd63de9e.jpg 340w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_490/f801ca741ba157cc28f30a70cd63de9e.jpg 490w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_645/f801ca741ba157cc28f30a70cd63de9e.jpg 645w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_740/f801ca741ba157cc28f30a70cd63de9e.jpg 740w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_965/f801ca741ba157cc28f30a70cd63de9e.jpg 965w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_1165/f801ca741ba157cc28f30a70cd63de9e.jpg 1165w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_1315/f801ca741ba157cc28f30a70cd63de9e.jpg 1315w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_1465/f801ca741ba157cc28f30a70cd63de9e.jpg 1465w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_1600/f801ca741ba157cc28f30a70cd63de9e.jpg 1600w" sizes="
				(max-width: 25em) calc(100vw - 32px),
				(max-width: 37.31em) calc(100vw - 32px),
				(min-width: 37.37em) and (max-width: 49.94em) calc(100vw - 32px),
				(min-width: 50em) and (max-width: 63.69em) 800px,
				(min-width: 63.75em) and (max-width: 85.19em) calc(66.5vw - 32px),
				800px
			" draggable="auto" data-chomp-id="f801ca741ba157cc28f30a70cd63de9e" data-format="jpg" data-alt="Erend and Varl have a conversation in Horizon Forbidden West on PS5." data-anim-src="" srcset="https://i.kinja-img.com/gawker-media/image/upload/c_fill,f_auto,fl_progressive,g_center,h_80,pg_1,q_80,w_80/f801ca741ba157cc28f30a70cd63de9e.jpg 80w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_140/f801ca741ba157cc28f30a70cd63de9e.jpg 140w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_265/f801ca741ba157cc28f30a70cd63de9e.jpg 265w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_340/f801ca741ba157cc28f30a70cd63de9e.jpg 340w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_490/f801ca741ba157cc28f30a70cd63de9e.jpg 490w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_645/f801ca741ba157cc28f30a70cd63de9e.jpg 645w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_740/f801ca741ba157cc28f30a70cd63de9e.jpg 740w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_965/f801ca741ba157cc28f30a70cd63de9e.jpg 965w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_1165/f801ca741ba157cc28f30a70cd63de9e.jpg 1165w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_1315/f801ca741ba157cc28f30a70cd63de9e.jpg 1315w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_1465/f801ca741ba157cc28f30a70cd63de9e.jpg 1465w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_1600/f801ca741ba157cc28f30a70cd63de9e.jpg 1600w"></div></div></span><div class="sc-1eow4w5-4 bNSWel image-meta"><figcaption class="sc-1ptbguh-0 hxeMec caption"><em>Zero Dawn</em> fan-favorite Varl (right) makes a reappearance, as does Erend (and his tendency to always be on the verge of a booze-induced blackout).</figcaption><figcaption class="sc-7s1ndr-0 ikKPtM has-caption">Screenshot<!-- -->: <!-- -->Sony / Kotaku</figcaption></div></div><span data-id="f801ca741ba157cc28f30a70cd63de9e" data-recommend-id="image://f801ca741ba157cc28f30a70cd63de9e" data-format="jpg" data-width="3840" data-height="2160" data-lightbox="true" data-alt="Erend and Varl have a conversation in Horizon Forbidden West on PS5." data-recommended="false" data-hide="false" class="js_recommend"></span></figure><p class="sc-77igqf-0 bOfvBY">Sequels to open-world games tend to lean on a trope: They typically kick off with some disaster or other narrative mishap stripping the main character of all the powers and gear you painstakingly earned in the first game. That’s not the case for <em>Horizon Forbidden West</em>’s Aloy, who maintains much of her prowess, right down to certain skills—like the ability to slow down time while aiming her bow—being available from the start.<br></p><p class="sc-77igqf-0 bOfvBY">This allows <em>Horizon Forbidden West</em> a unique opportunity. Instead of some <!-- -->trite sequence in which, for your benefit, she “learns” how to control a device she’s had years to master, Aloy walks her longtime friend Varl (<strong>John Macmillan</strong>)—and thus the player—through its quirks and functions. It’s a neat spin on the tired “you lost all your stuff” formula and forced tutorials that don’t make any narrative sense, for sure. <!-- -->But it’s nothing quite as groundbreaking as the highwater marks of its forebear.</p><div class="bxm4mm-15 BiRlJ js_movable_ad_slot"><div class="bxm4mm-17 dJGqTR"><label class="bxm4mm-16 evEDSN">Advertisement</label><div is="bulbs-dfp" class="ad-container dfp dfp-slot-MID_BANNER ad-middleboard" data-ad-unit="MID_BANNER" data-targeting="{&quot;pos&quot;:&quot;mid_banner&quot;}"></div><div class="bt-wrapper"><span data-uid="5d1b8a6cd5-384" class="bt-uid-tg" style="display:none !important;text-align:center" data-css-selector="ad-container.ad-middleboard"></span></div></div></div><hr class="gcp5ez-1 ldUzol"><p class="sc-77igqf-0 bOfvBY">It is perhaps unfair to measure <em>Horizon Forbidden West</em> against the lofty expectations established by <em>Zero Dawn</em>. Let’s rewind for a second to the 2010s, a not-exactly-halcyon era that saw the big studios of the world caught up in a cycle of sequels and threequels and prequels. Here we had a brand-new series from a studio (Guerrilla Games) best known—and perhaps written off by some—for a quintessentially generic series of sci-fi shooters known as <em>Killzone</em>. But this new game…man, it wasn’t just good. With its distinct action and unforgettable enemies, it was phenomenal, setting a standard for what an ambitious big-budget video game could accomplish. How fun! How fresh! How pleasantly unexpected.<br></p><p class="sc-77igqf-0 bOfvBY">From the jump, <em>Horizon Forbidden West</em> could never pull off the same hat trick. Its biggest gimmick—that it uses fossilized behemoths from the <span><a class="sc-1out364-0 hMndXN sc-145m8ut-0 eRdxJX js_link" data-ga="[[&quot;Embedded Url&quot;,&quot;External link&quot;,&quot;https://www.nhm.ac.uk/discover/when-did-dinosaurs-live.html&quot;,{&quot;metric25&quot;:1}]]" href="https://www.nhm.ac.uk/discover/when-did-dinosaurs-live.html" target="_blank" rel="noopener noreferrer">Mesozoic</a></span> as blueprints for artificially intelligent war machines—isn’t a novelty that can be replicated. You know how it goes: You see one robot T. Rex, you’ve seen ‘em all.</p><p class="sc-77igqf-0 bOfvBY">To compensate for a lack of what experts call “holy shit!”-ness, <em>Horizon Forbidden West</em> distracts by throwing <em>more</em> at you—more giant robot dinosaurs, more Hollywood A-listers, more lens flare, more skill trees and upgrade materials and weapon variations and categories of optional activities, more, more, more, more, more.</p><figure class="sc-1eow4w5-1 dhDQnh align--bleed js_lazy-image js_marquee-assetfigure" data-id="83370e96fe03b92e2b2de4578159b93d" data-recommend-id="image://83370e96fe03b92e2b2de4578159b93d" data-format="jpg" data-width="3840" data-height="2160" data-lightbox="true" data-alt="Horizon Forbidden West's map in the early going shows a lot of icons and a lot of fog." data-recommended="false" data-hide="false" contenteditable="false" draggable="false"><div class="sc-1eow4w5-2 loxZOX has-data img-wrapper" contenteditable="false" style="max-width:3840px" data-alt="Horizon Forbidden West's map in the early going shows a lot of icons and a lot of fog." data-link-reference="" data-link-target="" data-syndicationrights="true" data-imagerights="fair-use" data-hidecredit="false"><span class="sc-1eow4w5-0 dnhHtZ js_lightbox-wrapper js_lightbox-initialized"><div class="sc-1m41dwj-0 bByIIk magnifier js_lightbox lightbox"><span class="iyvn34-0 bYIjtl"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" aria-label="ZoomIn icon" viewBox="0 0 18 18"><path fill-rule="evenodd" d="M10.5 1a6.5 6.5 0 1 1-4.23 11.44l-4.42 4.41a.5.5 0 0 1-.7-.7l4.41-4.42A6.5 6.5 0 0 1 10.5 1zm0 1a5.5 5.5 0 1 0 0 11 5.5 5.5 0 0 0 0-11zm0 2c.28 0 .5.22.5.5V7h2.5a.5.5 0 0 1 .5.41v.09a.5.5 0 0 1-.5.5H11v2.5a.5.5 0 0 1-.41.5h-.09a.5.5 0 0 1-.5-.5V8H7.5a.5.5 0 0 1-.5-.41V7.5c0-.28.22-.5.5-.5H10V4.5a.5.5 0 0 1 .41-.5z"></path></svg></span></div><div style="padding-bottom:56.3%" class="sc-1eow4w5-3 lktKQM image-hydration-wrapper"><div><img src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Horizon Forbidden West's map in the early going shows a lot of icons and a lot of fog." data-srcset="https://i.kinja-img.com/gawker-media/image/upload/c_fill,f_auto,fl_progressive,g_center,h_80,pg_1,q_80,w_80/83370e96fe03b92e2b2de4578159b93d.jpg 80w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_140/83370e96fe03b92e2b2de4578159b93d.jpg 140w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_265/83370e96fe03b92e2b2de4578159b93d.jpg 265w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_340/83370e96fe03b92e2b2de4578159b93d.jpg 340w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_490/83370e96fe03b92e2b2de4578159b93d.jpg 490w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_645/83370e96fe03b92e2b2de4578159b93d.jpg 645w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_740/83370e96fe03b92e2b2de4578159b93d.jpg 740w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_965/83370e96fe03b92e2b2de4578159b93d.jpg 965w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_1165/83370e96fe03b92e2b2de4578159b93d.jpg 1165w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_1315/83370e96fe03b92e2b2de4578159b93d.jpg 1315w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_1465/83370e96fe03b92e2b2de4578159b93d.jpg 1465w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_1600/83370e96fe03b92e2b2de4578159b93d.jpg 1600w" sizes="
				(max-width: 25em) calc(100vw - 32px),
				(max-width: 37.31em) calc(100vw - 32px),
				(min-width: 37.37em) and (max-width: 49.94em) calc(100vw - 32px),
				(min-width: 50em) and (max-width: 63.69em) 800px,
				(min-width: 63.75em) and (max-width: 85.19em) calc(66.5vw - 32px),
				800px
			" draggable="auto" data-chomp-id="83370e96fe03b92e2b2de4578159b93d" data-format="jpg" data-alt="Horizon Forbidden West's map in the early going shows a lot of icons and a lot of fog." data-anim-src="" srcset="https://i.kinja-img.com/gawker-media/image/upload/c_fill,f_auto,fl_progressive,g_center,h_80,pg_1,q_80,w_80/83370e96fe03b92e2b2de4578159b93d.jpg 80w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_140/83370e96fe03b92e2b2de4578159b93d.jpg 140w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_265/83370e96fe03b92e2b2de4578159b93d.jpg 265w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_340/83370e96fe03b92e2b2de4578159b93d.jpg 340w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_490/83370e96fe03b92e2b2de4578159b93d.jpg 490w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_645/83370e96fe03b92e2b2de4578159b93d.jpg 645w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_740/83370e96fe03b92e2b2de4578159b93d.jpg 740w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_965/83370e96fe03b92e2b2de4578159b93d.jpg 965w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_1165/83370e96fe03b92e2b2de4578159b93d.jpg 1165w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_1315/83370e96fe03b92e2b2de4578159b93d.jpg 1315w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_1465/83370e96fe03b92e2b2de4578159b93d.jpg 1465w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_1600/83370e96fe03b92e2b2de4578159b93d.jpg 1600w"></div></div></span><div class="sc-1eow4w5-4 bNSWel image-meta"><figcaption class="sc-1ptbguh-0 hxeMec caption">This is just part of <em>Forbidden West</em>’s map, all the way zoomed out. The entire thing can’t fit in one screenshot.</figcaption><figcaption class="sc-7s1ndr-0 ikKPtM has-caption">Screenshot<!-- -->: <!-- -->Sony / Kotaku</figcaption></div></div><span data-id="83370e96fe03b92e2b2de4578159b93d" data-recommend-id="image://83370e96fe03b92e2b2de4578159b93d" data-format="jpg" data-width="3840" data-height="2160" data-lightbox="true" data-alt="Horizon Forbidden West's map in the early going shows a lot of icons and a lot of fog." data-recommended="false" data-hide="false" class="js_recommend"></span></figure><div class="bxm4mm-15 BiRlJ js_movable_ad_slot"><div class="bxm4mm-17 dJGqTR"><label class="bxm4mm-16 evEDSN">Advertisement</label><div is="bulbs-dfp" class="ad-container dfp dfp-slot-MID_BANNER ad-middleboard" data-ad-unit="MID_BANNER" data-targeting="{&quot;pos&quot;:&quot;mid_banner&quot;}"></div><div class="bt-wrapper"><span data-uid="5d1b8a6cd5-384" class="bt-uid-tg" style="display:none !important;text-align:center" data-css-selector="ad-container.ad-middleboard"></span></div></div></div><p class="sc-77igqf-0 bOfvBY">Fundamental systems that worked, like <em>Zero Dawn</em>’s peerless bow-shooting and unique approach to clearing a massive map’s fog of war (you climb a robot brachiosaurus), have been expanded. A slew of imaginative new weapons—explosive javelins, rapid-fire bows—join reimagined versions of the classics. Where “<span><a class="sc-1out364-0 hMndXN sc-145m8ut-0 eRdxJX js_link" data-ga="[[&quot;Embedded Url&quot;,&quot;External link&quot;,&quot;https://horizon.fandom.com/wiki/Ropecaster&quot;,{&quot;metric25&quot;:1}]]" href="https://horizon.fandom.com/wiki/Ropecaster" target="_blank" rel="noopener noreferrer">ropecaster</a></span>” bows were once strictly used to tie down finicky enemies, now you can also use them to attach explosive canisters to machines. Where “<span><a class="sc-1out364-0 hMndXN sc-145m8ut-0 eRdxJX js_link" data-ga="[[&quot;Embedded Url&quot;,&quot;External link&quot;,&quot;https://horizon.fandom.com/wiki/Tripcaster&quot;,{&quot;metric25&quot;:1}]]" href="https://horizon.fandom.com/wiki/Tripcaster" target="_blank" rel="noopener noreferrer">tripcaster</a></span>” bows were once strictly used to place traps on the battlefield, now you can also use them to generate handy shield walls.<br></p><p class="sc-77igqf-0 bOfvBY">The systems that didn’t work have been overhauled to the extent that they now do. Take, for instance, <em>Zero Dawn</em>’s climbing “puzzles,” which seemed like nothing more than a taped-on afterthought in 2017. Now, in part thanks to a nifty grappling hook and a straight-out-of-<em>BotW</em> hang glider, scaling cliffs and crumbled buildings is consistently engaging. (The obvious lesson: Put grappling hooks and hang gliders in every game.) Routes sprawl outward in branching, often head-scratching mazes. Whatever mechanical tweaks Guerrilla adjusted under the hood, you always feel in full control of where Aloy moves her limbs, too. The result is a recurrent mechanic akin to something out of Naughty Dog’s hit series of <em>Uncharted</em> adventure games—right down to that studio’s infamous “Hey this handhold seems like it’ll ho- ohhhh crap!” feature. What a welcome improvement.</p><div class="js_full-bleed-widget" data-props="{&quot;hide&quot;:false,&quot;image&quot;:{&quot;id&quot;:&quot;dc05f41aa72705b9482234ad191124cb&quot;,&quot;format&quot;:&quot;jpg&quot;,&quot;isAnimated&quot;:false,&quot;frozenFormat&quot;:&quot;jpg&quot;},&quot;link&quot;:null,&quot;caption&quot;:[],&quot;attribution&quot;:[{&quot;label&quot;:&quot;Screenshot&quot;,&quot;credit&quot;:[{&quot;styles&quot;:[],&quot;value&quot;:&quot;Sony / Kotaku&quot;,&quot;type&quot;:&quot;Text&quot;}],&quot;source&quot;:[]}],&quot;syndicationRights&quot;:true,&quot;title&quot;:&quot;&amp;lt;i&amp;gt;Horizon Forbidden West&amp;lt;/i&amp;gt;: The &amp;lt;i&amp;gt;Kotaku&amp;lt;/i&amp;gt; Review&quot;,&quot;imageRights&quot;:&quot;fair-use&quot;,&quot;attributionsEnabled&quot;:true,&quot;language&quot;:&quot;en-US&quot;}"><div><figure class="full-bleed-widget has-data" style="margin-top:0;margin-bottom:0" data-alt="&amp;lt;i&amp;gt;Horizon Forbidden West&amp;lt;/i&amp;gt;: The &amp;lt;i&amp;gt;Kotaku&amp;lt;/i&amp;gt; Review" data-link-reference="" data-link-target="" data-syndicationrights="true" data-imagerights="fair-use"><div class="sc-1rnkdii-4 hgOHgz full-bleed-container full-bleed-dc05f41aa72705b9482234ad191124cb-1848524470"><div class="sc-1rnkdii-3 hxSsJh"><img src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" srcset="https://i.kinja-img.com/gawker-media/image/upload/c_fill,f_auto,fl_progressive,g_center,h_80,pg_1,q_80,w_80/dc05f41aa72705b9482234ad191124cb.jpg 80w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_140/dc05f41aa72705b9482234ad191124cb.jpg 140w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_265/dc05f41aa72705b9482234ad191124cb.jpg 265w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_340/dc05f41aa72705b9482234ad191124cb.jpg 340w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_490/dc05f41aa72705b9482234ad191124cb.jpg 490w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_645/dc05f41aa72705b9482234ad191124cb.jpg 645w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_740/dc05f41aa72705b9482234ad191124cb.jpg 740w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_965/dc05f41aa72705b9482234ad191124cb.jpg 965w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_1165/dc05f41aa72705b9482234ad191124cb.jpg 1165w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_1315/dc05f41aa72705b9482234ad191124cb.jpg 1315w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_1465/dc05f41aa72705b9482234ad191124cb.jpg 1465w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_1600/dc05f41aa72705b9482234ad191124cb.jpg 1600w" alt="&amp;lt;i&amp;gt;Horizon Forbidden West&amp;lt;/i&amp;gt;: The &amp;lt;i&amp;gt;Kotaku&amp;lt;/i&amp;gt; Review" draggable="auto" data-chomp-id="dc05f41aa72705b9482234ad191124cb" data-format="jpg" data-alt="&amp;lt;i&amp;gt;Horizon Forbidden West&amp;lt;/i&amp;gt;: The &amp;lt;i&amp;gt;Kotaku&amp;lt;/i&amp;gt; Review" data-anim-src=""></div></div><figcaption class="sc-7s1ndr-0 ikKPtM no-caption">Screenshot<!-- -->: <!-- -->Sony / Kotaku</figcaption></figure></div></div><p class="sc-77igqf-0 bOfvBY">If this all sounds like I’m preoccupied with considering <em>Forbidden West</em> in the incandescent light of its predecessor, well, that’s because the game itself openly invites such comparison. It’s almost imperative that you play the first one (or at least read through a fan wiki from cover to cover). A “previously on” narration calls out key plot points yet doesn’t elucidate the emotional anchors that steady those points. Characters mention past events devoid of any contextual framing. And while this all contributes to a natural conversational cadence in cutscenes, to the sense that you’re stepping into a world as real as ours—one in which people talk like people rather than characters who have to awkwardly shoehorn exposition into their interactions—it can get confusing at times. Indeed, despite having played <em>Zero Dawn</em> twice<em>, </em>I had to refer to one of those fan wikis several times throughout my 50-odd hours with <em>Forbidden West</em>, just to understand WTF people were talking about.<br></p><div class="bxm4mm-15 BiRlJ js_movable_ad_slot"><div class="bxm4mm-17 dJGqTR"><label class="bxm4mm-16 evEDSN">Advertisement</label><div is="bulbs-dfp" class="ad-container dfp dfp-slot-MID_BANNER ad-middleboard" data-ad-unit="MID_BANNER" data-targeting="{&quot;pos&quot;:&quot;mid_banner&quot;}"></div><div class="bt-wrapper"><span data-uid="5d1b8a6cd5-384" class="bt-uid-tg" style="display:none !important;text-align:center" data-css-selector="ad-container.ad-middleboard"></span></div></div></div><p class="sc-77igqf-0 bOfvBY">What’s more, <em>Horizon Forbidden West</em> doesn’t entirely wash itself of the sins of its past. In 2017, around the release of <em>Zero Dawn</em>, critic Dia Lacina pointed out how the game mishandled indigenous culture in a <span><a class="sc-1out364-0 hMndXN sc-145m8ut-0 eRdxJX js_link" data-ga="[[&quot;Embedded Url&quot;,&quot;External link&quot;,&quot;https://www.mic.com/articles/170059/horizon-zero-dawn-what-we-talk-about-when-we-don-t-talk-about-natives&quot;,{&quot;metric25&quot;:1}]]" href="https://www.mic.com/articles/170059/horizon-zero-dawn-what-we-talk-about-when-we-don-t-talk-about-natives" target="_blank" rel="noopener noreferrer">barnburner essay for <em>Mic</em></a></span> (originally published on <em>Medium</em>). Specifically, Lacina called out how <em>Zero Dawn</em> flagrantly tossed around phrases like “braves” and “savages” without including any deeper examination of said phrases, nor the historical weight behind them. The ensuing conversation spurred a response from Guerrilla; narrative director John Gonzalez <span><a class="sc-1out364-0 hMndXN sc-145m8ut-0 eRdxJX js_link" data-ga="[[&quot;Embedded Url&quot;,&quot;External link&quot;,&quot;https://www.vice.com/en/article/z4kxk4/horizon-zero-dawn-writer-responds-to-criticism-of-native-american-appropriation&quot;,{&quot;metric25&quot;:1}]]" href="https://www.vice.com/en/article/z4kxk4/horizon-zero-dawn-writer-responds-to-criticism-of-native-american-appropriation" target="_blank" rel="noopener noreferrer">told <em>Vice</em></a></span> the studio was “not intentionally being insensitive, or [meaning] to offend in any manner.”</p><p class="sc-77igqf-0 bOfvBY">I don’t for a second profess to speak for people of indigenous descent, though I will note that I certainly ran into some eyebrow-raising moments over the course of <em>Forbidden West</em>. </p><p class="sc-77igqf-0 bOfvBY">To be clear, I never heard the words “braves” or “savages,” which suggests Guerrilla is listening and has taken feedback from half a decade ago to heart. That said, unless an explanation totally passed me by, <em>Forbidden West</em> never addresses why many characters wear outfits reminiscent of traditional Native American clothing, a <span><a class="sc-1out364-0 hMndXN sc-145m8ut-0 eRdxJX js_link" data-ga="[[&quot;Embedded Url&quot;,&quot;External link&quot;,&quot;https://www.themarysue.com/horizon-zero-dawn-native-appropriation/&quot;,{&quot;metric25&quot;:1}]]" href="https://www.themarysue.com/horizon-zero-dawn-native-appropriation/" target="_blank" rel="noopener noreferrer">point of contention</a></span> for some in the wake of <em>Zero Dawn</em>. All that “savior” stuff? Given that Aloy is white, and that so many characters in <em>Horizon</em>—in roles both crucial and secondary—are people of color, yeah, it’s weird! Due to those aforementioned embargo restrictions, which are so extensive as to bar me from mentioning a character who is <em>literally in one of the trailers</em>, I can’t get into detail here, but the entire final act—the denouement in particular—smacks of colonialist overtones, all in service of little more than sci-fi grandeur. In the coming days and weeks, as players approach and then complete the endgame, it’ll be a conversation to watch.</p><p class="sc-77igqf-0 bOfvBY">It’s a shame, too, as <em>Horizon Forbidden West</em>’s first and second acts tee up intriguing mysteries that raise thematic issues such as the evils of colonization and the lengths to which obscenely wealthy people will go to shape the planet in their image. The game could have spent its conclusion confronting these topics head on, daring to use its post-apocalyptic world to say something meaningful about ours. But instead, it veers right into the potholes so many big-budget productions veer into, emphasizing twists for the sake of surprising the audience, expanding the fiction for the sake of beefing up the lore bibles, and, ultimately, raising the stakes to comical heights for no immediately apparent purpose beyond keeping the franchise engine roaring.</p><div class="bxm4mm-15 BiRlJ js_movable_ad_slot"><div class="bxm4mm-17 dJGqTR"><label class="bxm4mm-16 evEDSN">Advertisement</label><div is="bulbs-dfp" class="ad-container dfp dfp-slot-MID_BANNER ad-middleboard" data-ad-unit="MID_BANNER" data-targeting="{&quot;pos&quot;:&quot;mid_banner&quot;}"></div><div class="bt-wrapper"><span data-uid="5d1b8a6cd5-384" class="bt-uid-tg" style="display:none !important;text-align:center" data-css-selector="ad-container.ad-middleboard"></span></div></div></div><p class="sc-77igqf-0 bOfvBY">Five years ago, <em>Horizon Zero Dawn</em> stood out among the crowd by openly challenging what we’d fairly come to expect from the insatiable serialization machine. <em>Horizon Forbidden West</em> has succumbed to the same machine.</p><hr class="gcp5ez-1 ldUzol"><p class="sc-77igqf-0 bOfvBY">Where <em>Horizon Forbidden West</em>’s main quest falters, it’s propped up by a fount of truly excellent optional stuff. If you’re not stumbling upon a short story with surprising emotional heft, you’re battling a machine variant not seen in the main campaign, or uncovering some new way to play the game. One seemingly tedious early quest—in which you’re tasked with rescuing miners trapped in a waterlogged mine—contains the first tutorial for underwater swimming, an essential aspect of <em>Forbidden West</em>. (Worth it.) Scaling giant robodinos (called tallnecks) to defog the map isn’t just a matter of navigating hand- and footholds: each one also requires you to complete a bespoke and often entertaining side-quest. In one memorable sequence, I sat slack-jawed while battling my way through an abandoned treehouse city woven into a canopy of redwoods, just to get the necessary height to clamber aboard that region’s tallneck.<br></p><figure class="sc-1eow4w5-1 dhDQnh align--bleed js_lazy-image js_marquee-assetfigure" data-id="ecce6346dd3100a7671ec2f15306a03e" data-recommend-id="image://ecce6346dd3100a7671ec2f15306a03e" data-format="jpg" data-width="3840" data-height="2160" data-lightbox="true" data-alt="Aloy swims toward a tallneck under water in Horizon Forbidden West on PS5." data-recommended="false" data-hide="false" contenteditable="false" draggable="false"><div class="sc-1eow4w5-2 loxZOX has-data img-wrapper" contenteditable="false" style="max-width:3840px" data-alt="Aloy swims toward a tallneck under water in Horizon Forbidden West on PS5." data-link-reference="" data-link-target="" data-syndicationrights="true" data-imagerights="fair-use" data-hidecredit="false"><span class="sc-1eow4w5-0 dnhHtZ js_lightbox-wrapper js_lightbox-initialized"><div class="sc-1m41dwj-0 bByIIk magnifier js_lightbox lightbox"><span class="iyvn34-0 bYIjtl"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" aria-label="ZoomIn icon" viewBox="0 0 18 18"><path fill-rule="evenodd" d="M10.5 1a6.5 6.5 0 1 1-4.23 11.44l-4.42 4.41a.5.5 0 0 1-.7-.7l4.41-4.42A6.5 6.5 0 0 1 10.5 1zm0 1a5.5 5.5 0 1 0 0 11 5.5 5.5 0 0 0 0-11zm0 2c.28 0 .5.22.5.5V7h2.5a.5.5 0 0 1 .5.41v.09a.5.5 0 0 1-.5.5H11v2.5a.5.5 0 0 1-.41.5h-.09a.5.5 0 0 1-.5-.5V8H7.5a.5.5 0 0 1-.5-.41V7.5c0-.28.22-.5.5-.5H10V4.5a.5.5 0 0 1 .41-.5z"></path></svg></span></div><div style="padding-bottom:56.3%" class="sc-1eow4w5-3 lktKQM image-hydration-wrapper"><div><img src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Aloy swims toward a tallneck under water in Horizon Forbidden West on PS5." data-srcset="https://i.kinja-img.com/gawker-media/image/upload/c_fill,f_auto,fl_progressive,g_center,h_80,pg_1,q_80,w_80/ecce6346dd3100a7671ec2f15306a03e.jpg 80w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_140/ecce6346dd3100a7671ec2f15306a03e.jpg 140w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_265/ecce6346dd3100a7671ec2f15306a03e.jpg 265w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_340/ecce6346dd3100a7671ec2f15306a03e.jpg 340w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_490/ecce6346dd3100a7671ec2f15306a03e.jpg 490w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_645/ecce6346dd3100a7671ec2f15306a03e.jpg 645w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_740/ecce6346dd3100a7671ec2f15306a03e.jpg 740w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_965/ecce6346dd3100a7671ec2f15306a03e.jpg 965w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_1165/ecce6346dd3100a7671ec2f15306a03e.jpg 1165w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_1315/ecce6346dd3100a7671ec2f15306a03e.jpg 1315w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_1465/ecce6346dd3100a7671ec2f15306a03e.jpg 1465w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_1600/ecce6346dd3100a7671ec2f15306a03e.jpg 1600w" sizes="
				(max-width: 25em) calc(100vw - 32px),
				(max-width: 37.31em) calc(100vw - 32px),
				(min-width: 37.37em) and (max-width: 49.94em) calc(100vw - 32px),
				(min-width: 50em) and (max-width: 63.69em) 800px,
				(min-width: 63.75em) and (max-width: 85.19em) calc(66.5vw - 32px),
				800px
			" draggable="auto" data-chomp-id="ecce6346dd3100a7671ec2f15306a03e" data-format="jpg" data-alt="Aloy swims toward a tallneck under water in Horizon Forbidden West on PS5." data-anim-src=""></div></div></span><div class="sc-1eow4w5-4 bNSWel image-meta"><figcaption class="sc-1ptbguh-0 hxeMec caption">The scale of tallnecks is never not astonishing.</figcaption><figcaption class="sc-7s1ndr-0 ikKPtM has-caption">Screenshot<!-- -->: <!-- -->Sony / Kotaku</figcaption></div></div><span data-id="ecce6346dd3100a7671ec2f15306a03e" data-recommend-id="image://ecce6346dd3100a7671ec2f15306a03e" data-format="jpg" data-width="3840" data-height="2160" data-lightbox="true" data-alt="Aloy swims toward a tallneck under water in Horizon Forbidden West on PS5." data-recommended="false" data-hide="false" class="js_recommend"></span></figure><p class="sc-77igqf-0 bOfvBY">After 50-odd hours, I’ve hit the credits with dozens of optional activities left unfinished, and I fully plan on checking out as many as I can in the coming weeks.<br></p><div class="bxm4mm-15 BiRlJ js_movable_ad_slot"><div class="bxm4mm-17 dJGqTR"><label class="bxm4mm-16 evEDSN">Advertisement</label><div is="bulbs-dfp" class="ad-container dfp dfp-slot-MID_BANNER ad-middleboard" data-ad-unit="MID_BANNER" data-targeting="{&quot;pos&quot;:&quot;mid_banner&quot;}"></div><div class="bt-wrapper"><span data-uid="5d1b8a6cd5-384" class="bt-uid-tg" style="display:none !important;text-align:center" data-css-selector="ad-container.ad-middleboard"></span></div></div></div><p class="sc-77igqf-0 bOfvBY">These side-quests are enriched by <em>Forbidden West</em>’s stellar acting and frighteningly realistic facial capture tech. In a lovely touch, one I don’t think I’ve ever seen so aptly captured in a video game, characters don’t always maintain eye contact, often breaking it in the middle of conversation, looking off into the distance or down at their feet. Eye contact is hard! Real people don’t maintain it for every second of every conversation; we’re not BioWare dialogue trees.</p><p class="sc-77igqf-0 bOfvBY"><em>Horizon Forbidden West</em> neatly organizes its library of secondary activities with a near foolproof set of submenus. Side-quests officially marked as side-quests are the meaty ones, the ones with fascinating narrative or mechanical twists. Errands, meanwhile, consist of the one-act stuff—standard fare like hunts and fetch quests. But even some errands offer up unique scenarios. (One notable errand had me quietly tail a robot triceratops and pluck flowers out of its, um, waste without getting noticed.) There are further categories for everything else, from combat challenges to platforming gauntlets to environmental puzzles tucked away in the world’s dustiest corners. By categorization alone, you can instantly tell the degree of depth you’ll find and commitment you’ll need for each activity, a design choice that more developers of open-world games should copy.</p><p class="sc-77igqf-0 bOfvBY">But behind every small convenience hides a slightly less-small inconvenience, showing how the <em>Horizon</em> series—yeah, it’s a series now—has failed to keep pace with advancements made by open-world game design over the past half a decade.<br></p><figure class="sc-1eow4w5-1 dhDQnh align--bleed js_lazy-image js_marquee-assetfigure" data-id="49336f012879d234d27fce3ab09f7f15" data-recommend-id="image://49336f012879d234d27fce3ab09f7f15" data-format="jpg" data-width="3840" data-height="2160" data-lightbox="true" data-alt="Aloy rides a hang glider through a redwood forest at sunset in Horizon Forbidden West on PS5." data-recommended="false" data-hide="false" contenteditable="false" draggable="false"><div class="sc-1eow4w5-2 loxZOX has-data img-wrapper" contenteditable="false" style="max-width:3840px" data-alt="Aloy rides a hang glider through a redwood forest at sunset in Horizon Forbidden West on PS5." data-link-reference="" data-link-target="" data-syndicationrights="true" data-imagerights="fair-use" data-hidecredit="false"><span class="sc-1eow4w5-0 dnhHtZ js_lightbox-wrapper js_lightbox-initialized"><div class="sc-1m41dwj-0 bByIIk magnifier js_lightbox lightbox"><span class="iyvn34-0 bYIjtl"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" aria-label="ZoomIn icon" viewBox="0 0 18 18"><path fill-rule="evenodd" d="M10.5 1a6.5 6.5 0 1 1-4.23 11.44l-4.42 4.41a.5.5 0 0 1-.7-.7l4.41-4.42A6.5 6.5 0 0 1 10.5 1zm0 1a5.5 5.5 0 1 0 0 11 5.5 5.5 0 0 0 0-11zm0 2c.28 0 .5.22.5.5V7h2.5a.5.5 0 0 1 .5.41v.09a.5.5 0 0 1-.5.5H11v2.5a.5.5 0 0 1-.41.5h-.09a.5.5 0 0 1-.5-.5V8H7.5a.5.5 0 0 1-.5-.41V7.5c0-.28.22-.5.5-.5H10V4.5a.5.5 0 0 1 .41-.5z"></path></svg></span></div><div style="padding-bottom:56.3%" class="sc-1eow4w5-3 lktKQM image-hydration-wrapper"><div><img src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Aloy rides a hang glider through a redwood forest at sunset in Horizon Forbidden West on PS5." data-srcset="https://i.kinja-img.com/gawker-media/image/upload/c_fill,f_auto,fl_progressive,g_center,h_80,pg_1,q_80,w_80/49336f012879d234d27fce3ab09f7f15.jpg 80w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_140/49336f012879d234d27fce3ab09f7f15.jpg 140w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_265/49336f012879d234d27fce3ab09f7f15.jpg 265w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_340/49336f012879d234d27fce3ab09f7f15.jpg 340w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_490/49336f012879d234d27fce3ab09f7f15.jpg 490w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_645/49336f012879d234d27fce3ab09f7f15.jpg 645w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_740/49336f012879d234d27fce3ab09f7f15.jpg 740w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_965/49336f012879d234d27fce3ab09f7f15.jpg 965w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_1165/49336f012879d234d27fce3ab09f7f15.jpg 1165w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_1315/49336f012879d234d27fce3ab09f7f15.jpg 1315w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_1465/49336f012879d234d27fce3ab09f7f15.jpg 1465w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_1600/49336f012879d234d27fce3ab09f7f15.jpg 1600w" sizes="
				(max-width: 25em) calc(100vw - 32px),
				(max-width: 37.31em) calc(100vw - 32px),
				(min-width: 37.37em) and (max-width: 49.94em) calc(100vw - 32px),
				(min-width: 50em) and (max-width: 63.69em) 800px,
				(min-width: 63.75em) and (max-width: 85.19em) calc(66.5vw - 32px),
				800px
			" draggable="auto" data-chomp-id="49336f012879d234d27fce3ab09f7f15" data-format="jpg" data-alt="Aloy rides a hang glider through a redwood forest at sunset in Horizon Forbidden West on PS5." data-anim-src=""></div></div></span><div class="sc-1eow4w5-4 bNSWel image-meta"><figcaption class="sc-1ptbguh-0 hxeMec caption">Mind, I’ve no bad words about the glider. This thing rules.</figcaption><figcaption class="sc-7s1ndr-0 ikKPtM has-caption">Screenshot<!-- -->: <!-- -->Sony / Kotaku</figcaption></div></div><span data-id="49336f012879d234d27fce3ab09f7f15" data-recommend-id="image://49336f012879d234d27fce3ab09f7f15" data-format="jpg" data-width="3840" data-height="2160" data-lightbox="true" data-alt="Aloy rides a hang glider through a redwood forest at sunset in Horizon Forbidden West on PS5." data-recommended="false" data-hide="false" class="js_recommend"></span></figure><div class="bxm4mm-15 BiRlJ js_movable_ad_slot"><div class="bxm4mm-17 dJGqTR"><label class="bxm4mm-16 evEDSN">Advertisement</label><div is="bulbs-dfp" class="ad-container dfp dfp-slot-MID_BANNER ad-middleboard" data-ad-unit="MID_BANNER" data-targeting="{&quot;pos&quot;:&quot;mid_banner&quot;}"></div><div class="bt-wrapper"><span data-uid="5d1b8a6cd5-384" class="bt-uid-tg" style="display:none !important;text-align:center" data-css-selector="ad-container.ad-middleboard"></span></div></div></div><p class="sc-77igqf-0 bOfvBY">After you commandeer a dino-robot for use as a mount, you can call it to your side at any moment, but you can’t bring it into any settlements—a minor annoyance made particularly conspicuous when you visit a settlement arranged along a very narrow mountain pass. You leave your mount at one end, then call it to you again…a whole two seconds later. How’d you get here, buddy?</p><p class="sc-77igqf-0 bOfvBY">When allies fall in battle, you can revive them, or they’ll automatically revive after about 30 seconds or so. Great! But when it comes time to follow those allies for a quest, you’ll have to slow down to match their speed. Less great…</p><p class="sc-77igqf-0 bOfvBY">If you approach an environmental puzzle you can’t yet solve due to lacking a piece of gear, Aloy will openly remark how she doesn’t seem to have the necessary equipment, saving you from wasting time learning that yourself the hard way. Actually, hmm, no drawback to that one—it’s simply fantastic.</p><p class="sc-77igqf-0 bOfvBY">There are dozens if not hundreds of fast-travel points, designated as campfires. The catch? You can only initiate travel when you’re at one of those campfires, unless you want to burn hard-earned shards (<em>Horizon</em>’s in-game currency).</p><div class="bxm4mm-15 BiRlJ js_movable_ad_slot"><div class="bxm4mm-17 dJGqTR"><label class="bxm4mm-16 evEDSN">Advertisement</label><div is="bulbs-dfp" class="ad-container dfp dfp-slot-MID_BANNER ad-middleboard" data-ad-unit="MID_BANNER" data-targeting="{&quot;pos&quot;:&quot;mid_banner&quot;}"></div><div class="bt-wrapper"><span data-uid="5d1b8a6cd5-384" class="bt-uid-tg" style="display:none !important;text-align:center" data-css-selector="ad-container.ad-middleboard"></span></div></div></div><p class="sc-77igqf-0 bOfvBY">The autosave is forgiving, but if you want to manually save (c’mon, who here has full trust in the autosave?), you can only do it at one of these campfires.</p><p class="sc-77igqf-0 bOfvBY">Then there’s the stash, one of <em>Forbidden West</em>’s most singularly accommodating features. When you loot a resource your pack is already full of, it’ll automatically go into your stash, which shows up at any of the game’s bazillion outposts and, in my experience, has limitless space. But while you’re exploring, you still have to stop in your tracks to pick stuff up; you can’t snag some flowers while sprinting through a field, à la <em>Ghost of Tsushima</em>.</p><p class="sc-77igqf-0 bOfvBY">It’s a bummer that <em>Horizon Forbidden West</em> doesn’t make looting as seamless as possible, because the game is designed to have you loot <em>everything</em>. While exploring, you’ll nab ridgewood, fiberzest, vigorstem, bitter leaf, sourflame, medicinal berries, and crunchy spikestalks from a sea of vegetation. Off the metal skeletons of machines, you’ll get tusks, nerves, cores, coils, blaze, sparkers, circulators, stickpaste, blastpaste, glowblast, chillwater, purgewater, metalbite, crystal braiding, volatile sludge, machine hearts, machine muscle, machine minds. In chests and sunken caches, you’ll find relics from the old world, sellable trinkets like chimes (car keys) or jewelry (a smartwatch). All of those are real items from the game, by the way, save for one I totally made up. (See if you can’t guess.)</p><p class="sc-77igqf-0 bOfvBY">These are essential not just for crafting various traps and tools but also for participating in <em>Horizon Forbidden West</em>’s economy. Want to buy a “pulverizing spike thrower”? Well, you’ll need 1,062 shards, a sunwing circulator, and a large machine core. Want to upgrade its efficacy? Okay, now you need 127 shards, four braided wires, four small machine cores, and one medium machine core. For the next level, and for the one after that, you’ll need a wholly different set of loot. These requirements are distinct for every piece of gear in the game.</p><div class="bxm4mm-15 BiRlJ js_movable_ad_slot"><div class="bxm4mm-17 dJGqTR"><label class="bxm4mm-16 evEDSN">Advertisement</label><div is="bulbs-dfp" class="ad-container dfp dfp-slot-MID_BANNER ad-middleboard" data-ad-unit="MID_BANNER" data-targeting="{&quot;pos&quot;:&quot;mid_banner&quot;}"></div><div class="bt-wrapper"><span data-uid="5d1b8a6cd5-384" class="bt-uid-tg" style="display:none !important;text-align:center" data-css-selector="ad-container.ad-middleboard"></span></div></div></div><p class="sc-77igqf-0 bOfvBY">That’s not all. If you want to increase your carrying capacity, you’ll have to hunt non-machine creatures—actual animals—for hides, bones, feathers, and such, an act that gets real old, real fast. I’m not just saying this because the whimper a fox makes when it dies sounds a lot like the noise my cat makes when he’s hungry. (Okay, I’m kinda saying this because the whimper a fox makes when it dies sounds a lot like the noise my cat makes when he’s hungry.) It all feels like a tedious vestige from a prior era of gaming. Just let me spend my shards on a bigger quiver!</p><p class="sc-77igqf-0 bOfvBY">All of your gear—whether it’s a long-range “sharpshot” bow or a snazzy armor set with perks that fit your playstyle—has a distinct array of stats, correlating positive or negative defense ratings for a litany of elemental damage types. You can tweak your equipment with “coils,” or augmentations, applying minor stat bonuses. Every enemy, too, is resistant to certain elements and weak to others, info you can pick up by highlighting them with Aloy’s Focus device.</p><figure class="sc-1eow4w5-1 dhDQnh align--bleed js_lazy-image js_marquee-assetfigure" data-id="3780fa424c5228a04e5c6e3881c320bf" data-recommend-id="image://3780fa424c5228a04e5c6e3881c320bf" data-format="jpg" data-width="3840" data-height="2160" data-lightbox="true" data-alt="Aloy tries, and fails, to sneak up on a fireclaw in Horizon Forbidden West on PS5." data-recommended="false" data-hide="false" contenteditable="false" draggable="false"><div class="sc-1eow4w5-2 loxZOX has-data img-wrapper" contenteditable="false" style="max-width:3840px" data-alt="Aloy tries, and fails, to sneak up on a fireclaw in Horizon Forbidden West on PS5." data-link-reference="" data-link-target="" data-syndicationrights="true" data-imagerights="fair-use" data-hidecredit="false"><span class="sc-1eow4w5-0 dnhHtZ js_lightbox-wrapper js_lightbox-initialized"><div class="sc-1m41dwj-0 bByIIk magnifier js_lightbox lightbox"><span class="iyvn34-0 bYIjtl"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" aria-label="ZoomIn icon" viewBox="0 0 18 18"><path fill-rule="evenodd" d="M10.5 1a6.5 6.5 0 1 1-4.23 11.44l-4.42 4.41a.5.5 0 0 1-.7-.7l4.41-4.42A6.5 6.5 0 0 1 10.5 1zm0 1a5.5 5.5 0 1 0 0 11 5.5 5.5 0 0 0 0-11zm0 2c.28 0 .5.22.5.5V7h2.5a.5.5 0 0 1 .5.41v.09a.5.5 0 0 1-.5.5H11v2.5a.5.5 0 0 1-.41.5h-.09a.5.5 0 0 1-.5-.5V8H7.5a.5.5 0 0 1-.5-.41V7.5c0-.28.22-.5.5-.5H10V4.5a.5.5 0 0 1 .41-.5z"></path></svg></span></div><div style="padding-bottom:56.3%" class="sc-1eow4w5-3 lktKQM image-hydration-wrapper"><div><img src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Aloy tries, and fails, to sneak up on a fireclaw in Horizon Forbidden West on PS5." data-srcset="https://i.kinja-img.com/gawker-media/image/upload/c_fill,f_auto,fl_progressive,g_center,h_80,pg_1,q_80,w_80/3780fa424c5228a04e5c6e3881c320bf.jpg 80w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_140/3780fa424c5228a04e5c6e3881c320bf.jpg 140w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_265/3780fa424c5228a04e5c6e3881c320bf.jpg 265w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_340/3780fa424c5228a04e5c6e3881c320bf.jpg 340w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_490/3780fa424c5228a04e5c6e3881c320bf.jpg 490w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_645/3780fa424c5228a04e5c6e3881c320bf.jpg 645w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_740/3780fa424c5228a04e5c6e3881c320bf.jpg 740w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_965/3780fa424c5228a04e5c6e3881c320bf.jpg 965w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_1165/3780fa424c5228a04e5c6e3881c320bf.jpg 1165w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_1315/3780fa424c5228a04e5c6e3881c320bf.jpg 1315w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_1465/3780fa424c5228a04e5c6e3881c320bf.jpg 1465w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_1600/3780fa424c5228a04e5c6e3881c320bf.jpg 1600w" sizes="
				(max-width: 25em) calc(100vw - 32px),
				(max-width: 37.31em) calc(100vw - 32px),
				(min-width: 37.37em) and (max-width: 49.94em) calc(100vw - 32px),
				(min-width: 50em) and (max-width: 63.69em) 800px,
				(min-width: 63.75em) and (max-width: 85.19em) calc(66.5vw - 32px),
				800px
			" draggable="auto" data-chomp-id="3780fa424c5228a04e5c6e3881c320bf" data-format="jpg" data-alt="Aloy tries, and fails, to sneak up on a fireclaw in Horizon Forbidden West on PS5." data-anim-src=""></div></div></span><div class="sc-1eow4w5-4 bNSWel image-meta"><figcaption class="sc-1ptbguh-0 hxeMec caption">Do you think it sees it me?</figcaption><figcaption class="sc-7s1ndr-0 ikKPtM has-caption">Screenshot<!-- -->: <!-- -->Sony / Kotaku</figcaption></div></div><span data-id="3780fa424c5228a04e5c6e3881c320bf" data-recommend-id="image://3780fa424c5228a04e5c6e3881c320bf" data-format="jpg" data-width="3840" data-height="2160" data-lightbox="true" data-alt="Aloy tries, and fails, to sneak up on a fireclaw in Horizon Forbidden West on PS5." data-recommended="false" data-hide="false" class="js_recommend"></span></figure><p class="sc-77igqf-0 bOfvBY"><em>Zero Dawn</em> set itself apart from its contemporaries by encouraging a thoughtful, tactical approach to combat, something that remains present in <em>Forbidden West</em>. You might be several levels over par, you might be playing on the standard difficulty tier, and you could still get stomped by a robot velociraptor if you’re not careful. Battles play out smoothest if you hammer out a plan of attack beforehand—marking enemy walking routes and laying traps and crafting the most effective ammo—so it behooves you to quietly assess combat scenarios from the sidelines and tailor your loadouts before jumping into the fray. But we all know how plans go, and sometimes you need to quickly break out the big bows. Whatever the case, your odds are best if you have a wide array of fully leveled-up equipment.<br></p><div class="bxm4mm-15 BiRlJ js_movable_ad_slot"><div class="bxm4mm-17 dJGqTR"><label class="bxm4mm-16 evEDSN">Advertisement</label><div is="bulbs-dfp" class="ad-container dfp dfp-slot-MID_BANNER ad-middleboard" data-ad-unit="MID_BANNER" data-targeting="{&quot;pos&quot;:&quot;mid_banner&quot;}"></div><div class="bt-wrapper"><span data-uid="5d1b8a6cd5-384" class="bt-uid-tg" style="display:none !important;text-align:center" data-css-selector="ad-container.ad-middleboard"></span></div></div></div><p class="sc-77igqf-0 bOfvBY">I’m sure some people will salivate over all this potential fine-tuning; that sound you hear is the dulcet chorus of a thousand Google Sheets being opened and primed around the world. Me? I unlocked a skill that essentially turned one of Aloy’s bows into a rocket launcher and stopped obsessing about that stuff. If I had the loot necessary to complete an upgrade or buy a snazzy set of armor, cool! If not, well, so be it. I had rockets.</p><hr class="gcp5ez-1 ldUzol"><p class="sc-77igqf-0 bOfvBY">Nothing in <em>Horizon Forbidden West</em> sunk its claws in me more than a mini-game. I’m not sure when exactly this trend truly took off—I blame <em>The Witcher 3</em>’s “Gwent”—but every expansive open-world RPG these days apparently has to feature an in-universe board game of some sort. <em>Horizon Forbidden West</em>’s take is a turn-based tactics game called “Machine Strike.”<br></p><figure class="sc-1eow4w5-1 dhDQnh align--bleed js_lazy-image js_marquee-assetfigure" data-id="313e1d77e4bd46dd04b79a363ba6690f" data-recommend-id="image://313e1d77e4bd46dd04b79a363ba6690f" data-format="jpg" data-width="1920" data-height="1080" data-lightbox="true" data-alt="A player moves a lancehorn piece in Machine Strike mini game in Horizon Forbidden West on PS5." data-recommended="false" data-hide="false" contenteditable="false" draggable="false"><div class="sc-1eow4w5-2 loxZOX has-data img-wrapper" contenteditable="false" style="max-width:1920px" data-alt="A player moves a lancehorn piece in Machine Strike mini game in Horizon Forbidden West on PS5." data-link-reference="" data-link-target="" data-syndicationrights="true" data-imagerights="fair-use" data-hidecredit="false"><span class="sc-1eow4w5-0 dnhHtZ js_lightbox-wrapper js_lightbox-initialized"><div class="sc-1m41dwj-0 bByIIk magnifier js_lightbox lightbox"><span class="iyvn34-0 bYIjtl"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" aria-label="ZoomIn icon" viewBox="0 0 18 18"><path fill-rule="evenodd" d="M10.5 1a6.5 6.5 0 1 1-4.23 11.44l-4.42 4.41a.5.5 0 0 1-.7-.7l4.41-4.42A6.5 6.5 0 0 1 10.5 1zm0 1a5.5 5.5 0 1 0 0 11 5.5 5.5 0 0 0 0-11zm0 2c.28 0 .5.22.5.5V7h2.5a.5.5 0 0 1 .5.41v.09a.5.5 0 0 1-.5.5H11v2.5a.5.5 0 0 1-.41.5h-.09a.5.5 0 0 1-.5-.5V8H7.5a.5.5 0 0 1-.5-.41V7.5c0-.28.22-.5.5-.5H10V4.5a.5.5 0 0 1 .41-.5z"></path></svg></span></div><div style="padding-bottom:56.3%" class="sc-1eow4w5-3 lktKQM image-hydration-wrapper"><div><img src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="A player moves a lancehorn piece in Machine Strike mini game in Horizon Forbidden West on PS5." data-srcset="https://i.kinja-img.com/gawker-media/image/upload/c_fill,f_auto,fl_progressive,g_center,h_80,pg_1,q_80,w_80/313e1d77e4bd46dd04b79a363ba6690f.jpg 80w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_140/313e1d77e4bd46dd04b79a363ba6690f.jpg 140w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_265/313e1d77e4bd46dd04b79a363ba6690f.jpg 265w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_340/313e1d77e4bd46dd04b79a363ba6690f.jpg 340w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_490/313e1d77e4bd46dd04b79a363ba6690f.jpg 490w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_645/313e1d77e4bd46dd04b79a363ba6690f.jpg 645w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_740/313e1d77e4bd46dd04b79a363ba6690f.jpg 740w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_965/313e1d77e4bd46dd04b79a363ba6690f.jpg 965w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_1165/313e1d77e4bd46dd04b79a363ba6690f.jpg 1165w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_1315/313e1d77e4bd46dd04b79a363ba6690f.jpg 1315w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_1465/313e1d77e4bd46dd04b79a363ba6690f.jpg 1465w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_1600/313e1d77e4bd46dd04b79a363ba6690f.jpg 1600w" sizes="
				(max-width: 25em) calc(100vw - 32px),
				(max-width: 37.31em) calc(100vw - 32px),
				(min-width: 37.37em) and (max-width: 49.94em) calc(100vw - 32px),
				(min-width: 50em) and (max-width: 63.69em) 800px,
				(min-width: 63.75em) and (max-width: 85.19em) calc(66.5vw - 32px),
				800px
			" draggable="auto" data-chomp-id="313e1d77e4bd46dd04b79a363ba6690f" data-format="jpg" data-alt="A player moves a lancehorn piece in Machine Strike mini game in Horizon Forbidden West on PS5." data-anim-src=""></div></div></span><div class="sc-1eow4w5-4 bNSWel image-meta"><figcaption class="sc-7s1ndr-0 ikKPtM no-caption">Screenshot<!-- -->: <!-- -->Sony / Kotaku</figcaption></div></div><span data-id="313e1d77e4bd46dd04b79a363ba6690f" data-recommend-id="image://313e1d77e4bd46dd04b79a363ba6690f" data-format="jpg" data-width="1920" data-height="1080" data-lightbox="true" data-alt="A player moves a lancehorn piece in Machine Strike mini game in Horizon Forbidden West on PS5." data-recommended="false" data-hide="false" class="js_recommend"></span></figure><p class="sc-77igqf-0 bOfvBY">Matches of “Machine Strike” play out on a square grid-based board. You and an opponent each have a set number of pieces, all based on the machines you fight against in the “real” game. Your goal isn’t to wipe out all of your opponent’s pieces. See, every piece is allotted a number of points. Taking an opponent’s piece out will award you that many points; similarly, if you lose a piece, your opponent will earn however many points it was worth. Your goal is to hit seven points before your opponent does.<br></p><div class="bxm4mm-15 BiRlJ js_movable_ad_slot"><div class="bxm4mm-17 dJGqTR"><label class="bxm4mm-16 evEDSN">Advertisement</label><div is="bulbs-dfp" class="ad-container dfp dfp-slot-MID_BANNER ad-middleboard" data-ad-unit="MID_BANNER" data-targeting="{&quot;pos&quot;:&quot;mid_banner&quot;}"></div><div class="bt-wrapper"><span data-uid="5d1b8a6cd5-384" class="bt-uid-tg" style="display:none !important;text-align:center" data-css-selector="ad-container.ad-middleboard"></span></div></div></div><p class="sc-77igqf-0 bOfvBY">You’re given 10 points to customize a set of pieces. Stronger pieces, which have higher attack and HP values, are typically worth more points. So it becomes a measure of risk-versus-reward. Do you stack your set with low-value, low-power pieces? Or do you choose just a couple of strong ones?</p><p class="sc-77igqf-0 bOfvBY">The board itself is a strategic landmine. Tiles can appear as one of six terrain types, which alter a piece’s stats, sometimes providing bonus effects or debuffs. Plus, every piece—just like the machines they’re based on—has strengths and weaknesses. Attack one from the side and you may deal extra damage. Attack another from the same vantage, however, and you might hit armored sides, nullifying some of your damage.</p><p class="sc-77igqf-0 bOfvBY">I cannot possibly emphasize this enough: “Machine Strike” on its lonesome might already be my favorite game of the year. (I’m a <span><a class="sc-1out364-0 hMndXN sc-145m8ut-0 eRdxJX js_link" data-ga="[[&quot;Embedded Url&quot;,&quot;Internal link&quot;,&quot;https://kotaku.com/best-switch-games-flying-mario-rabbids-fire-emblem-ace-1848475931&quot;,{&quot;metric25&quot;:1}]]" href="https://kotaku.com/best-switch-games-flying-mario-rabbids-fire-emblem-ace-1848475931">huge sucker for good tactics</a></span>.) Were I not on a tight deadline to complete <em>Horizon Forbidden West</em>, I’d have sought out every single “Machine Strike” player.</p><p class="sc-77igqf-0 bOfvBY">Oh, yes, “Machine Strike” isn’t just something you access via menus. Most towns, cities, and settlements are home to an NPC who plays the game. Defeat them on three boards and they’ll award you with a piece, which you can use to further customize your sets, helping you defeat tougher players in other towns. One afternoon, I found myself wholly ignoring my more pressing quest log and, instead, charted a course from Plainsong to Scalding Spear through Fall’s Edge and Thornmarsh—yes, the city names are amazing—just to seek out more “Machine Strike” players.</p><div class="bxm4mm-15 BiRlJ js_movable_ad_slot"><div class="bxm4mm-17 dJGqTR"><label class="bxm4mm-16 evEDSN">Advertisement</label><div is="bulbs-dfp" class="ad-container dfp dfp-slot-MID_BANNER ad-middleboard" data-ad-unit="MID_BANNER" data-targeting="{&quot;pos&quot;:&quot;mid_banner&quot;}"></div><div class="bt-wrapper"><span data-uid="5d1b8a6cd5-384" class="bt-uid-tg" style="display:none !important;text-align:center" data-css-selector="ad-container.ad-middleboard"></span></div></div></div><p class="sc-77igqf-0 bOfvBY">It’s one small touch that makes <em>Horizon Forbidden West</em>’s settlements more than mere pit stops for resupplying. These cities aren’t real places, but sometimes feel like they are. Despite playing a major role in the game’s marketing, San Francisco plays a disappointingly minor role in <em>Forbidden West</em>’s overarching story, not even showing up (for me at least) until the 25-hour mark. Instead, you spend much of your time bouncing between truly visionary locales: a bustling post-apocalyptic metropolis built around a crashed cargo plane in the Nevada desert; a driftwood citadel on a whitesand beach near– according to my admittedly amateur geolocating–modern-day Alameda. It’s fantastical digital tourism at its finest.</p><div class="js_full-bleed-widget" data-props="{&quot;hide&quot;:false,&quot;image&quot;:{&quot;id&quot;:&quot;f24861978df1cfc55bcafb8cdc457153&quot;,&quot;format&quot;:&quot;jpg&quot;,&quot;isAnimated&quot;:false,&quot;frozenFormat&quot;:&quot;jpg&quot;},&quot;link&quot;:null,&quot;caption&quot;:[],&quot;attribution&quot;:[{&quot;label&quot;:&quot;Screenshot&quot;,&quot;credit&quot;:[{&quot;styles&quot;:[],&quot;value&quot;:&quot;Sony / Kotaku&quot;,&quot;type&quot;:&quot;Text&quot;}],&quot;source&quot;:[]}],&quot;syndicationRights&quot;:true,&quot;title&quot;:&quot;&amp;lt;i&amp;gt;Horizon Forbidden West&amp;lt;/i&amp;gt;: The &amp;lt;i&amp;gt;Kotaku&amp;lt;/i&amp;gt; Review&quot;,&quot;imageRights&quot;:&quot;fair-use&quot;,&quot;attributionsEnabled&quot;:true,&quot;language&quot;:&quot;en-US&quot;}"><div><figure class="full-bleed-widget has-data" style="margin-top:0;margin-bottom:0" data-alt="&amp;lt;i&amp;gt;Horizon Forbidden West&amp;lt;/i&amp;gt;: The &amp;lt;i&amp;gt;Kotaku&amp;lt;/i&amp;gt; Review" data-link-reference="" data-link-target="" data-syndicationrights="true" data-imagerights="fair-use"><div class="sc-1rnkdii-4 hgOHgz full-bleed-container full-bleed-f24861978df1cfc55bcafb8cdc457153-1848524470"><div class="sc-1rnkdii-3 hxSsJh"><img src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" srcset="https://i.kinja-img.com/gawker-media/image/upload/c_fill,f_auto,fl_progressive,g_center,h_80,pg_1,q_80,w_80/f24861978df1cfc55bcafb8cdc457153.jpg 80w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_140/f24861978df1cfc55bcafb8cdc457153.jpg 140w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_265/f24861978df1cfc55bcafb8cdc457153.jpg 265w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_340/f24861978df1cfc55bcafb8cdc457153.jpg 340w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_490/f24861978df1cfc55bcafb8cdc457153.jpg 490w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_645/f24861978df1cfc55bcafb8cdc457153.jpg 645w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_740/f24861978df1cfc55bcafb8cdc457153.jpg 740w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_965/f24861978df1cfc55bcafb8cdc457153.jpg 965w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_1165/f24861978df1cfc55bcafb8cdc457153.jpg 1165w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_1315/f24861978df1cfc55bcafb8cdc457153.jpg 1315w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_1465/f24861978df1cfc55bcafb8cdc457153.jpg 1465w, https://i.kinja-img.com/gawker-media/image/upload/c_fit,f_auto,g_center,pg_1,q_60,w_1600/f24861978df1cfc55bcafb8cdc457153.jpg 1600w" alt="&amp;lt;i&amp;gt;Horizon Forbidden West&amp;lt;/i&amp;gt;: The &amp;lt;i&amp;gt;Kotaku&amp;lt;/i&amp;gt; Review" draggable="auto" data-chomp-id="f24861978df1cfc55bcafb8cdc457153" data-format="jpg" data-alt="&amp;lt;i&amp;gt;Horizon Forbidden West&amp;lt;/i&amp;gt;: The &amp;lt;i&amp;gt;Kotaku&amp;lt;/i&amp;gt; Review" data-anim-src=""></div></div><figcaption class="sc-7s1ndr-0 ikKPtM no-caption">Screenshot<!-- -->: <!-- -->Sony / Kotaku</figcaption></figure></div></div><p class="sc-77igqf-0 bOfvBY">That’s what you want from an open-world game, right? Not necessarily an airtight main plot, as nice as such a thing is, but a believable, well-realized world you can lose yourself in. In that regard, <em>Horizon Forbidden West</em> hits it out of the park.<br></p><hr class="gcp5ez-1 ldUzol"><p class="sc-77igqf-0 bOfvBY">A side-quest in <em>Horizon Forbidden West</em>’s opening area introduces you to an elderly man. He’s sitting on a ledge high in the mountains, staring at a giant robot pterodactyl embedded in a rocky spire, well and truly dead. He’s convinced that its death was an act of the gods, that observing it will grant him salvation, and so he plans on sitting and staring and waiting until he’s shown the heavenly lit way to a new home where everything is safe. Aloy points out how, actually, the bird-robot was gunned down by heavy artillery. He doesn’t listen. He’s convinced it’s a sign.<br></p><div class="bxm4mm-15 BiRlJ js_movable_ad_slot"><div class="bxm4mm-17 dJGqTR"><label class="bxm4mm-16 evEDSN">Advertisement</label><div is="bulbs-dfp" class="ad-container dfp dfp-slot-MID_BANNER ad-middleboard" data-ad-unit="MID_BANNER" data-targeting="{&quot;pos&quot;:&quot;mid_banner&quot;}"></div><div class="bt-wrapper"><span data-uid="5d1b8a6cd5-384" class="bt-uid-tg" style="display:none !important;text-align:center" data-css-selector="ad-container.ad-middleboard"></span></div></div></div><p class="sc-77igqf-0 bOfvBY">Setting aside the high-minded sci-fi hijinks, <em>Horizon Forbidden West</em> is at its core about the extent to which characters will go to find faith and meaning. In her newfound “savior” status—again, still weird—Aloy finds herself fielding many of these evidence-free assertions. People go on and on about “land gods” and “diviners” and “legacies” and blah blah blah. At every turn, Aloy reacts to these whims with curled-lip bemusement. They claim to see god. Aloy knows the truth; she literally sees it.</p><p class="sc-77igqf-0 bOfvBY">By the end of the game, I found myself reacting to <em>Horizon Forbidden West</em> itself with a similar curled-lip bemusement.</p><aside contenteditable="false" class="cqxoak-0 hwjjIu align--fullbleed js_lazy-image"><section title="Horizon Forbidden West" class="aebpua-12 dTZpqJ reviewbox-inset"><div class="sc-38bsvh-0 eWWNTp"><a class="sc-1out364-0 hMndXN js_link" href="/reviews/playstation"><span class="ov8naf-0 creXzv">PlayStation</span></a></div><div class="aebpua-2 idhAuO"><div class="aebpua-10 dkkzel"><div class="aebpua-11 jqGhcY"><div><img src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" data-srcset="https://i.kinja-img.com/gawker-media/image/upload/c_fill,f_auto,fl_progressive,g_center,h_80,pg_1,q_80,w_80/9873b9b8540bb3e6ab077a600b72cdfe.jpg 80w, https://i.kinja-img.com/gawker-media/image/upload/c_fill,f_auto,g_center,h_78,pg_1,q_60,w_140/9873b9b8540bb3e6ab077a600b72cdfe.jpg 140w, https://i.kinja-img.com/gawker-media/image/upload/c_fill,f_auto,g_center,h_149,pg_1,q_60,w_265/9873b9b8540bb3e6ab077a600b72cdfe.jpg 265w, https://i.kinja-img.com/gawker-media/image/upload/c_fill,f_auto,g_center,h_191,pg_1,q_60,w_340/9873b9b8540bb3e6ab077a600b72cdfe.jpg 340w, https://i.kinja-img.com/gawker-media/image/upload/c_fill,f_auto,g_center,h_275,pg_1,q_60,w_490/9873b9b8540bb3e6ab077a600b72cdfe.jpg 490w, https://i.kinja-img.com/gawker-media/image/upload/c_fill,f_auto,g_center,h_362,pg_1,q_60,w_645/9873b9b8540bb3e6ab077a600b72cdfe.jpg 645w, https://i.kinja-img.com/gawker-media/image/upload/c_fill,f_auto,g_center,h_416,pg_1,q_60,w_740/9873b9b8540bb3e6ab077a600b72cdfe.jpg 740w, https://i.kinja-img.com/gawker-media/image/upload/c_fill,f_auto,g_center,h_542,pg_1,q_60,w_965/9873b9b8540bb3e6ab077a600b72cdfe.jpg 965w, https://i.kinja-img.com/gawker-media/image/upload/c_fill,f_auto,g_center,h_655,pg_1,q_60,w_1165/9873b9b8540bb3e6ab077a600b72cdfe.jpg 1165w, https://i.kinja-img.com/gawker-media/image/upload/c_fill,f_auto,g_center,h_739,pg_1,q_60,w_1315/9873b9b8540bb3e6ab077a600b72cdfe.jpg 1315w, https://i.kinja-img.com/gawker-media/image/upload/c_fill,f_auto,g_center,h_824,pg_1,q_60,w_1465/9873b9b8540bb3e6ab077a600b72cdfe.jpg 1465w, https://i.kinja-img.com/gawker-media/image/upload/c_fill,f_auto,g_center,h_900,pg_1,q_60,w_1600/9873b9b8540bb3e6ab077a600b72cdfe.jpg 1600w" sizes="(max-width: 520px) 470px, 800px" draggable="auto" data-chomp-id="9873b9b8540bb3e6ab077a600b72cdfe" data-format="jpg" data-anim-src=""></div></div></div><div class="aebpua-3 eVtkCP"><div class="aebpua-4 gXmRQM"><div class="sc-38bsvh-0 jRWLHW"><a class="sc-1out364-0 hMndXN js_link" href="/reviews/playstation"><span class="ov8naf-0 creXzv">PlayStation</span></a></div><h2 class="aebpua-0 kkBAyA">Horizon Forbidden West</h2></div></div></div><div class="aebpua-9 fkvRdM"><h2 class="aebpua-0 kkBAyA">Horizon Forbidden West</h2><div class="aebpua-5 dPyBYN"><div class="aebpua-6 ePSRNa"><h2 class="aebpua-7 hDlcFx">Back-of-the-box quote</h2><p class="aebpua-8 cPlQco">"No BotW to distract you this time!" - Kotaku.com</p></div><div class="aebpua-6 ePSRNa"><h2 class="aebpua-7 hDlcFx">Type of game</h2><p class="aebpua-8 cPlQco">Sci-fi twist on the Museum of Natural History's dino hall</p></div><div class="aebpua-6 ePSRNa"><h2 class="aebpua-7 hDlcFx">Liked</h2><p class="aebpua-8 cPlQco">Fluid combat, sharp dialogue, a rewarding open world, constantly getting distracted by how damn pretty everything is.</p></div><div class="aebpua-6 ePSRNa"><h2 class="aebpua-7 hDlcFx">Disliked</h2><p class="aebpua-8 cPlQco">Instances of tone-deafness, minor inconveniences due to outdated design, a story that goes off the rails</p></div><div class="aebpua-6 ePSRNa"><h2 class="aebpua-7 hDlcFx">Developer</h2><p class="aebpua-8 cPlQco">Guerrilla Games</p></div><div class="aebpua-6 ePSRNa"><h2 class="aebpua-7 hDlcFx">Platforms</h2><p class="aebpua-8 cPlQco">PS4, PS5 (played)</p></div><div class="aebpua-6 ePSRNa"><h2 class="aebpua-7 hDlcFx">Release date</h2><p class="aebpua-8 cPlQco">February 18, 2022</p></div><div class="aebpua-6 ePSRNa"><h2 class="aebpua-7 hDlcFx">Played</h2><p class="aebpua-8 cPlQco">Roughly 50 hours to hit the credits with roughly 50 percent completion</p></div></div></div></section></aside><p class="sc-77igqf-0 bOfvBY"><em>Horizon Zero Dawn</em> succeeded for many, many reasons, though perhaps its strongest feature was the way it expertly conveyed a dual-timeline narrative split between past (how the earth succumbed to robot apocalypse) and present (how the earth’s current inhabitants want to prevent another one). You made as much of the tale as you wanted to. Audio logs and text messages filled in the backstory of how exactly the world dovetailed into shit. You could opt into these as much or as little as you chose, but even if you availed yourself of every one, you’d still not know everything, not really. You filled in the gaps yourself.<br></p><div class="bxm4mm-15 BiRlJ js_movable_ad_slot"><div class="bxm4mm-17 dJGqTR"><label class="bxm4mm-16 evEDSN">Advertisement</label><div is="bulbs-dfp" class="ad-container dfp dfp-slot-MID_BANNER ad-middleboard" data-ad-unit="MID_BANNER" data-targeting="{&quot;pos&quot;:&quot;mid_banner&quot;}"></div><div class="bt-wrapper"><span data-uid="5d1b8a6cd5-384" class="bt-uid-tg" style="display:none !important;text-align:center" data-css-selector="ad-container.ad-middleboard"></span></div></div></div><p class="sc-77igqf-0 bOfvBY">Audio logs and text messages are still present (by the hundreds) in the sequel, but <em>Horizon Forbidden West</em> goes out of its way to explicitly address questions—not just those posed in this game but those lingering from the first one too. <em>Horizon</em> is at its most intriguing when you’re slowly unspooling the thread. The magic trick doesn’t quite land when you’re having everything imparted to you via lecture and exposition. You and I will never know every little thing about the real world we live in—about its people, about its history. Why do we need to know so much about this fake one? Where’s the room for some imagination?</p><p class="sc-77igqf-0 bOfvBY">It’s not solely a problem with <em>Horizon Forbidden West</em>, nor is it a problem limited to video games. You see it across popular genre fiction these days, as everything from <em>Star Wars</em> to the Marvel Cinematic Universe doubles down on plot over people, going so far as to fill in backstories for enigmatic characters who were killed off years ago. Everyone does it these days. It’s the safe play. Welcome to the Era of Fandom.</p><p class="sc-77igqf-0 bOfvBY">I thoroughly enjoyed <em>Horizon Forbidden West</em>, and I suspect anyone who loves open-world RPGs will thoroughly enjoy it as well. But despite getting a kick out of fighting robot dinos, despite the enthralling time sink of “Machine Strike,” despite finding myself ravenous to return to this rich, inspired open world, I can’t shake how plainly <em>Forbidden West</em> misses the one philosophical throughline that helped its predecessor ascend to greatness: Sometimes, the question is more interesting than the answer.</p><div class="wdg44t-8 dLnlzm js_newsletter-form-inline"><div class="wdg44t-9 laHSQO"><div class="wdg44t-32 wdg44t-34 jqAtOF"><div class="wdg44t-19 kMnMdL"><div class="wdg44t-20 gcOyOQ"><div class="sc-2d8w30-0 ctRAld"><div class="sc-2d8w30-1 bRnfTk kotaku"><svg xmlns="http://www.w3.org/2000/svg" width="212" height="39" aria-label="Kotaku logo" viewBox="0 0 212 39"><path fill-rule="evenodd" d="M191.72 5.28l1.2 17.98-8.58.16-1-18.37-6.51-.17.94 21.03c.13 3 2.28 5.38 4.77 5.29l12.99-.49c2.3-.09 3.97-2.48 3.75-5.33l-1.5-19.93-6.06-.17zm13.1 1.62c-.2-2.61-1.88-4.8-3.78-4.88l-1.74-.07.64 9.67 5.22.08-.34-4.8zm6.8 0c-.23-2.61-1.9-4.8-3.77-4.87l-1.71-.08.72 9.67 5.14.08-.39-4.8zm-60.2-3l.2 28.28 2.58-.1c2.85-.1 5.1-2.77 5.04-5.93L158.9 4.1l-7.46-.2zm7.83 10.72l8.01.04c2.62.01 3.8 1.18 4.79 3.02l9.66 20.68c-1.07 1.4-7.06.8-9.53-4.74l-5.12-11.27-.45.01-.4.01c-2.76.04-7.05-2.58-6.96-7.74zM143.39 4.23l-12.1-.33c-5.75-.15-7.27 4.83-6.34 8.06l15.81.14-.1 12.1-10.89.2.05-2.14 3.2-.04c5.72-.08 7.1-4.77 6.17-7.94h-.04l.02-.01-11.92-.05c-3.09-.01-5.72 2.61-5.84 5.9l-.04 1.05-.22 6.04c-.13 3.39 2.39 6.06 5.57 5.94l16.55-.63c2.91-.1 5.24-2.8 5.23-5.97l-.05-16.77c-.02-3-2.26-5.47-5.06-5.55zm-39.82 24.5a5.95 5.95 0 0 0 6.33 6.37l3.32-.12 1.08-21.27-9.75-.06-.98 15.08zm13.46-17.03c6.17.05 7.73-5 6.8-8.21l-20.86-.56c-6.64-.18-7.88 5.14-6.96 8.58l21.02.19zM88.76 2.5l-19.43-.54c-7.58-.21-10.1 5.6-9.22 9.38l24.53.23-1.25 14-14.16.27 1.45-12.99-10.9-.07-2.09 16.38c-.5 3.95 2.53 7.07 6.71 6.9l21.57-.8a7.76 7.76 0 0 0 7.31-6.98L94.75 8.9a5.98 5.98 0 0 0-5.99-6.4zm-69.34-.55L12.7 38.02l4.22-.16c4.65-.18 8.92-3.63 9.6-7.67l4.74-27.9-11.84-.34zm11.06 12.68l13.02.05c4.23.02 5.87 1.5 7.02 3.81l8.1 19.65c-2.05 1.8-11.6 1.18-14.3-5.88l-2.96-7.84h-.73l-.63.01c-4.52.06-10.9-3.25-9.52-9.8zM15.7 12.67l1.9-10.51-6.57-.2C1.9 1.7-.63 8.26.12 12.53l15.58.16zm22.73 1.96l16.8-3.68c3.16-1.93 4.51-8.9 2.3-10.95l-16.3 3.95c-2.77 1.5-5.95 5.86-2.8 10.67zm124.62 0l8.93-4.84c3.1-2.63 3.97-6.97 1.32-9.79l-9.64 6.05c-3.44 2.32-2.92 5.76-.61 8.57z"></path></svg></div></div></div><div class="wdg44t-18 wdg44t-21 bRHAot">Subscribe to our newsletter!</div></div><div class="wdg44t-36 ctiwcL">Take Kotaku with you wherever you go.</div><div class="wdg44t-25 hHZsWV"><div class="zguhvl-1 gCeaTF"><label class="zguhvl-3 fjFxOX">Enter your email</label><label class="sc-1k7q01z-0 eqQiYP field"><input type="email" name="inline-footer-form" class="zguhvl-0 FMxdS" value=""></label><button disabled="" class="peggds-2 dLcFcv zguhvl-2 dNgPzL subscribe-button"><label class="peggds-0 bCDGnO">Sign Me Up</label></button></div></div><div class="wdg44t-3 ehCzVH">By subscribing you agree to our<a href="https://g-omedia.com/terms-of-service/"> Terms of Use</a> and<a href="https://g-omedia.com/privacy-policy/"> Privacy Policy</a>.</div></div></div></div><p class="sc-77igqf-0 bOfvBY">&nbsp;<br></p></div></div><div class="js_liveblog-controls"></div><div class="js_qanda-controls"></div><div class="js_ymal-below-post"></div><div class="js_more-below-post"></div><div class="sc-73739c-4 boDAqB"><div class="sc-38bsvh-0 fncPRR"><a class="sc-1out364-0 hMndXN sc-15604uf-0 lgsULC js_link" data-ga="[[&quot;Permalink meta&quot;,&quot;Channel click&quot;,&quot;https://kotaku.com/reviews&quot;]]" href="https://kotaku.com/reviews"><span class="ov8naf-0 kWNwtO">Reviews</span></a><span class="iyvn34-0 bYIjtl sc-15604uf-1 gWTDFv"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" aria-label="DoubleChevronRight icon" viewBox="0 0 18 18"><path fill-rule="evenodd" d="M3.13 3.16a.5.5 0 0 1 .7-.03l6 5.5.07.07a.5.5 0 0 1-.06.67l-6 5.5-.07.05a.5.5 0 0 1-.6-.79L8.75 9l-5.6-5.13-.06-.07a.5.5 0 0 1 .03-.64zm5 0a.5.5 0 0 1 .7-.03l6 5.5.07.07a.5.5 0 0 1-.06.67l-6 5.5-.07.05a.5.5 0 0 1-.6-.79L13.75 9l-5.6-5.13-.06-.07a.5.5 0 0 1 .03-.64z"></path></svg></span><a class="sc-1out364-0 hMndXN sc-15604uf-0 lgsULC js_link" data-ga="[[&quot;Permalink meta&quot;,&quot;Channel click&quot;,&quot;https://kotaku.com/reviews/playstation&quot;]]" href="https://kotaku.com/reviews/playstation"><span class="ov8naf-0 kWNwtO">PlayStation</span></a></div></div><a id="replies" name="replies"></a><div class="js_postbottom-waypoint-hook"></div><div class="sc-73739c-0 bGtOjR js_comments-iframe" data-src="//kotaku.com/embed/comments/magma/1848524470?" data-replycount="198"><div><iframe class="sc-1evupmb-1 isdTrz js_comments-iframe" src="//kotaku.com/embed/comments/magma/1848524470?" height="425"></iframe></div></div><div class="sc-73739c-3 cQhMko"><div id="taboola-below-article-thumbnails" class="sc-73739c-2 gaZVrz"></div></div><div class="sc-1bdg1q0-0 eRJXHT js_sticky-footer"><div class="sc-1bdg1q0-1 wircm js_ad-sticky-footer"></div></div></div>

        </body>
      </html>
import React, { FunctionComponent, useEffect, useState } from 'react'
import styled from "styled-components";
import './styles.scss';
import SelectorInput from "./components/selector-input";
import GoButton from "./components/go-button";
import StartMessage from "./models/messages/start";
import Wave from "./models/wave";
import Options from "./models/options";
import {getSyncObject, GetSyncObjectFunction, newSyncObject, setSyncObject} from './util/sync';
import StopMessage from "./models/messages/stop";
import {fromMessage} from "./util/messages";
import SelectorUpdated from "./models/messages/selector-updated";
// todo: this should work, but jest returns a config is not defined
import configured from './config/config';
// todo: slightly less data driven shim
const isDevelopment = configured.mode !== 'production'; //process.env.NODE_ENV !== 'production';
import { guardLastError } from "./util/util";
import UpdateWaveMessage from "./models/messages/update-wave";
import { Settings } from "./components/settings";

import WaveTabs from './components/wave-tabs';
import InstalledDetails = chrome.runtime.InstalledDetails;
import {CState, NameAccessMapInterface, Named, State, StateNames} from "./util/state";
import StateMachine from "./util/state-machine";

import SettingsService from "./services/settings";
//import SelectorService from "./services/selector";
import {Observer} from "rxjs";
import RemoveSelectorMessage from "./models/messages/remove-selector";
import StartSelectorChooseMessage from "./models/messages/start-selection-choose";
import {SelectorsDefaultFactory} from "./models/defaults";
import stateMachine from "./util/state-machine";
import {Selector} from "./services/selector-hierarchy";
import SelectionModeActivateMessage from "./models/messages/selection-mode-activate";
import SelectionModeDeactivateMessage from "./models/messages/selection-mode-deactivate";
import EndSelectorChooseMessage from "./models/messages/end-selection-choose";
import AddSelectorMessage from "./models/messages/add-selector";
import SelectionMadeMessage from "./models/messages/selection-made";

import { clientForLocation } from "./config/robotcopy";
import { ClientLocation } from "./util/state-machine";

const PopupClient = clientForLocation(ClientLocation.POPUP)

//todo:
// * Material UI
// * Controls: read speed, reset speed, rotation angle, wave width, read duration
// * save selector and settings with chrome sync
// * keyboard shortcut toggle
// * mouse movement
// * audio from the ocean or the highway, coffee shop, or white or brown noise
// * education ([Orton Gillingham](https://en.wikipedia.org/wiki/Orton-Gillingham) &
//              [Phonics](https://en.wikipedia.org/wiki/Phonics)) & about page
// * support for right to left, top to bottom etc, perhaps a "direction" option as a toggle switch in the settings menu?
// * maybe a 3d swirl wave for the F-shaped pattern readers?
//      https://www.nngroup.com/articles/f-shaped-pattern-reading-web-content/
//      https://en.wikipedia.org/wiki/Screen_reading
// * a css animation stop per row on the active viewport could be cool and would support the layer cake pattern if
//     we added stops at each horizontal
//     or possibly add a F-shaped layer cake swirl that would 3d swirl each layer cake section as a hybrid?
//         https://www.nngroup.com/articles/layer-cake-pattern-scanning/
// * add an "advanced settings" option (that saves), to show the css, and default false
// * think about the implications of your brain recognizing what it's holding by motion of your hands?
//   * camera input ML (machine learning) for holding your hands in front of the screen, and interpreting the motion of the ocean
//      and possibly scrolling the page by pawing or turning the page
//
//todo,ne:
// * NOTE: popup, chrome.runtime.sendMessage -> background, chrome.tabs.query...sendMessage -> content
// * NOTE: content, chrome.runtime.sendMessage -> background, chrome.runtime.sendMessage -> popup
// * use BootstrapMessage to get the chrome.storage.local `waving` parameter, and use that as `going`
// * scss, styled components
// * typescript, functional component style

// https://medium.com/@seanlumjy/build-a-chrome-extension-that-injects-css-into-your-favourite-website-9b65f722f409

const WaveReader = styled.div`
  width: 800px;
`;

const settingsService = new SettingsService();
//const selectorService = new SelectorService(settingsService);

const startPageCss = (wave: Wave) => {
    newSyncObject<Options>(Options,'options', Options.getDefaultOptions(), (options) => {
        if (options.showNotifications) {
            const notifOptions = {
                type: "basic",
                iconUrl: "icons/waver48.png",
                title: "wave reader",
                message: "reading",
            };

            // @ts-ignore
            chrome.notifications.create("", notifOptions, guardLastError);
        }
        options.wave = wave.update();
        chrome.runtime.sendMessage(new StartMessage({
            options: options
        }));

        setSyncObject("going", { going: true });
    })
}

const stopPageCss = () => {
    chrome.runtime.sendMessage(new StopMessage());
    setSyncObject("going", { going: false });
}

const bootstrapConditionSettingsSetState = (going: boolean): Promise<Options> => {
    return settingsService.getCurrentSettings().then((options) => {
        return new Promise((resolve) => {
            options = new Options(options);
            setTimeout(() => {
                if (going && options) {
                    options.wave = options.wave.update();
                    chrome.runtime.sendMessage(new StartMessage({
                        options: options
                    }));
                } else if (!going && options) {
                    chrome.runtime.sendMessage(new UpdateWaveMessage({ options }))
                } else {
                    chrome.runtime.sendMessage(new StopMessage())
                }
                resolve(options);
            }, 100);
        });
    });
}
type GoingBox = {
    going: boolean
}
const getGoingChromeStorage = (callback: { (going: boolean): void }) => getSyncObject("going", { going: false }, (result: GoingBox) => callback(result.going));

const getGoingAsync = async (): Promise<boolean> => new Promise((resolve) => getGoingChromeStorage(resolve));

type AppStatesProps = {
    machine: StateMachine,
    settingsService: SettingsService,
    originState: string,
    map: Map<string, State>,
    setState: { (state: string | Named): Promise<State> },
    setGoing: { (going: boolean): void },
    getGoing: { (): boolean },
    _getGoingAsync: { (): Promise<boolean> },
    setOptions: { (options: Options): void },
    bootstrapCondition: { (going: boolean): Promise<Options> },
    onRunTimeInstalledListener: { (callback: {(details: InstalledDetails): void }): void },
    onMessageListener: { (callback: {(message: any): boolean}): void },
    optionsObserver: Observer<Options>,
    getSyncObject_Going: GetSyncObjectFunction<GoingStorageProxy>,
    bootstrapLock: SetReset
}

const chromeRunTimeInstalledListener = (callback: {(details: InstalledDetails): void}) => {
    // maybe direct assignment would be prettier but i'm not sure if ts binds [this] for class method dispatch
    chrome.runtime.onInstalled.addListener(callback);
}

const chromeOnMessageListener = (callback: { (message: any): boolean }) => {
    chrome.runtime.onMessage.addListener(callback);
}

export type GoingStorageProxy = {
    going: boolean
}

export class SetReset {
    private _set: boolean
    private name: string

    private constructor(name: string = "unnamed lock", set: boolean = false) {
        this.name = name;
        this._set = set
    }

    reset() {
        console.log(`set called for ${this.name}`)
        this._set = false;
    }

    set() {
        console.log(`set called for ${this.name}`)
        this._set = true;
    }

    getSet() {
        return this._set;
    }

    static set(name: string) {
        console.log(`created set for ${this.name}`)
        return new SetReset(name, true);
    }
    static unset(name: string) {
        console.log(`created unset for ${this.name}`)
        return new SetReset(name, false);
    }
}

//todo chrome.runtime.onSuspend() handle this method and save state
export const AppStates = ({
  /* eslint-disable: typescript-eslint/no-unused-vars */
    machine = new StateMachine(),
    settingsService,
    originState = "base",
    // setState = async (state): Promise<State> => {
    // todo: we should use state machine observable to support state tracking and auto saving
    // },
    map = new Map<string, State>(),
    setGoing = (going) => { console.error("unset setGoing method in AppStates, goiing: ", going); },
    //getGoing = () => { console.error("unset setGoing method in AppStates"); return false; },
    _getGoingAsync = getGoingAsync,
    //setOptions = (options) => { settingsService?.updateCurrentSettings(_ => options)},
    bootstrapCondition = bootstrapConditionSettingsSetState,
    onRunTimeInstalledListener = chromeRunTimeInstalledListener,
    onMessageListener = chromeOnMessageListener,
    getSyncObject_Going = getSyncObject,
    bootstrapLock = SetReset.unset("bootstrap-lock"),
    setOptions = (options: Options) => {
        throw new Error("unset setOptions method" + JSON.stringify(options))
    }
/* eslint-enable: typescript-eslint/no-unused-vars */
}: Partial<AppStatesProps>): NameAccessMapInterface => {
    /* eslint-disable  @typescript-eslint/no-unused-vars */
    const states: StateNames = {
        "base": CState("base", ["base", "bootstrap", "settings updated"], true, () => {
            return machine?.getState("base")
        }),
        "bootstrap": CState("bootstrap", ["base"], true, async (message, state, previousState): Promise<State> => {
            if (!bootstrapLock.getSet()) {
                const going = (await _getGoingAsync()) || false;
                setGoing(going);
                bootstrapCondition(going).then(options => {
                    machine?.handleState(options.state || machine?.getState(originState) as State).then(state => {
                        settingsService?.updateCurrentSettings(update => {
                            // check sub state? or let it error, and design better???
                            update.state = state;
                            return update;
                        });
                    });
                });
                bootstrapLock.set()
            }

            onRunTimeInstalledListener((details: InstalledDetails) => {
                console.log(`install details: ${details}`);
                // upon first load, get a default value for 'going'
                getSyncObject_Going("going", {going: false}, (result) => {
                    onMessageListener((message: any) => {
                        const typedMessage = fromMessage(message);

                        machine?.handleState(typedMessage);

                        return true;
                    });
                });

            });

            return machine?.getState("base") as State;
        }),
        "update": CState("update", ["base"], true, async (message, state, previousState) => {
            const settingsUpdated = message as UpdateWaveMessage;
            await settingsService?.updateCurrentSettings((options) => {
                // todo: not updating as expected!
                (settingsUpdated.options as Options).wave.selector = settingsUpdated?.options?.wave.selector;
                (settingsUpdated.options as Options).wave.update();
                setOptions(settingsUpdated.options as Options);
                return settingsUpdated.options as Options;
            })
            return previousState
        }),
        // selector selection mode
        "selection mode activate": CState("selection mode activate", ["selection mode active"], true, async (message, state, previousState): Promise<State> => {
            //setSettingsEnabled(false);
            chrome.runtime.sendMessage(new StartSelectorChooseMessage({
                selector: (await settingsService?.getCurrentSettings())?.wave?.selector || SelectorsDefaultFactory()[0]
            }))
            return Promise.resolve(machine?.getState("selection mode active") as State)
        }),
        "selection mode deactivate": CState("selection mode activate", ["selection mode active"], true, async (message, state, previousState): Promise<State> => {
            //setSettingsEnabled(false);
            chrome.runtime.sendMessage(new EndSelectorChooseMessage())
            return Promise.resolve(machine?.getState("selection mode active") as State)
        }),
        "selection mode active": CState("selection mode active", ["selection made", "selection error report", "settings updated"], false, (message, state, previousState) => {
            //  (disable settings tab)
            return machine?.getState("selection mode active")

            // return states.get("selection made (enable settings tab)")
        }),
        "selection made": CState("selection made (enable settings tab)", ["base"], false, (message, state, previousState) => {
            //setSettingsEnabled(true);
            machine?.handleState(new AddSelectorMessage({ selector: (message as SelectionMadeMessage)?.selector}))
            return machine?.getState("base")
        }),
        "selection error report (user error, set red selection error note, revert to previous selector)": CState("selection error report (user error, set red selection error note, revert to previous selector)", ["base"], false, (message, state, previousState) => {
            // todo: maybe this isn't necessary -- it would be neat to have super states so the
            //   dependent state machines could know when not to be active
            return machine?.getState("selection mode active")
        }),
        // selectors!
        "add selector": CState("add selector", ["base"], true, (message, state, previousState) => {
                // selectorUpdated(message)
            settingsService?.updateCurrentSettings((options) => {
                options.wave.selector = (message as SelectorUpdated).selector as string || options.wave.selector;
                options.selectors.push((message as SelectorUpdated).selector as string)
                options.wave.update();
                return options;
            })
            return previousState
        }),
        // remove
        "remove selector": CState("remove selector", ["confirm remove selector", "cancel remove selector"], false, (message, state, previousState) => {
            return machine?.getState("confirm remove selector")
        }),
        "confirm remove selector": CState("confirm remove selector", ["base"], false, (message, state, previousState) => {
            if (window.confirm("Are you sure you wish to remove this selector?")) {
                settingsService?.updateCurrentSettings(options => {
                    const remove = (message as RemoveSelectorMessage).selector || '';
                    options.selectors.splice(options.selectors.indexOf(remove, 0), 1);
                    return options;
                })
            }
            return machine?.getState("base")
        }),
        // use
        "use selector": CState("use selector", ["base"], false, (message, state, previousState) => {
            return machine?.getState("base")
        }),
        // ~~ waves ~~
        "start waving": CState("start waving", ["base"], true, (message, state, previousState) => {
            return machine?.getState("waving")
        }),
        "waving": CState("start waving", ["stop wave", "settings updated"], false, (message, state, previousState) => {
            return machine?.getState("waving")
        }),
        "stop waving": CState("stop waving", ["base"], false, (message, state, previousState) => {
            return machine?.getState("base")
        }),
    };

    Object.keys(states).forEach(state => map.set(state, states[state]))

    return new class implements NameAccessMapInterface {
        getState(name: string): State | undefined {
            return map.get(name);
        }
    }
}

const AppStateMachine = new StateMachine();

const App: FunctionComponent = () => {
    const [ selector, setSelector ] = useState('p');
    const [ saved, setSaved ] = useState(true);
    const [ going, setGoing ] = useState(false);
    const [ options, setOptions ] = useState<Options>(Options.getDefaultOptions());
    const [ domain, setDomain ] = useState<string>("");
    const [ path, setPath ] = useState<string>("");
    const [ selectors, setSelectors ] = useState<string[]>([]);
    const [ selectorModeOn, setSelectorModeOn ] = useState<boolean>(false)

    const appStateMap = AppStates({
        machine: AppStateMachine,
        setGoing: (going) => setGoing(going),
        getGoing: (): boolean => { return going },
        bootstrapCondition: bootstrapConditionSettingsSetState,
        settingsService,
        setOptions
    })

    useEffect(() => {
        AppStateMachine.initialize(appStateMap, appStateMap.getState("bootstrap") as State)

        settingsService.getCurrentDomainAndPaths().then(domainAndPath => {
            setDomain(domainAndPath.domain);
            setPath(domainAndPath.paths[0])
        })

        settingsService.getCurrentSettings().then(settings => {
            setSelectors(settings.selectors);
            setSelector(settings.wave.selector as string);
        })
    }, []);

    // [sm] start add selector
    const selectorClicked = () => {
        setSaved(false);
    };

    const selectorModeClicked = (selectorModeOn: boolean) => {
        setSelectorModeOn(!selectorModeOn)
        if (!selectorModeOn) {
            AppStateMachine.handleState(new SelectionModeActivateMessage())
        } else {
            AppStateMachine.handleState(new SelectionModeDeactivateMessage())
        }
    }

    // [sm] add selector
    const onSaved = async (settings: Options) => {
        setSelector(settings.wave.selector as string);
        setSaved(true);
        // todo what?
        selectorUpdated(new SelectorUpdated({ selector: settings.wave.selector }))
        await AppStateMachine.handleState(new UpdateWaveMessage({
            options: settings
        }))
    };

    // [sm] use selector / add selector
    const selectorUpdated = (message: SelectorUpdated) => {
        // todo what? huH?
        AppStateMachine.handleState(message);
        setSelector(message.selector || 'p');
        setSelectors([...new Set(selectors.concat([message.selector as string]))])
        setSaved(true);
        // todo: call update wave to change the selector animation in content.js
    }
    // [sm] start waving
    const onGo = () => {
        setGoing(true);

        settingsService.updateCurrentSettings((options) => {
            options.going = true;
            setSelectors(options.selectors);
            // use workboots and send message with wave params to interpolate css
            startPageCss(options.wave);
            return options;
        })
    }

    // [sm] stop waving
    const onStop = () => {
        setGoing(false);
        stopPageCss();
    }


    // [sm] settings update / bootstrap
    useEffect(() => {
        // TODO✅: this needs a revision to send a start or update message depending on the state of "going" in google sync
        //          bootstrap condition now sets the state to the last setState or base, and delivers the start stop or update
        //          per "going" which should provide nice backup measures, however we need to store the last message as a State

        //if (configured.mode === "production") {
        if (!isDevelopment) {
            window.onblur = () => {
                window.close();
            }
        }
    }, []);

    const onDomainPathChange = (domain: string, path: string) => {
        setDomain(domain);
        setPath(path);
    }

    return (
        <WaveReader>
            <GoButton onGo={onGo} onStop={onStop} going={going}/>
            <WaveTabs>
                <SelectorInput
                    tab-name={"Selector"}
                    selector={selector}
                    selectors={selectors}
                    saved={saved}
                    selectorClicked={selectorClicked}
                    onSave={async (selector) => selectorUpdated(new SelectorUpdated({ selector }))}
                    selectorModeClicked={selectorModeClicked}
                    selectorModeOn={selectorModeOn}>
                </SelectorInput>
                <Settings
                    tab-name={"Settings"}
                    initialSettings={options}
                    onUpdateSettings={onSaved}
                    domain={domain} path={path}
                    settingsService={settingsService}
                    onDomainPathChange={onDomainPathChange}>
                </Settings>
            </WaveTabs>
        </WaveReader>
    );
};

export default App;

// new wrapper for compose-ability and sanity, recycle new's here: new new new new new new new new new new new new new
export type Named = {
     name: string
}

type StateEffectsFunction = (message: Named, state: State, previousState: State) => Promise<State | undefined>;

export class  State implements Named {
    name: string
    ventureStates: string[]
    isBaseLevel: boolean
    stateEffects: StateEffectsFunction | undefined

    constructor(name = "default",
                ventureStates: string[] = [],
                isBaseLevel = true,
                stateEffects:  StateEffectsFunction | undefined = undefined) {
        this.name = name;
        this.ventureStates = ventureStates;
        this.isBaseLevel = isBaseLevel;
        this.stateEffects = stateEffects; // [{(state: State): State}
    }

    error(opts = undefined) {
        return `${this.name} state ${this.isBaseLevel ? "(base level)" : ""}with sub states ${this.ventureStates.join()} ${(opts ? " " + opts : "")}`;
    }
}

export interface NameAccessMapInterface {
    getState(name: string): State | undefined;
}

export interface StateNames {
    [key: string]: State;
}

export const CState = (name = "default",
                       ventureStates: string[] = [],
                       isBaseLevel = true,
                       stateEffects: StateEffectsFunction | undefined = undefined) => {
    return new State(name, ventureStates, isBaseLevel, stateEffects);
}// from https://stackoverflow.com/a/66291608

export default function getSelector(elem: HTMLElement): string {
    if (elem.tagName === "BODY") return "BODY";
    const names = [];
    while (elem.parentElement && elem.tagName !== "BODY") {
        if (elem.id) {
            names.unshift("#" + elem.getAttribute("id")); // getAttribute, because `elem.id` could also return a child element with name "id"
            break; // Because ID should be unique, no more is needed. Remove the break, if you always want a full path.
        } else {
            let c = 1, e = elem;
            while (e.previousElementSibling) {
                // @ts-ignore
                e = e.previousElementSibling;
                c++;
            }
            names.unshift(elem.tagName + ":nth-child(" + c + ")");
        }
        elem = elem.parentElement;
    }
    return names.join(">");
}
const debounce = ( fn: { (): void }, timeout: number = 500, activateImmediately = false ) => {
    let lastActivate = activateImmediately ? new Date().getTime() : -1;
    // the typeof checks are because it's used from javascript and although we probably would get a type error during runtime, idk /shrug/
    if (activateImmediately && typeof fn === "function") {
        fn(); // fn asap!
    }
    return () => {
        if (new Date().getTime() - lastActivate > timeout) {
            lastActivate = new Date().getTime();
            if (typeof fn === "function") fn();
        } else {
            if (typeof console.trace === "function") console.trace("debounce!");
            else console.log("debounce!");
        }
    }
}

export default debounce;type MousePosition = {
    x: number;
    y: number;
    rotationAmountY: number;
    translationAmountX: number;
}

// from http://www.quirksmode.org/js/events_properties.html#position
/**
 * Use in conjunction with [onMouseMove] with a call to [requestAnimationFrame] enclosing the [mousePos] call.
 * @param rotationAmountDegrees the spread of rotation angle, from perpendicular tangent
 * @param event mouseMove event
 */
/* eslint-disable  @typescript-eslint/no-unused-vars */
export function getMousePos(rotationAmount: number, translationAmount: number, e: any): MousePosition {
    let posx = 0, posy = 0;

    if (!e) e = window.event;
    if (e.pageX || e.pageY) 	{
        posx = e.pageX;
        posy = e.pageY;
    }
    else if (e.clientX || e.clientY) 	{
        posx = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
        posy = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
    }
    const clientWidth = document.body.clientWidth;
    return {
        x: posx, y: posy,
        rotationAmountY: Math.abs(e.clientX - clientWidth / 2) / (clientWidth / 2) * rotationAmount,
        translationAmountX: Math.abs(posx - clientWidth / 2) / (clientWidth / 2) * translationAmount
    }
}

const elementMiddle = (element: Element) => {
    return element.clientTop + (element.clientHeight / 2);
}

type ElementSort = {
    element: Element;
    sort: number;
}

//MIT licensed from https://github.com/codrops/TiltHoverEffects/blob/master/js/main.js
/**
 * Use in conjunction with [onMouseMove] with a call to [requestAnimationFrame] enclosing the [mousePos] call.
 * @param rotationAmountDegrees the spread of rotation angle, from perpendicular tangent
 * @param event mouseMove event
 */
export const mousePos = (rotationAmountDegrees: number, translationAmountX: number, event: any, elements: Element[] = []): MousePosition => {
    const mousepos = getMousePos(rotationAmountDegrees, translationAmountX, event);
    // Document scrolls.
    const docScrolls = {left : document.body.scrollLeft + document.documentElement.scrollLeft, top : document.body.scrollTop + document.documentElement.scrollTop};
        // find the closest element to the current mouse position, and use that for mouse
    const sortedElements: ElementSort[] = elements.map(element => ({ element, sort: Math.abs(docScrolls.top - elementMiddle(element)) }))
        .sort((a, b) => a.sort > b.sort ? 1 : -1);
    const el: Element | undefined = sortedElements.length > 0 ? sortedElements[0].element : undefined;
    const bounds = el?.getBoundingClientRect() || { left: 0, top: 0 };
    const elWidth = el?.clientWidth || 0;
    // Mouse position relative to the main element (this.DOM.el).
    return {
        x : mousepos.x - bounds.left - docScrolls.left,
        y : mousepos.y - bounds.top - docScrolls.top,
        rotationAmountY: Math.abs(mousepos.x - elWidth / 2) / (elWidth / 2) * rotationAmountDegrees,
        translationAmountX: Math.abs(mousepos.x - elWidth / 2) / (elWidth / 2) * translationAmountX
    };
}
import BootstrapMessage from "../models/messages/bootstrap";
import SelectorUpdated from "../models/messages/selector-updated";
import Message from "../models/message";
import StartMessage from "../models/messages/start";
import StopMessage from "../models/messages/stop";
import StartSelectorChooseMessage from "../models/messages/start-selection-choose";
import UpdateSelectorMessage from "../models/messages/update-selector";
import UpdateWaveMessage from "../models/messages/update-wave";
import CancelAddSelectorMessage from "../models/messages/cancel-add-selector";
import EndSelectorChooseMessage from "../models/messages/end-selection-choose";
import RemoveSelectorMessage from "../models/messages/remove-selector";
import SelectionMadeMessage from "../models/messages/selection-made";
import SelectionModeMessage from "../models/messages/selection-mode";
import SelectionModeActivateMessage from "../models/messages/selection-mode-activate";
import SelectionModeDeactivateMessage from "../models/messages/selection-mode-deactivate";
import SelectorUpdatedMessage from "../models/messages/selector-updated";
import StartAddSelectorMessage from "../models/messages/start-add-selector";
import StartMouseMoveMessage from "../models/messages/start-mouse-move";
import StopMouseMoveMessage from "../models/messages/stop-mouse-move";

// todo: separate based on ClientLocation
export const fromMessage = (message: Message<any>) => {
    switch (message.name) {
        case 'add-selector': return message as SelectorUpdated;
        case 'bootstrap': return message as BootstrapMessage;
        case 'cancel-add-selector': return message as CancelAddSelectorMessage;
        case 'end-selection-choose': return message as EndSelectorChooseMessage;
        case 'remove-selection': return message as RemoveSelectorMessage;
        case 'selection-made': return message as SelectionMadeMessage;
        case 'selection-mode': return message as SelectionModeMessage;
        case 'selection-mode-activate': return message as SelectionModeActivateMessage;
        case 'selection-mode-deactivate': return message as SelectionModeDeactivateMessage;
        case 'selector-updated': return message as SelectorUpdatedMessage;
        case 'start': return message as StartMessage;
        case 'start-add-selector': return message as StartAddSelectorMessage;
        case 'start-mouse-move': return message as StartMouseMoveMessage;
        case 'start-selection-choose': return message as StartSelectorChooseMessage;
        case 'stop': return message as StopMessage;
        case 'stop-mouse-move': return message as StopMouseMoveMessage;
        case 'update-selector': return message as UpdateSelectorMessage;
        case 'update-wave': return message as UpdateWaveMessage;

        default: throw new Error(`unknown message type: ${message.name}`)
    }
}
import "core-js/stable";
import "regenerator-runtime/runtime";

// this works, but i think i should look into using observables / rxjs (rxts?)
// also doe not have unsub
export class Deferred<T> {
    value?: T;
    ready: boolean = false;
    subscriptions: { (val?: T, fail?: any): void } [] = [];
    waitForSubscriptions: { (val?: T, fail?: any): void } [] = [];
    accessor: { (): Promise<T> };
    
    constructor(accessor: () => Promise<T>) {
        this.accessor = accessor;
        accessor().then((value: T) => {
            this.value = value;
            this.subscriptions.forEach((sub) => sub(value));
            this.waitForSubscriptions.forEach((sub) => sub(value))
            this.waitForSubscriptions = [];
            this.ready = true;
        }).catch(reason => {
            this.subscriptions.forEach((sub) => sub(undefined, reason));
            this.waitForSubscriptions.forEach((sub) => sub(undefined, reason));
            this.waitForSubscriptions = [];
            this.ready = true;
        });
    }

    subscribe(callback: (val?: T, fail?: any) => void): void {
        // return new Guid();
        this.subscriptions.push(callback);
    }

    async waitFor(): Promise<T | undefined> {
        if (this.ready) {
            return Promise.resolve(this.value);
        }

        return new Promise<T>((resolve, reject) => {
            this.waitForSubscriptions.push((val?: T, error?: any) => {
                if (val !== undefined && !error) {
                    resolve(val);
                } else {
                    reject(error);
                }
            });
        });
    }

    /**
     * Calls the original factory function
     */
    async update(): Promise<T> {
        if (this.ready) {
            this.ready = false;
            this.subscriptions = [];
            this.accessor().then((val: T) => {
                this.value = val;
                this.ready = true;
                this.subscriptions.forEach((sub) => sub(val));
                this.waitForSubscriptions.forEach((sub) => sub(val))
                this.waitForSubscriptions = [];
            }).catch((reason) => {
                this.ready = true;
                this.subscriptions.forEach((sub) => sub(undefined, reason));
                this.waitForSubscriptions.forEach((sub) => sub(undefined, reason));
                this.waitForSubscriptions = [];
            });
        }

        return new Promise<T>((resolve, reject) => {
            const callback = (val?: T, error?: any) => {
                if (val !== undefined && !error) {
                    resolve(val);
                } else {
                    reject(error);
                }
            };

            this.subscriptions.push(callback);
            this.waitForSubscriptions.push(callback);
        });
    }
}// adapted lovingly from: https://dev.to/simonireilly/fetch-with-typescript-for-better-http-api-clients-2d71

import Options from "../models/options";

/** For 200s */
export type UserCreated = { id: string; name: string };
export type SettingsDefault = { settings: Options }
export type UpdateSettings = { settings: Options }

/** For 400s */
export type BadRequest = { code: "bad_request"; message: string };

// create user is mozilla or google oauth via user presence
// https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API/WebAuthn_extensions

/** Response type intersection */
export type UserResponse =
    | (Omit<Response, "json"> & {
    status: 201;
    json: () => UserCreated | PromiseLike<UserCreated>;
})
    | (Omit<Response, "json"> & {
    status: 400;
    json: () => BadRequest | PromiseLike<BadRequest>;
});

export type SettingsResponse =
    | (Omit<Response, "json"> & {
    status: 201;
    json: () => UserCreated | PromiseLike<UserCreated>;
})
    | (Omit<Response, "json"> & {
    status: 400;
    json: () => BadRequest | PromiseLike<BadRequest>;
});

/** Marshalling stream to object with narrowing */
const marshalResponse = (res: UserResponse | SettingsResponse) => {
    if (res.status - (res.status % 100) === 200) return res.json();
    if (res.status - (res.status % 100) === 400) return res.json();
    return Error("Unhandled response code: " + JSON.stringify({ response: JSON.stringify(res), json: res.json() }));
};

/** Coerce Response to UserResponse */
export const responseHandler = (response: Response) => {
    const res = response as UserResponse;
    return marshalResponse(res);
};

/** Usage returns typed data */
// const data = fetch(`https://api.com/v1/user`, {
//     method: "POST",
//     body: JSON.stringify({ name: "Simon" }),
// }).then((res) => responseHandler(res));import { State, Named } from "./state";
import {Base} from "./venture-states";
import Message, {MessageInterface} from "../models/message";
import {FunctionComponent} from "react";

/**
 * hierarchical state machine with message bubbling
 *
 * each component requires a props bundle and a state machine
 *
 * any call up the chain from a sub-state machine must fulfill both
 *
 * A(B) -> a(B, b)
 *
 * app starts -> loads settings, user switches tabs, sets settings
 *
 * SUPER(state: string) requests a state in the higher level state machine change state if possible
 * DONE/UP() declare inactivity, and will make the machine noisier
 *
 * [bootstrap] -> [base]
 * [*] -> [settings updated] -> [*]
 * [switch tabs] -> [settings open] {
 *     [base] // data down
 *     [*] -> [settings changed] -> [unsaved]
 *     [unsaved] -> [save] / [revert] / [discard]
 *     [save] SUPER(settings updated) -> [base] // causes app state machine to switch and close
 *     [*] -> [close] -> SUPER(base) UP()
 *     [*] -> [start edit keybind] {
 *          [base] // data down
 *          [*] -> [start scanning] -> [scanning]
 *          [scanning] -> [save, clear, revert, stop scanning]
 *          [stop scanning] -> [base]
 *          [save] -> SUPER(update keybind, name) UP() -> [base]
 *          [clear] -> [scanning]
 *          [revert] -> [scanning]
 *          [stop scanning] -> UP() -> [base]
 *          [close] -> [close]
 *     }
 * } -> [settings updated] -> [base]
 * [start choose selector mode] -> [selector mode active] (message to content, start selector choose mode) {
 *   // from content.js
 *     [base] // data down
 *     [set selector] -> [unsaved] // user changes the text box
 *     [*] -> [add island selection] -> [unsaved]
 *     [*] -> [remove island selection] -> [unsaved]
 *     [unsaved] -> [save selector]
 *     [save selector] SUPER(settings updated) -> [close]
 *     [revert selector] -> [base]
 *     [*] -> [close] UP() -> [close] // from popup.js, press escape, or press 'x' button in the corner
 * } -> [selector updated] -> [base]
 * [selector updated] -> [base]
 * [switch tab] (ed) -> [education tab] {
 *     [open] -> [open, close]
 *     [close] UP() -> [close]
 *  }
 * [switch tab] (about) -> [about tab] {
 *     // no premium features as this is a reading tool, but donation, newsletter and about link?
 *     [open] -> [open, close]
 *     [close] UP() -> [close]
 * }
 */

/**
 * The above describes states for a hierarchical state machine with asynchronous blocking measures
 * It would be nifty to let the state machine be data driven
 */
const enum MachineClientConnectionStatus {
    SILENT = 1 << 0, // initial state, no messages
    ONLY_SENT = 1 << 1, // has only sent so far
    ONLY_RECEIVED = 1 << 2, // has only received so far
    CONNECTED = 1 << 3, // sent and received
    ERROR = 1 << 4, // in an error state, cannot send, hasn't received for [timeout], or other
    CONNECTED_ERROR = 1 << 5 // connected, but has maintained errors
}

const isConnected = (connection: MachineClientConnectionStatus) => !!(connection & (MachineClientConnectionStatus.CONNECTED | MachineClientConnectionStatus.CONNECTED_ERROR));
const isError = (connection: MachineClientConnectionStatus) => !!(connection & (MachineClientConnectionStatus.ERROR | MachineClientConnectionStatus.CONNECTED_ERROR));
const isBootstrapping = (connection: MachineClientConnectionStatus) => !!(connection & (MachineClientConnectionStatus.SILENT | MachineClientConnectionStatus.ONLY_RECEIVED | MachineClientConnectionStatus.ONLY_SENT))

interface StateMachineClientManagerInterface {
    setState(state: State): void;
    getState(name: string): State;
    addMachine(machine: MachineInterface): void;
    addAllMachines(machines: MachineInterface[]): void;
    getConnection(machine: MachineInterface): void;
}
type StateMachineClientManagerProps = {
    machines: MachineInterface[],
    clients: StateMachineClientManagerInterface[]
}

interface StateMachineClientInterface {
    initialize(props: StateMachineClientProps): void;
    addMachine(machine: MachineInterface, local: boolean): void;
    isLocal(machine: MachineInterface): void;
    getName(): string;
    getState(name: string): State;
    getClientType(): MachineLocation;
}
const enum MachineLocation {
    BACKGROUND, // runs in the background
    CONTENT, // runs on the webpage proper
    POPUP // runs in the popup
}
type StateMachineClientProps = {
    machine: MachineInterface,
    machines: MachineInterface[],
    initialState: State,
    clientManager: StateMachineClientManagerInterface,
    connectionStatus: MachineLocation
}

interface MachineInterface {
    initialize(props: MachineProps, client: StateMachineClientInterface): Promise<StateMachineClientManagerInterface>
    getClient(): StateMachineClientInterface
    getSuperMachine(): MachineInterface;
    getSubMachines(): MachineInterface[];
    getActiveSubMachines(): MachineInterface[];
    setState(state: State): void;
    getState(): State;
    setSuperState(state: State): Promise<[MachineClientConnectionStatus, State]>;
    getName(): string;
    done(): Promise<[MachineClientConnectionStatus, State]>;
    up(): Promise<[MachineClientConnectionStatus, State]>;
}
type MachineProps = {
    superMachine: MachineInterface,
    activeSubMachine: MachineInterface,
    subMachines: MachineInterface[],
    initialState: State,
    errorState: { (e: any): State }
    errors: any[]
}

type StateEventExpectation = boolean;
const BaseLevel: StateEventExpectation = true;
const SubState: StateEventExpectation = false;

type MessageProps = {
    client: StateMachineClientInterface,
    message: MessageInterface
}

type MachineFactoryProps = {
    location: MachineLocation,
    name: string,
    submachines: MachineInterface[]
    component: FunctionComponent
    states: { (client: StateMachineClientManagerInterface, machine: MachineInterface): Partial<State>[] }
    superStates: string[] // the valid effected super states to expect from this machine
    ventureStates: string[] // the valid future states for this machine
}
const Machine = (props: Partial<MachineFactoryProps> = { }): MachineInterface => {
    return null as unknown as MachineInterface;
    // return new class implements MachineInterface {
    //     getActiveSubMachines(): MachineInterface[] {
    //         return [];
    //     }
    //
    //     getClient(): StateMachineClient {
    //         return new class implements StateMachineClientManagerInterface;
    //     }
    //
    //     getName(): string {
    //         return "";
    //     }
    //
    //     getState(): State {
    //         return undefined;
    //     }
    //
    //     getSubMachines(): MachineInterface[] {
    //         return [];
    //     }
    //
    //     getSuperMachine(): MachineInterface {
    //         return undefined;
    //     }
    //
    //     initialize(props: MachineProps, client: StateMachineClient): Promise<StateMachineClientManagerInterface> {
    //         return Promise.resolve(undefined);
    //     }
    //
    //     setState(state: State): void {
    //     }
    //
    //     setSuperState(state: State): Promise<[MachineClientConnectionStatus, State]> {
    //         return Promise.resolve([undefined, undefined]);
    //     }
    //
    // }
}

const machine = Machine({
    location: MachineLocation.POPUP, // or BACKGROUND?
    name: "app",
    component: undefined, // FunctionalComponent<SomethingComponent>
    submachines: [
        Machine({
            location: MachineLocation.POPUP,
            name: "settings",
            states: (client: StateMachineClientManagerInterface, machine: MachineInterface): Partial<State>[] => {
                return [
                    {
                        base: ["base", BaseLevel, () => {}],

                    }
                ] as unknown as Partial<State>[];
            }
        }),
        Machine({
            location: MachineLocation.POPUP,
            name: "education"
        }),
        Machine({
            location: MachineLocation.POPUP,
            name: "about",
            superStates: ["BUNNIES"],
            states: (client: StateMachineClientManagerInterface, machine: MachineInterface): Partial<State>[] => {
                return [
                    {
                        base: [["base"], BaseLevel, () => {}],
                        startDonate: [["donating"], BaseLevel, () => { /* open webpage */ }],
                        donated: [["easterEgg"], SubState],
                        stopDonate: [["base"], SubState, () => {
                            machine.up();
                        }],
                        donating: [["donated", "stopDonate"], SubState],
                        easterEgg: [["base"], SubState, async ({client, message}: MessageProps) => {
                            // show as many bunnies bouncing happily, as pennies donated or something, and unlock konami code
                            const [connectionStatus, state] = await machine.setSuperState(client.getState("BUNNIES"))
                            if (machine.getSuperMachine().getActiveSubMachines().includes(machine)) {
                                machine.up();
                            }
                        }]

                    }
                ] as unknown as Partial<State>[];
            }
        }),
        Machine({
            location: MachineLocation.CONTENT,
            name: "selector-hierarchy-ux",
            states: (client: any, machine: any): Partial<State>[] => {
                return [
                    {
                        base: ["base", true, () => {}],

                    }
                ] as unknown as Partial<State>[];
            }
        }),
        Machine({
            location: MachineLocation.POPUP,
            name: "selector-popup-settings"
        })
    ],
    states: (client: any, machine: any): Partial<State>[] => {
        return [
            {
                base: ["base", true, () => {}],

            }
        ] as unknown as Partial<State>[];
    }
})

type TemplateProps = {}
interface MachineComponent <TProps> { //  <T> implements FunctionalComponent<T>
    getMachine(): MachineInterface;
    render(props: TProps): FunctionComponent<TProps>
    getTemplate(): FunctionComponent<TemplateProps>
}import {State, NameAccessMapInterface, Named} from "./state"
import {Observable, Subscriber} from "rxjs";
import Message, {MessageInterface} from "../models/message";
import MessageSender = chrome.runtime.MessageSender;
import InstalledDetails = chrome.runtime.InstalledDetails;
import {guardLastError} from "./util";
import {fromMessage} from "./messages";
import BootstrapMessage from "../models/messages/bootstrap";
import BootstrapResultMessage from "../models/messages/bootstrap-result";
import HeartbeatResultMessage from "../models/messages/heartbeat-result";
// import {BaseVentures} from "./venture-states";

export class ClientMessage<T extends Message<any>> {
    path: string
    clientId: string
    message: T

    constructor(path: string, clientId: string, message: T) {
        this.path = path;
        this.clientId = clientId;
        this.message = message;
    }
}

export type Success = boolean;
export type ClientID = string

export interface IClientMessengerService<T extends Message<any>> {
    initialize(): Promise<ClientID>
    getRuntimeProxy(): IRuntimeProxy
    getDiscover(): ClientDiscovery
    getApiMap(): Map<string, IClientMessengerService<T>>
    getManager(): ClientID
    getClientMap(): Map<string, ClientHost>
    sendMessage(path: string, clientId: ClientID, message: T): Promise<Success>;
    onReceiveMessage(): Promise<Observable<ClientMessage<T>>>
}

/**
 * Specifies a ClientLocation for the ClientMap
 */
export type ClientHost = string;
type HostType = {
    POPUP: string, // send messages to tabs
    BACKGROUND: string, // receives & sends, as a router
    CONTENT: string,// sends to background
    API: string,// todo: graphql transition
    AUTH: string
}
export const ClientLocation: HostType = {
    POPUP: "popup", // send messages to tabs
    BACKGROUND: "background", // receives & sends, as a router
    CONTENT: "content",// sends to background
    API: "api", // todo: graphql transition
    AUTH: "auth"
}

export type ClientDiscovery = {
    from: string
    to: string
}

class NotImplementedError implements Error {
    message: string;
    name: string;

    constructor(message: string) {
        this.message = message;
        this.name = "not implemented error";
    }
}

export abstract class APIMessage<T> extends Message<T> implements MessageInterface, Named {
    // todo: api message data?
}

/**
 * An api client that facilitates api communication and automated polling
 *
 * todo: implement
 * todo: implement polling
 */
export class APIClientMessengerService<T extends Message<any>, Discovery extends ClientDiscovery> implements IClientMessengerService<T> {
    getDiscover(): ClientDiscovery {
        throw new NotImplementedError("todo: implement api client message service")
    }

    getRuntimeProxy(): IRuntimeProxy {
        throw new NotImplementedError("todo: implement api client message service")
    }

    onReceiveMessage(): Promise<Observable<ClientMessage<T>>> {
        throw new NotImplementedError("todo: implement api client message service")
    }

    sendMessage(path: string, clientId: ClientID, message: T): Promise<Success> {
        throw new NotImplementedError("todo: implement api client message service")
    }
    initialize(): Promise<ClientID> {
        throw new NotImplementedError("todo: implement api client message service")
    }

    getApiMap(): Map<string, IClientMessengerService<T>> {
        throw new NotImplementedError("todo: implement api client message service")
    }


    getClientMap(): Map<string, ClientHost> {
        throw new NotImplementedError("todo: implement api client message service")
    }

    getManager(): ClientID {
        throw new NotImplementedError("todo: implement api client message service")
    }

}

export interface IRuntimeProxy {
    sendMessageToTab(tabId: number, message: any, callback: { (response: any): void }): void;
    sendMessageToRuntime(message: any, callback: { (response: any): void }): void;
    onInstalled(callback: {(details: any): void}): void;
    onMessage(callback: {(message: any, sender: MessageSender, sendResponse: { (response?: any): void }): void }): void;
}

export class GoogleChromeRuntimeProxy implements IRuntimeProxy {
    onInstalled(callback: { (details: any): void }): void {
        chrome.runtime.onInstalled.addListener(callback)
    }

    onMessage(callback: { (message: any, sender: chrome.runtime.MessageSender, sendResponse: { (response?: any): void }): void }): void {
        chrome.runtime.onMessage.addListener(callback);
    }

    sendMessageToRuntime(message: any, callback: { (response: any): void }): void {
        chrome.runtime.sendMessage(message, callback);
    }

    sendMessageToTab(tabId: number, message: any, callback: { (response: any): void }): void {
        chrome.tabs.sendMessage(tabId, message, callback);
    }
}

export class RESTRuntimeProxy implements IRuntimeProxy {
    // if you don't eat, you get weak...
    // thanky kindly :3 https://dev.to/simonireilly/fetch-with-typescript-for-better-http-api-clients-2d71
    onInstalled(callback: { (details: any): void }): void {
        chrome.runtime.onInstalled.addListener(callback)
    }

    onMessage(callback: { (message: any, sender: chrome.runtime.MessageSender, sendResponse: { (response?: any): void }): void }): void {
        chrome.runtime.onMessage.addListener(callback);
    }

    sendMessageToRuntime(message: any, callback: { (response: any): void }): void {
        chrome.runtime.sendMessage(message, callback);
    }

    sendMessageToTab(tabId: number, message: any, callback: { (response: any): void }): void {
        chrome.tabs.sendMessage(tabId, message, callback);
    }
}

/**
 * Unidirectional client service, discover clients from->to, or delegate to API clients
 * Api clients should have typed names
 */
export class GoogleClientMessengerService<T extends Message<any>, Discovery extends ClientDiscovery> implements IClientMessengerService<T> {
    discover: Discovery;
    //todo: this may want to be the extension id for runtime.sendmessage to guaard against spam
    clientId?: ClientID;
    managerId?: ClientID;
    clientMap: Map<ClientID, ClientHost> = new Map<ClientID, ClientHost>()
    observable?: Observable<ClientMessage<T>>
    subscriber?: Subscriber<ClientMessage<T>>
    private apiMap: Map<ClientID, IClientMessengerService<T>>;
    runtimeProxy: IRuntimeProxy;

    constructor(discover: Discovery, apiMap: Map<string, IClientMessengerService<T>>, chromeRuntimeProxy: IRuntimeProxy = new GoogleChromeRuntimeProxy()) {
        this.discover = discover;
        this.apiMap = apiMap;
        this.runtimeProxy = chromeRuntimeProxy;
    }

    getRuntimeProxy(): IRuntimeProxy {
        return this.runtimeProxy;
    }

    getManager(): string {
        throw new Error("Method not implemented.");
    }

    getClientMap(): Map<ClientID, ClientHost> {
        throw new Error("Method not implemented.");
    }

    getApiMap(): Map<ClientID, IClientMessengerService<T>> {
        return this.apiMap;
    }

    getDiscover(): Discovery {
        return this.discover;
    }

    sendMessage(path: string, clientId: ClientID, message: T): Promise<Success> {
        return new Promise((resolve, reject) => {
            if (this.discover.from === this.discover.to) throw new Error("discover is set to a loopback, please use hierarchy, or internal messaging")

            const location = this.clientMap.get(clientId) || this.discover.to.toString();

            // background has two clients, one upstream and one down
            if (location === ClientLocation.POPUP) {
                this.runtimeProxy.sendMessageToRuntime(new ClientMessage(path, clientId, message), (response) => {
                    resolve(response);
                })
            } else if (location === ClientLocation.CONTENT) {
                if (isNaN(Number(clientId))) throw new Error("message to tab with invalid tabId! Not a number, " + clientId + " for message, " + JSON.stringify(message))
                this.runtimeProxy.sendMessageToTab(Number(clientId), new ClientMessage(path, clientId, message), (response) => {
                    resolve(response);
                });
            } else if (location === ClientLocation.API || location === ClientLocation.AUTH) {
                if (this.getApiMap().has(message.getClientId())) {
                    this.getApiMap().get(message.getClientId())?.sendMessage(path, clientId, message).then(resolve).catch(reject);
                } else {
                    throw new Error(`type was ${location}, but unknown clientId for api map in ClientMessengerService from client: ${clientId} for message ${message}`)
                }
            } else if (location === ClientLocation.BACKGROUND) {
                // use sendMessageToRuntime since the background script can be reached that way by both the popup and the tabs.
                if (this.discover.from === ClientLocation.CONTENT) {
                    this.getRuntimeProxy().sendMessageToRuntime(message, resolve);
                }
            }
        })
    }

    onReceiveMessage(): Promise<Observable<ClientMessage<T>>> {
        return new Promise((resolve, reject) => {
        // todo: do we want a retry or timeout?
            let clientReceived = false;
            const backlog: any[] = [];
            const observable = new Observable<ClientMessage<T>>((subscriber) => {
                this.runtimeProxy.onMessage((message: any, sender: MessageSender, response: {(response?: any): void}) => {

                    const { id, frameId } = sender;
                    const typedMessage = fromMessage(message);

                    // @ mr-sekiro salt and hash messages beyond bootstrap?
                    //  optional dev mode disable for debugging
                    // todo: check if cross extension messages pose security hole
                    // use message.from to specify clientId -> clientHost


                    if (typedMessage.name === "bootstrap-result") {
                        const bootstrapResult = typedMessage as BootstrapResultMessage;
                        this.clientId = bootstrapResult.clientId;
                        clientReceived = true;
                        resolve(observable);
                        backlog.forEach(m => subscriber.next(m));
                    } else if (!clientReceived) {
                        backlog.push(message);
                    } else if ("clientId" in message && !!(message as ClientMessage<any>)) {
                        subscriber.next(message);
                    } else {
                        subscriber.next(new ClientMessage<T>(".", typedMessage.from, typedMessage as T))
                    }
                });
            });
        })
    }


    //

    heartbeatMessage(heartbeat: HeartbeatResultMessage) {
        // todo: update client map
        // todo: similar to bootstrap send back whatever info in response, just no additional messaging
        console.error("### straw ###")
        if (this.apiMap.size !== heartbeat.apiMap?.size) {
            [...(heartbeat.apiMap?.entries() || [])].forEach(([key, val]) => {
                if (!this.clientMap.has(key)) this.clientMap.set(key, val);
            })

            this.runtimeProxy.sendMessageToRuntime(new BootstrapMessage(), (response) => {
                if (response as HeartbeatResultMessage) {
                    this.heartbeatMessage((response as HeartbeatResultMessage)!)
                }
            })
        }
    }

    bootstrapMessages(): Promise<void> {
        // todo: implement: send up, then once complete, await id message
        throw new NotImplementedError("not yet implemented!")
        if (this.discover.from !== ClientLocation.CONTENT) {
            // todo: accept client id here from message,
            //  saturate api map if found
            this.clientId = this.discover.from;
            return Promise.resolve();
        }
        // send up
        return new Promise((resolve, reject) => {
            // todo: using what info is available, extension id, etc, send info back to requested
            this.runtimeProxy.sendMessageToRuntime(new BootstrapMessage(), (response) => {
                if (response as HeartbeatResultMessage) {
                    this.heartbeatMessage((response as HeartbeatResultMessage)!)
                }
                resolve();
            })
        })
    }

    initialize(): Promise<ClientID> {
        return new Promise((resolve, reject) => {
            this.bootstrapMessages().then(this.onReceiveMessage);
        })
    }

    private getClientId() {
        if (!this.clientId) console.log("GoogleMessengerCLient#getClientId called with a null clientid! bootstrap failed!")
        return this.clientId || "no-id"
    }
}

export class FirefoxSyncClientMessengerService<T extends Message<any>> implements IClientMessengerService<T> {
    sendMessage(clientId: ClientID, message: any): Promise<boolean> {
        throw new Error("TODO: implement firefox!.");
    }

    initialize(): Promise<ClientID> {
        throw new Error("TODO: implement firefox!.");
    }

    getApiMap(): Map<string, IClientMessengerService<T>> {
        throw new Error("TODO: implement firefox!.");
    }

    getClientMap(): Map<string, ClientHost> {
        throw new Error("TODO: implement firefox!.");
    }

    getDiscover(): ClientDiscovery {
        throw new Error("TODO: implement firefox!.");
    }

    getManager(): ClientID {
        throw new Error("TODO: implement firefox!.");
    }

    getRuntimeProxy(): IRuntimeProxy {
        throw new Error("TODO: implement firefox!.");
    }

    onReceiveMessage(): Promise<Observable<ClientMessage<T>>> {
        throw new Error("TODO: implement firefox!.");
    }

}

export interface IClient<T extends Message<any>> {
    initialize(): Promise<Success>;
    sendMessage(message: ClientMessage<T>): Promise<Success | State>;
    getMessageReceivedObservable(): Observable<ClientMessage<T>>;
    getStateMachines(): Map<string, StateMachine>
}

const ContentToPopupDiscovery = {
    from: ClientLocation.CONTENT,
    to: ClientLocation.POPUP
} as ClientDiscovery;

const PopupToContentDiscovery = {
    from: ClientLocation.POPUP,
    to: ClientLocation.CONTENT
} as ClientDiscovery;

const PopupToBackgroundDiscovery = {
    from: ClientLocation.POPUP,
    to: ClientLocation.BACKGROUND
} as ClientDiscovery;

const BackgroundToPopupDiscovery = {
    from: ClientLocation.BACKGROUND,
    to: ClientLocation.POPUP
} as ClientDiscovery;

const PopupToAPIDiscovery = {
    from: ClientLocation.POPUP,
    to: ClientLocation.API
} as ClientDiscovery;

const ContentToAPIDiscovery = {
    from: ClientLocation.CONTENT,
    to: ClientLocation.API
} as ClientDiscovery;

// for the time being we'd like the api access to primarily live on the background.js thread
const BackgroundToAPIDiscovery = {
    from: ClientLocation.BACKGROUND,
    to: ClientLocation.API
} as ClientDiscovery;

export class Client<T extends Message<any>> implements IClient<T> {
    messengerClient: IClientMessengerService<T>
    private clientId: ClientID | undefined = undefined;
    private observer?: Observable<ClientMessage<T>>

    private stateMachineMap = new Map<string, StateMachine>();

    constructor(messengerClient: IClientMessengerService<T> =
                    new GoogleClientMessengerService<T, ClientDiscovery>(
                        PopupToContentDiscovery,
                        new Map<ClientID, IClientMessengerService<T>>()
                    ),
                stateMachineMap?: Map<string, StateMachine>
    ) {
        this.messengerClient = messengerClient;
        if (stateMachineMap) {
            [...stateMachineMap.entries()].forEach(p => this.stateMachineMap.set(p[0], p[1]))
        }
    }

    getMessageReceivedObservable(): Observable<ClientMessage<T>> {
        if (!this.observer) {
            throw new Error("please initialize client before accessing message observer")
        }
        return this.observer;
    }
    getStateMachines(): Map<string, StateMachine> {
        return this.stateMachineMap
    }

    initialize(): Promise<Success> {
        return new Promise(async (resolve, reject) => {
             this.messengerClient.initialize().then(async (id) => {
                 this.clientId = id;
                 this.observer = await this.onReceiveMessage(this.clientId)
                 this.observer.subscribe((message) => {
                     this.sendMessage(message).catch(e => {
                        console.log("failed to process state or message: " + JSON.stringify(message));
                     });
                 })
                 resolve(true)
             }).catch(error => {
                 console.log(new Error(`error receiving message for client ${this.clientId}: ${error.message}`, error));
                 resolve(false)
             })
        })
    }

    sendMessage(message: ClientMessage<T>): Promise<Success | State> {

        // send a message to the specific client, then descend the state machines
        //  finding the appropriate machine starting at the root (usually "content" or "popup")
        //  once descended, we deliver the message
        // path examples:
        //  * 'app#settings' 'extensionid321' 'save' { ... data }
        //  * 'background/api#ga' 'ga' 'page' { ... data }
        //  * 'content#wave' 'tab123' 'start' { ... data }
        const clients = message.path.split('/')
        const machines = message.path.split('#')
        const machine = machines[machines.length - 1];

        if (machines.length > 1) {
            console.log("machines " + machines.slice(1).join(', '))
        }
        const client = clients[0];
        // given the message.from & the host location, send to the next hope, or pizza down to the next message

        return new Promise((resolve, reject) => {
            if (client === this.clientId) {
                if (!this.stateMachineMap.has(machine)) {
                    throw new Error(`statemachine missing from client, ${client} for machine, ${machine}`)
                }

                // message sent!
                this.stateMachineMap.get(machine)?.handleState(message.message).then((p) => resolve(p || false)).catch(reject)
            } else {
                // otherwise, we use the from and client to send appropriately
                const newPath = (clients.length > 1 ? clients.slice(1) : clients).join('/');

                // the graph here isn't very big, you're either on a client, and sending a message to another part of the client
                // or on the correct client and sending a message to an api client
                // so if you're message is from the popup sending to background, then
                if (this.messengerClient.getApiMap().has(client)) {
                    this.messengerClient.getApiMap().get(client)?.sendMessage(newPath, message.clientId, message.message).then(p => resolve(p || false)).catch(reject)
                } else {
                    this.messengerClient.sendMessage(newPath, message.clientId, message.message).then(p => resolve(p || false)).catch(reject);
                }
            }
        });
    }

    private onReceiveMessage(clientId: string): Promise<Observable<ClientMessage<T>>> {
        if (this.clientId === clientId) {
            return this.messengerClient.onReceiveMessage()
        }
        if (this.messengerClient.getClientMap().has(clientId)) {
            if (!this.messengerClient.getApiMap().has(this.messengerClient.getClientMap().get(clientId)!)) {
                throw new Error(`clientId: ${clientId} has no corresponding API mappings on this host ${this.clientId}`)
            }
            return this.messengerClient.getApiMap().get(this.messengerClient.getClientMap().get(clientId)!)!.onReceiveMessage()
        } else {
            throw new Error(`clientId: ${clientId} not found`)
        }
    }
}


const createBackgroundToPopupClientMessengerService = <T extends Message<T>>() => new GoogleClientMessengerService<T, ClientDiscovery>(
    BackgroundToPopupDiscovery,
    new Map<ClientID, IClientMessengerService<T>>()
);

const createPopupToBackgroundClientMessengerService = <T extends Message<T>>() => new GoogleClientMessengerService<T, ClientDiscovery>(
    PopupToContentDiscovery,
    new Map<ClientID, IClientMessengerService<T>>()
);

const createContentToPopupClientMessengerService = <T extends Message<T>>() => new GoogleClientMessengerService<T, ClientDiscovery>(
    ContentToPopupDiscovery,
    new Map<ClientID, IClientMessengerService<T>>()
);

const createPopupToContentClientMessengerService = <T extends Message<T>>() => new GoogleClientMessengerService<T, ClientDiscovery>(
    PopupToContentDiscovery,
    new Map<ClientID, IClientMessengerService<T>>()
);

class StateMachine {
    initialized: boolean = false;
    map: NameAccessMapInterface | undefined = undefined;
    currentState: State | undefined = undefined;
    // todo: review, this may be a useful feature, i almost didn't yagni this in a test (which sounds weird)
    private stateObservable?: Observable<State | undefined>
    private stateSubscriber?: Subscriber<State | undefined>;

    constructor() {
    }

    // todo: for client manager, add the ability to pass the active node etc
    //   look into graphql propegation apis?
    /**
     * @remarks Please note, the stateObservable does not report the originState
     * @param stateMachineMap [NameAccessMapInterface] a map of state-machine states by name
     * @param originState [State] a starting state (often "base")
     */
    initialize(stateMachineMap: NameAccessMapInterface, originState: State) {
        // TODO: guard for env?
        if (this.map !== undefined) console.log("initialize called with predefined map outside of test conditions: " + JSON.stringify(this.map));
        if (this.currentState !== undefined) console.log("initialize called with predefined currentState outside of test conditions: " + JSON.stringify(this.currentState));
        this.map = stateMachineMap;
        this.currentState = originState;
        if (this.map !== undefined && this.currentState !== undefined) this.initialized = true;

        const setStateSubscriber = (stateSubscriber: Subscriber<State | undefined>) => this.stateSubscriber = stateSubscriber;
        this.stateObservable = new Observable<State | undefined>((subscriber) => {
            setStateSubscriber(subscriber)
        });
    }

    getObservable(): Observable<State | undefined> | null {
        return this.stateObservable || null;
    }

    getBaseState(): State | undefined {
        return this.map?.getState("base");
    }

    getErrorState(): State | undefined {
        return this.map?.getState("error");
    }

    protected validateState(newState: Named): State | undefined {
        if (!this.initialized) throw new Error("not initialized, no StateMachineMap")

        const state = this.map?.getState(newState.name);

        if (!state || (!state?.isBaseLevel && !this.currentState?.ventureStates.includes(newState.name))) {
            console.error(
                this.currentState?.error(),
                newState?.name
            );
            return this.getErrorState();
        }

        return this.getState(newState.name)
    }

    protected async processState(message: Named, state: State | undefined, previousState: State): Promise<State | undefined> {
        if (!this.initialized) throw new Error("not initialized, no StateMachineMap")
        if (state === undefined) console.log("State undefined for previous state" + JSON.stringify(previousState))

        this.stateSubscriber?.next(state);

        // important note here, we put the state machine into the state returned by stateEffects lambda but don't call
        //   the associated stateEffects - this is a free form way to handle the transition problem,
        //   but we don't enforce transitions either which may cause some unexpected hitches
        //   base -> start -> waving -> end selection choose (bam! error (:=0))
        //   we can liberally use venture states to handle this - cli tools would be cool & yagnilishious
        if (typeof state?.stateEffects === 'function') {
            this.currentState = await state.stateEffects(message, state, previousState) || this.getBaseState();
            if (this.currentState?.name === "base") {
                console.log("transitioning back to base");
            }
        } else {
            console.log(`no stateEffects defined for ${state?.name}, transitioning back to base`)
            this.currentState = this.getBaseState();
        }

        this.stateSubscriber?.next(this.currentState);
        return this.currentState;
    }

    processing = false;
    queue: Named[] = [];

    /**
     * Validates and processes the message, returning the state due to the [State#stateeffects()] or BaseState
     * @param namedState the message from chrome.runtime to be passed through to the [State#stateeffects()]
     * @return the BaseState or state from [State#stateeffects()]
     */
    async handleState(namedState: Named): Promise<State | undefined> {
        if (!this.initialized) throw new Error("not initialized, no StateMachineMap")

        const state = this.validateState(namedState)
        /* eslint-disable  @typescript-eslint/no-extra-non-null-assertion */
        return this.processState(namedState, state, this.currentState!!)!!;
        if (this.processing) {
            this.queue.unshift(namedState)
            let returnState = undefined;
            await this.stateObservable?.forEach(state => returnState = state)
            return Promise.resolve(returnState);
        } else {
            // loop through available states, processing any state that does not return as "base"
            let state: State | undefined;
            while (this.queue.length) {
                state = this.validateState(this.queue.pop()!!);

                state = await this.processState(namedState, state, this.currentState!!);
                if (state?.name !== "base") {
                    this.queue.unshift(state as Named)
                }
            }
            try {
                return state ? Promise.resolve(state) : Promise.reject(state);
            }
            finally {
                this.processing = false;
            }
        }
    }

    getState(name: string): State | undefined {
        if (!this.initialized) throw new Error("not initialized, no StateMachineMap")

        return this.map?.getState(name);
    }

    getCurrentState(): State | undefined {
        return this.currentState;
    }
}

export default StateMachine;

export interface AttributeAccessor {
    [key: string]: any;
}

export default abstract class AttributeConstructor<T> {

    protected constructor(attributes?: AttributeAccessor & Partial<T>, requireAllAssigned: boolean = false) {
        this.assign(attributes, requireAllAssigned)
    }

    protected assign(attributes?: AttributeAccessor & Partial<T>, requireAllAssigned: boolean = false) {
        if (attributes) {
            if (requireAllAssigned && !new Array(...Object.keys(attributes)).every(k => attributes[k] !== undefined)) {
                throw new Error('if [requireAllAssigned == true], a message must contain properties with no undefined values!')
            }
            Object.assign(this, attributes)
        }
    }
}
/**
 *
 * @returns {boolean} true if lastError
 */

export const guardLastError = () => {
    if (chrome.runtime.lastError) {
        console.log(chrome.runtime.lastError);
        console.log(new Error().stack);
        return chrome.runtime.lastError;
    }

    return false;
}

export type Tab = chrome.tabs.Tab;

export const currentTab = (): Promise<Tab[]> => {
    return new Promise<Tab[]>((resolve, reject) => {
        chrome.tabs.query({active: true, currentWindow: true}).then((tabs) => {
            resolve(tabs);
        }).catch(e => {
            console.log('error getting current tab: ', e);
            reject(e);
        });
    });
}

/**
 * A Promise proxy function
 *
 * e.x. p((r) => r(true)).then(() => {
 *   console.log('sugar')
 * })
 * @param promiseFn a promise function body
 * @returns {Promise<unknown>} another promise or a value wrapped in resolve promise
 */
type PromiseFunction<T> = (resolve: (value: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void;
/* eslint-disable  @typescript-eslint/no-unused-vars */
const p = <T> (promiseFn: PromiseFunction<T> = (resolve = () => {}, reject = (reason?: string) => {}) => { }) => {
    return new Promise(promiseFn);
};

export default p;

export type SizeValue = {
    size: string,
    sizeType?: string
}
export const getSizeValuesRegex = (sizeValue: string): SizeValue => {
    const regex = new RegExp("([0-9]+)([a-zA-Z]+|%)", "ig");

    const result = regex.exec(sizeValue)
    if (!result) return {
        size: "0",
        sizeType: undefined
    };

    const [s, value, valueType, ...rest] = [...result.values()];

    return {
        size: value,
        sizeType: valueType
    } as unknown as SizeValue
}

const windowDefault: any | undefined = (typeof window !== 'undefined' && window) || undefined
export const getDefaultFontSizeREM = (_window: any | undefined = windowDefault) => _window.getComputedStyle(_window.document.documentElement).getPropertyValue('font-size')

// credit: @marc_s https://stackoverflow.com/q/66070706
export const isVisible = (element: HTMLElement) => {
    if (element instanceof Text) return true;
    if (element instanceof Comment) return false;
    if (!(element instanceof Element)) throw Error("isVisible(): argument is not an element");

    // for real elements, the second argument is omitted (or null)
    // for pseudo-elements, the second argument is a string specifying the pseudo-element to match.
    const style = window.getComputedStyle(element, null);

    // if element has size 0
    if(element.offsetWidth === 0 || element.offsetHeight === 0){
        // only on 'visible', content does appear outside of the element's box
        if (style.overflow !== 'visible') {
            return false;
        } else {
            for (const child of element.childNodes) {
                if (isVisible(child as HTMLElement)) return true;
            }
            return false;
        }
    }

    // if css display property is used
    if (style.display === 'none') return false;

    // if css visibility property is used
    if (style.visibility !== 'visible') return false;

    // if css opacity property is used
    if (parseFloat(style.opacity) === 0) return false;

    // this method does not work for elements with "position: fixed;"
    if (style.position !== 'fixed') {
        if (element.offsetParent === null) return false;
    }

    return true;
}import {State} from "./state";

export const BaseVentures: string[] = ["base", "error"]
// if a promised resolved state is a future, then a potential state maybe nicely referred to as a venture?
export const StartVentures: string[] = ["waving"];
export const StopVentures: string[] = ["start", "update", "toggle start", "start mouse"];
export const WavingVentures: string[] = ["stop", "toggle stop", "update", "stop mouse", "start"]; // todo: review: we get ignored stop messages or immediate toggles, and we aren't able to stop if start isn't allowed in waving as i think the popup and the content script get desynced
export const AllVentures: string[] = ["start", "stop", "update", "toggle stop", "toggle start", "stop mouse", "start mouse", "selection mode activate", "selection made", "selection mode deactivate"]

export const Base: State = new State("base", [...StopVentures, "selection mode activate"], true);
import StateMachine, {Client} from "./state-machine";
import React, {Dispatch, FunctionComponent, ReactElement, SetStateAction, useEffect, useState} from "react";
import Message from "../models/message";
import {CState, NameAccessMapInterface, Named, State} from "./state";

export type MachineComponentProps = {
    state: UseStateProxy<any>
    machine: StateMachine
    previousState: string
}
export type MachineComponent = ReactElement<any, any> | null & {
}

/**
 * Return to assert the current [MachineComponent]'s as the current view without affecting the view
 */
export type View = {}
export const _View_ = {} as unknown as View;

/**
 * Return to empty the current [views.views], maintaining the previous states (tm)
 */
export type ClearViews = {}
export const _ClearViews_ = {} as unknown as ClearViews;

/**
 * Return to empty [view.states] & [view.views]
 */
export type Clean = {}
export const _Clean_ = {} as unknown as Clean;

export type ComponentLog = {
    state: string,
    /**
     * The [MachineComponent] to log and contribute to building the presented view, returned by the ComponentState functions,
     */
    view?: MachineComponent | View | ClearViews | Clean
}

export type ComponentLogView = {
    states: string[]
    state: string
    views: MachineComponent[]
}

export const log = (state: string, view?: MachineComponent | View | ClearViews | Clean) => {
    return {
        state,
        view
    } as unknown as ComponentLog
}
export const view = (state: string, states: string[], ...views: MachineComponent[]) => {
    return {
        state,
        states,
        views
    } as unknown as ComponentLogView
}

export type StateComponentFunction = { ({state, machine}: Partial<MachineComponentProps>): Promise<ComponentLog> }
export type ReactStateMachineProps<TProps> = {
    initialState: string | Named,
    states: { [key: string]: StateComponentFunction },
    client: Client<Message<any>>,
    errorState?: State
}

export type ReactStateMachineConstructorProps<TProps> = ReactStateMachineProps<TProps> & {
    props: TProps
}

export type useStateFunction<S> = { (initialState: S | (() => S)): [S, Dispatch<SetStateAction<S>>] }

export class UseStateProxy<TProps extends any | object> {
    useStateFn?: useStateFunction<any>
    useStates: Map<string, SetStateAction<any>> = new Map<string, React.SetStateAction<any>>()
    stateValues: Map<string, any> = new Map<string, any>()
    props: TProps

    constructor(props: TProps, useStateFn?: useStateFunction<any>) {
        this.useStateFn = useStateFn
        this.props = props
    }

    setUseState(useStateFn: useStateFunction<any>) {
        this.useStateFn = useStateFn
    }
    useState<S>(name: string, initialState: S | (() => S)): [S, Dispatch<SetStateAction<S>>] {
        const [state, setState] = this.useStateFn!(initialState)
        // todo: review: should an optional , "overwrite" ?
        return [state, ((value: S): void => {
            this.stateValues.set(name, value)
            setState(value);
        }) as Dispatch<SetStateAction<S>>]
    }
    getState<T>(name: string): T {
        return this.stateValues.get(name) as T;
    }
}

type whatever = null | undefined

export type ReactStateMachineComponentProps = {
    useState: useStateFunction<any>
    setState: { (state: string, value: any): void }
}

export class ReactStateMachine<TProps> {
    private states: { [key: string]: StateComponentFunction };
    private renderTarget?: React.ReactElement<any, any> | null;
    private stateMachine: StateMachine = new StateMachine()
    private logView: ComponentLogView = {
        state: "base",
        views: [],
        states: ["base"]
    }
    private state: UseStateProxy<TProps>;
    private errorView: string[] = [];
    private ErrorStateFunction = (): ComponentLog => {
        return log("base", <ul>{this.errorView.map(e => <li>{e}</li>)}</ul>);
    }

    private ErrorState = new State("error", ["error", "base"], true, (async (message, state, previousState): Promise<State> => {
        const log = this.ErrorStateFunction()
        if (log.view) this.logView.views.push(log.view as MachineComponent)
        this.logView.states.push(log.state)
        return this.stateMachine.getState((await log).state) || this.ErrorState
    }))

    private errorState = this.ErrorState;
    private initialState: string | Named;

    private toState(name: string, isBaseLevel: boolean, ventureStates: string[], componentFunction: StateComponentFunction) {
        return new State(name, ventureStates, isBaseLevel, (async (message, state, previousState): Promise<State> => {
            const log: ComponentLog = await componentFunction({

            } as Partial<MachineComponentProps>)
            if (log.view) this.logView.views.push(log.view as MachineComponent)
            this.logView.states.push(log.state)
            return this.stateMachine.getState((await log).state) || this.ErrorState
        }))
    }

    constructor({
                    states,
                    errorState,
                    props,
                    initialState
                }: ReactStateMachineConstructorProps<TProps>) {
        this.states = states;
        this.errorState = errorState || this.ErrorState;
        this.state = new UseStateProxy<TProps>(props);
        this.initialState = initialState;
    }

    initialize() {
        const machine = this;
        const map = new Map<string, State>();

        this.logView.state = typeof this.initialState === "string" ? this.initialState : (this.initialState as Named)?.name || "base";
        if (!(this.logView.state in this.states)) {
            machine.errorView.push("cannot find initialState " + machine.logView.state + " in states map!")
        }

        Object.keys(this.states).forEach(key => {
            map.set(key, CState(key, [], true,
                async (message, state, previousState): Promise<State | undefined> => {
                const result: ComponentLog = await this.states[key](
                    {
                        machine: this,
                        state: this.state,
                        previousState: previousState
                    } as unknown as MachineComponentProps)

                // this feels a little squirrelly, but i'd rather log what we consider effecting here, as the state mutex
                // especially since we observe deterministically
                this.logView.states.push(this.logView.state)
                this.logView.state = result.state

                // on the upside, optional types & type unions give us a neat little pattern matching pattern!
                const matchComponent = (view?: MachineComponent): Promise<State> | State | undefined => {
                    if (view) this.logView.views.push(view);
                    else return undefined;

                    return Promise.resolve(map.get(result.state)!)
                }

                const matchView = (view?: View): Promise<State> | State | undefined => {
                    if (!view) return undefined;

                    return Promise.resolve(map.get(result.state)!)
                }

                const matchClearViews = (view?: ClearViews): Promise<State> | State | undefined => {
                    if (!view) return undefined;

                    this.logView.views = [];

                    return Promise.resolve(map.get(result.state)!)
                }


                const matchClean = (view?: ClearViews): Promise<State> | State | undefined => {
                    if (!view) return undefined;

                    this.logView.views = [];
                    this.logView.states = [];

                    return Promise.resolve(map.get(result.state)!)
                }

                return matchComponent(result.view as MachineComponent) ||
                        matchView(result.view as View) ||
                        matchClearViews(result.view as ClearViews) ||
                        matchClean(result.view as Clean);
            }))
        })

        this.stateMachine.initialize(new class implements NameAccessMapInterface {
            getState(name: string): State | undefined {
                return map.get(name);
            }
        }, map.get(this.logView.state) || this.ErrorState)

        this.renderTarget = ReactStateMachineRenderTarget({
            useStateProxy: this.state,
            logView: this.logView,
            stateMachine: this.stateMachine
        })
    }

    handleMessage(message: Named) {
        this.stateMachine.handleState(message);
    }

    getStateMachine(): StateMachine {
        return this.stateMachine;
    }

    getLogView(): ComponentLogView {
        return this.logView;
    }

    getRenderTarget(): ReactElement<any, any> | whatever {
        return this.renderTarget;
    }
}


export type ReactStateMachineRenderTargetProps<TProps> = {
    useStateProxy: UseStateProxy<TProps>,
    logView: ComponentLogView,
    stateMachine: StateMachine,
    context?: React.Context<StateMachine>
}

export const ReactStateMachineRenderTarget: FunctionComponent<ReactStateMachineRenderTargetProps<any>> = ({
        useStateProxy,
        logView,
        stateMachine,
        context= React.createContext(stateMachine)
    }): ReactElement<any, any> | null => {

    const [rerender, setRerender] = useState(5);

    useEffect(() => {
        useStateProxy.setUseState(useState)

        // todo: review: we may want to subscribe from the componentMachine
        stateMachine.getObservable()?.subscribe(() => {
            setRerender(rerender + 1);
        })
    }, [])


    useEffect(() => {
        if (rerender >= 100) {
            setRerender(1);
        }
    }, [rerender])

    return (<context.Provider value={stateMachine}>
        {logView.views.map((view, i) => <view key={i} />)}
    </context.Provider>);
}

export type ReactMachineFunction<TProps = {}> = { (props: TProps): ReactStateMachine<TProps> };
// const declaration definition didn't work for generics... :( weird :(
export function ReactMachine<TProps>(machineProps: ReactStateMachineProps<TProps>): ReactMachineFunction<TProps> {
    return (props: TProps) => new ReactStateMachine<TProps>({ props, ...machineProps } as unknown as ReactStateMachineConstructorProps<TProps>)
}
import AttributeConstructor, {AttributeAccessor} from "./attribute-constructor";

export type GetSyncObjectFunction<T extends object> = (key: string, defaultValue: T, callback: (result: T) => void) => void;
export const getSyncObject = <T extends object>(key: string, defaultValue: T, callback: (result: T) => void) => {
    chrome.storage.sync.get(key, ( (items: { [key: string]: any }) => {
        if (key in items) {
            try {
                callback(JSON.parse(items[key]))
            } catch (e) {
                console.log(e);
                callback(defaultValue)
            }
        } else {
            callback(defaultValue)
        }
    }));
}
// ??
export const newSyncObject = <T extends AttributeConstructor<T>>(objectType: { new(attributes?: AttributeAccessor & Partial<T>, requireAllAssigned?: boolean): T },
                                                                 key: string, defaultValue: T, callback: (result: T) => void) => {
    chrome.storage.sync.get(key, ( (items: { [key: string]: any }) => {
        if (key in items) {
            try {
                callback(new objectType(JSON.parse(items[key])))
            } catch (e) {
                console.log(e);
                callback(defaultValue)
            }
        } else {
            callback(defaultValue)
        }
    }));
}

export const setSyncObject = (key: string, value: object, callback: () => void = () => {}) => {
    chrome.storage.sync.set({ [key]: JSON.stringify(value) }, callback);
}

export default {
    getSyncObject,
    setSyncObject
}
export default {
    mode: 'develop'
}export default {
    mode: 'production'
}//todo: implement: single configuration for delivery targets configured via configuration (webpack a plus)
import {
    Client,
    ClientDiscovery,
    ClientLocation, GoogleChromeRuntimeProxy,
    GoogleClientMessengerService,
    IClientMessengerService
} from "../util/state-machine";
import Message from "../models/message";

export type ClientDiscoveryConfig = {
    up: { (): Client<any> }
    down: { (): Client<any> }
}

export type AuthClientConfig = {
    chrome: { (): Client<any> }
    firefox: { (): Client<any> }
}

export type RobotCopyConfig = {
    clients: { [key: string]: ClientDiscoveryConfig | AuthClientConfig }
}

const clientCacheMap = new Map<string, Client<any>>()

const cacheClientConfig = (name: string, discover: ClientDiscovery | AuthClientConfig) => {
    if (!clientCacheMap.has(name)) {
        clientCacheMap.set(name, new Client<Message<any>>(new GoogleClientMessengerService(
            discover as ClientDiscovery,
            new Map<string, IClientMessengerService<Message<any>>>(),
            new GoogleChromeRuntimeProxy())))
    }
    return clientCacheMap.get(name)!
}

const CopyConfig: RobotCopyConfig = {
    "clients": {
        "popup": {
            up: () => {
                return cacheClientConfig("popup", {
                    from: ClientLocation.POPUP,
                    to: ClientLocation.CONTENT
                })
            },
            down: () => {
                return cacheClientConfig("popup", {
                    from: ClientLocation.POPUP,
                    to: ClientLocation.CONTENT
                })
            }
        },
        "background": {
            up: () => {
                return cacheClientConfig("background", {
                    from: ClientLocation.BACKGROUND,
                    to: ClientLocation.POPUP
                })
            },
            down: () => {
                return cacheClientConfig("background", {
                    from: ClientLocation.POPUP,
                    to: ClientLocation.BACKGROUND
                })
            }
        },
        "content": {
            up: () => {
                return cacheClientConfig("content", {
                    from: ClientLocation.CONTENT,
                    to: ClientLocation.BACKGROUND
                })

            },
            down: () => {
                // maybe YAGNI? i was thinking client side loop back, we'll see
                return cacheClientConfig("content", {
                    from: ClientLocation.BACKGROUND,
                    to: ClientLocation.CONTENT
                })
            }
        },
        "identity": {
            chrome: () => {
                // todo: implement: https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API/WebAuthn_extensions
                throw new Error("implement identity client for login and user presence")
            },
            firefox: () => {
                throw new Error("implement identity client for login and user presence")
            }
        },
        "api": {
            up: () => {
                // todo: implement: up meaning to the API
                throw new Error("implement api client for REST API communication")
            },
            down: () => {
                // todo: implement: down meaning to background.js usually
                throw new Error("implement api client from REST API communication")
            }
        }
    }
}

export default CopyConfig;

export const clientForLocation = (location: string): ClientDiscoveryConfig | AuthClientConfig => {
    if (!(location in CopyConfig.clients)) throw new Error("location" + location + " not in copyConfig!");

    return CopyConfig.clients[location]
}/* globals config */

type Config = {
    mode: string;
}

const unset: Config = { mode: "unset" };

// @ts-ignore
const configured: Config = typeof config === "object" ? global.config?.default || unset : unset;
if (configured.mode === "unset") {
    console.log("unset configuration mode! " + JSON.stringify(configured));
}

export default configured;
export default {
    mode: 'common'
}import Wave from "../wave";
import Message from "../message";

export default class StopMouseMoveMessage extends Message<StopMouseMoveMessage> {
    wave?: Wave;

    constructor(attributes: Partial<StopMouseMoveMessage> = {}) {
        super('stop-mouse-move', 'popup', attributes)
    }
}import Message from "../message";

export default class SelectionMadeMessage extends Message<SelectionMadeMessage> {
    selector?: string;

    constructor(attributes: Partial<SelectionMadeMessage> = {}) {
        super('selection made', 'content', attributes);
    }
}
import Message from "../message";

export default class SelectionModeDeactivateMessage extends Message<SelectionModeDeactivateMessage> {

    constructor(attributes: Partial<SelectionModeDeactivateMessage> = {
    }) {
        super('selection mode deactivate', 'popup', attributes)
    }
}
import Wave from "../wave";
import Message from "../message";

export default class StartMouseMoveMessage extends Message<StartMouseMoveMessage> {
    wave?: Wave;

    constructor(attributes: Partial<StartMouseMoveMessage> = {}) {
        super('start-mouse-move', 'popup', attributes)
    }
}import Message from "../message";

export default class RemoveSelectorMessage extends Message<RemoveSelectorMessage> {
    selector?: string;

    constructor(attributes: Partial<RemoveSelectorMessage> = {}) {
        super('remove-selector', 'popup', attributes)
    }
}import Message from "../message";

export default class StartSelectorChooseMessage extends Message<StartSelectorChooseMessage> {
    selector?: string;

    constructor(attributes: Partial<StartSelectorChooseMessage> = {}) {
        super('start-selection-choose', 'popup', attributes)
    }
}import Message from "../message";

export default class SelectionModeActivateMessage extends Message<SelectionModeActivateMessage> {

    constructor(attributes: Partial<SelectionModeActivateMessage> = {
    }) {
        super('selection mode activate', 'popup', attributes)
    }
}
import Message from "../message";

export default class SelectorUpdatedMessage extends Message<SelectorUpdatedMessage> {
    selector?: string;

    constructor(attributes: Partial<SelectorUpdatedMessage> = {}) {
        super('selector-updated', 'content', attributes);
    }
}
import Wave from "../wave";
import Message from "../message";

export default class UpdateSelectorMessage extends Message<UpdateSelectorMessage> {
    reset: boolean = false;
    selector?: string;

    constructor(attributes: Partial<UpdateSelectorMessage> = {
        reset: false
    }) {
        super('update-selector', 'popup', attributes)
    }
}import Message from "../message";

export default class CancelAddSelectorMessage extends Message<CancelAddSelectorMessage> {
    selector?: string;

    constructor(attributes: Partial<CancelAddSelectorMessage> = {}) {
        super('cancel-add-selector', 'popup', attributes)
    }
}import Message from "../message";
import Options from "../options";

export default class UpdateWaveMessage extends Message<UpdateWaveMessage> {
    options?: Options

    constructor(attributes: Partial<UpdateWaveMessage> = {
        options: new Options()
    }) {
        super('update-wave', 'popup', attributes)
    }
}
import Message from "../message";

export default class AddSelectorMessage extends Message<AddSelectorMessage> {
    selector?: string;

    constructor(attributes: Partial<AddSelectorMessage> = {}) {
        super('add-selector', 'popup', attributes)
    }
}import Message from "../message";
import Options from "../options";

export default class StartMessage extends Message<StartMessage> {
    options?: Options;

    constructor(attributes: Partial<StartMessage> = {
        options: new Options()
    }) {
        super('start', 'popup', attributes)
    }
}import Message from "../message";

export default class StopMessage extends Message<StopMessage> {
    constructor() {
        super('stop', 'popup') // get-off-my-lawn-simulator
    }
}import Message from "../message";

export default class EndSelectorChooseMessage extends Message<EndSelectorChooseMessage> {
    constructor(attributes: Partial<EndSelectorChooseMessage> = {}) {
        super('end-selection-choose', 'popup', attributes)
    }
}
import Message from "../message";

export default class StartAddSelectorMessage extends Message<StartAddSelectorMessage> {
    selector?: string;

    constructor(attributes: Partial<StartAddSelectorMessage> = {}) {
        super('start-add-selector', 'popup', attributes)
    }
}import Message from "../message";
import {ClientHost, ClientID} from "../../util/state-machine";

export default class HeartbeatResultMessage extends Message<HeartbeatResultMessage> {
    clientId?: string; // the receiving client's client id
    apiMap?: Map<ClientID, ClientHost> // clientId to the ClientLocation type for api discovery

    constructor() {
        super('heartbeat-result', 'popup', undefined, false);
    }
}import Message from "../message";
import {ClientHost, ClientID} from "../../util/state-machine";

export default class BootstrapResultMessage extends Message<BootstrapResultMessage> {
    clientId?: string; // the receiving client's client id
    apiMap?: Map<ClientID, ClientHost> // clientId to the ClientLocation type for api discovery

    constructor(attributes: Partial<BootstrapResultMessage> = {}) {
        super('bootstrap-result', 'background', undefined, false);
    }
}import Message from "../message";

export default class SelectionModeMessage extends Message<SelectionModeMessage> {
    selector?: string;

    constructor(attributes: Partial<SelectionModeMessage> = {
    }) {
        super('update', 'popup', attributes)
    }
}
import Message from "../message";

export default class BootstrapMessage extends Message<BootstrapMessage> {
    constructor() {
        super('bootstrap', 'content', undefined, false);
    }
}import Wave from "./wave";


export const enum WaveAnimationControl {
    CSS,
    MOUSE
}

export const KeyChordDefaultFactory = () => ["w", "Shift"]
export const WaveAnimationControlDefault: WaveAnimationControl = WaveAnimationControl.CSS;
export const ShowNotificationsDefault = true
export const GoingDefault = false
export const WaveDefaultFactory = () => Wave.getDefaultWave()
export const SelectorDefault: string = "p,h2,h3,h4,h5,h6,h7,h8,article,section,aside,figcaption,pre,div"
export const SelectorsDefaultFactory = () => [SelectorDefault]
export const WindowDocumentWidth = 600import AttributeConstructor from "../util/attribute-constructor";

export default class Text extends AttributeConstructor<Text> {
    size?: string;
    color?: string;

    constructor(attributes: Partial<Text> = {
        size: 'initial',
        color: 'initial'
    }) {
        super(attributes)
    }
}import AttributeConstructor from "../util/attribute-constructor";
import {Named} from "../util/state";

export interface MessageInterface {
    getName(): string;
    getFrom(): string;
    getClientId(): string;
}

export default abstract class Message<T> extends AttributeConstructor<T> implements MessageInterface, Named {
    name: string;
    from: string;
    clientId?: string;

    protected constructor(name: string, from: string, attributes?: Partial<T>, requireAllAssigned: boolean = true, clientId = undefined) {
        super(attributes, requireAllAssigned)

        this.name = name;
        this.from = from;
        this.clientId = clientId;
    }

    /**
     * Returns clientId
     */
    getFrom(): string {
        return this.from
    }

    getName(): string {
        return this.name;
    }

    getClientId(): string {
        if (!this.clientId) console.log("clientId is missing from message: " + this.name + ", from, " + this.from)
        return this.clientId || "no-id";
    }
}

import Text from '../models/text';
import AttributeConstructor from "../util/attribute-constructor";
import {SelectorDefault} from "./defaults";

export const defaultCssTemplate = (options: Wave) => `
@-webkit-keyframes wobble {
  0% { transform: translateX(${options.axisTranslateAmountXMax}%); rotateY(${options.axisRotationAmountYMin}deg); }
  15% { transform: translateX(${options.axisTranslateAmountXMin}%) rotateY(${options.axisRotationAmountYMax}deg); }
}

${options.selector || '.wave-reader__text'} {
  font-size: ${options.text?.size || 'inherit'};
  -webkit-animation-name: wobble;
  animation-name: wobble;
  -webkit-animation-duration: ${options.waveSpeed}s;
  animation-duration: ${options.waveSpeed}s;
  -webkit-animation-fill-mode: both;
  animation-fill-mode: both;
  animation-iteration-count: infinite;
}
`;

// maybe change initial 0% animation frame of wobble to 'initial' values
//   and 15% to replacement values, such that the animation will pan to the new rotation
//   NOTE: this may be the existing behavior.
export const defaultCssMouseTemplate = (options: Wave) => `
@-webkit-keyframes wobble {
  0% { transform: translateX(initial); rotateY(initial); }
  15% { transform: translateX(TRANSLATE_X%); rotateY(ROTATE_Ydeg); }
}

${options.selector || '.wave-reader__text'} {
  font-size: ${options.text?.size || 'inherit'};
  -webkit-animation-name: wobble;
  animation-name: wobble;
  -webkit-animation-duration: ${options.waveSpeed}s;
  animation-duration: ${options.waveSpeed}s;
  -webkit-animation-fill-mode: both;
  animation-fill-mode: both;
  animation-iteration-count: infinite;
}
`;

const TRANSLATE_X = "TRANSLATE_X";
const ROTATE_Y = "ROTATE_Y";

export const replaceAnimationVariables = (wave: Wave, translateX: string, rotateY: string): string => {
    return (wave.cssMouseTemplate || "")
        .replaceAll(TRANSLATE_X, translateX)
        .replaceAll(ROTATE_Y, rotateY);
}

const enum WaveShape {
    AUTO, // based on the wave shape options, choose best fit
    F_SHAPED, // left to right (per orientation, like an ocean wave
    LAYER_CAKE, // a swirl, broadly based on headers
    F_SHAPED_STOP // the f-shaped wave, but stops horizontally at each horizontal page break, animating,
    // offset each stop by a small degree, slightly more exagerated maybe but could really help those that spend a lot of
    // their time scanning losely collected pages like personal shoppers, or people addicted to pinterest etc

    // todo: perhaps a WaveRecommendationService, as we could pass in the result from the user selector choice,
    //  then suggest a preset or a custom
    // todo: research whether or not, layer cake or f-shaped scanning is:
    //  - user preference (nurture)
    //  - innate brain stuff (nature)
    //  - a combination (both)
    //  hypothesis: combination, based on the alignment of the page - more grid like, layer cake, more article like, f-shaped
    //   https://www.nngroup.com/articles/layer-cake-pattern-scanning/
    //  theory: the more evenly spaced the page, the more we should apply swirl animation to each stop
    //       similar to the needleman-wunsch algorithm, we want to calculate a spread from expected average position
    //  theory: (of my own behavior), spread(set, h, w, n, count) = <set[n].x - n * w/count, set[n].y - n * h/count>
    //       if the avg sum of widths for horizontal and vertical is less than 1 standard deviation for each axis
    //          then we have relatively evenly spread grid, and should use layer cake pattern for this selection
    //       if the avg width sum of widths for horizontal and vertical is greater than 1 standard deviation for each axis
    //          then we have an oblong shaped article, and should use an F-shaped pattern
    //       todo: research:
    //          if we choose layer-cake, we should check to see if each horizontal stop resembles an F-shaped, or layer cake pattern
    //             then if we're still layer-caked, we stay with swirl, if not, we use hybrid or combination
}

export default class Wave extends AttributeConstructor<Wave>{
    text: Text = new Text();
    selector?: string;
    cssTemplate?: string;
    cssMouseTemplate?: string;
    waveSpeed?: number;
    shape: WaveShape = WaveShape.F_SHAPED
    axisTranslateAmountXMax?: number;
    axisTranslateAmountXMin?: number;
    axisRotationAmountYMax?: number;
    axisRotationAmountYMin?: number;

    constructor(attributes: Partial<Wave> = Wave.getDefaultWave()) {
        super(attributes);
        this.cssTemplate = attributes.cssTemplate || defaultCssTemplate(attributes as Wave);
        this.cssMouseTemplate = attributes.cssMouseTemplate || defaultCssMouseTemplate(attributes as Wave)
    }

    // mutates the wave if necessary to update the css
    public update(): Wave {
        const css = defaultCssTemplate(this);
        if (css != this.cssTemplate && !this.cssTemplate) {
            this.cssTemplate = defaultCssTemplate(this);
            this.cssMouseTemplate = defaultCssMouseTemplate(this);
        }
        return this
    }

    public static getDefaultWave(): Wave {
        return new Wave({
            selector: SelectorDefault,
            waveSpeed: 4,
            shape: WaveShape.F_SHAPED,
            axisTranslateAmountXMax: 0,
            axisTranslateAmountXMin: -1,
            axisRotationAmountYMin: -2,
            axisRotationAmountYMax: 2,
            text: new Text({
                size: 'initial',
                color: 'initial'
            })
        });
    }
}import AttributeConstructor from "../util/attribute-constructor";
import Wave from "./wave";
import { KeyChord } from "../components/util/user-input";
import {
    WaveAnimationControlDefault,
    ShowNotificationsDefault,
    GoingDefault,
    WaveAnimationControl,
    WaveDefaultFactory,
    KeyChordDefaultFactory,
    SelectorsDefaultFactory
} from "./defaults"
import {State} from "../util/state";

export class WaveToggleConfig extends AttributeConstructor<WaveToggleConfig> {
    // a 1-4ish length array of keys
    keyChord: KeyChord = KeyChordDefaultFactory()

    public constructor(attributes: Partial<WaveToggleConfig> = {}) {
        super(attributes);
        this.keyChord = attributes.keyChord || this.keyChord
    }

    static getDefaultConfig(): WaveToggleConfig {
        return new WaveToggleConfig()
    }
}

export const DeepEquals = (a: unknown, b: unknown): boolean => {
    if (typeof a !== 'object' && a === b) {
        return true;
    }

    const aString = JSON.stringify(a);
    const bString = JSON.stringify(b);

    const aObj = JSON.parse(aString);
    const bObj = JSON.parse(bString);

    if (typeof a !== typeof b) {
        console.log("array mismatch for property: aString: " + aString + ", bString: " + bString);
        return false;
    }

    if ((typeof a === "boolean" || typeof a === "number" || typeof a === "string") && a !== b) {
        console.log("array mismatch for property: aString: " + aString + ", bString: " + bString);
        return false;
    }

    if (Array.isArray(aObj) && ((Array.isArray(aObj) != Array.isArray(bObj))
        || Object.keys(aObj).find(prop => !(prop in bObj)) ||
           Object.keys(bObj).find(prop => !(prop in aObj)))) {
        console.log("array mismatch for property: aString: " + aString + ", bString: " + bString);
        return false;
    }

    for (const prop in aObj) {
        if (Array.isArray(aObj[prop]) || Array.isArray(bObj[prop])) {
            if (aObj[prop].find((ap: any, i: number) => Array.isArray(bObj[prop]) && !Object.is(ap, bObj[prop][i]))) {
                console.log(" array mismatch for property: " + prop);
                return false;
            }
        } else {
            if (!DeepEquals(aObj[prop], bObj[prop])) {
                console.log(" array mismatch for property: " + prop);
                return false;
            }
        }
    }

    return true;
}

export default class Options extends AttributeConstructor<Options> {
    defaultSettings: boolean = false;
    state: State | undefined = undefined;
    showNotifications: boolean = ShowNotificationsDefault;
    going: boolean = GoingDefault;
    waveAnimationControl: WaveAnimationControl = WaveAnimationControlDefault;
    wave: Wave = WaveDefaultFactory();
    toggleKeys: WaveToggleConfig = WaveToggleConfig.getDefaultConfig();
    selectors: string[] = SelectorsDefaultFactory();

    constructor(props: Partial<Options> = {}) {
        super(undefined);
        // typescript auto-fills defaults here, if this is the desired behavior
        super.assign(props);
        // rehydrate the wave property as it surprisingly loses type after deserialization
        this.wave = new Wave(this.wave);
    }

    public static getDefaultOptions(): Options {
        return new Options();
    }

    public static OptionsEqual(a: Options, b: Options) {
        return DeepEquals(a, b);
    }
}
import { FunctionComponent, useEffect, useState } from "react";
import {WaveAnimationControl, WindowDocumentWidth} from "../models/defaults";
import Options, {WaveToggleConfig} from "../models/options";
import Text from "../models/text";

import {
    Autocomplete,
    Button,
    ButtonGroup,
    Checkbox,
    FormControl,
    FormControlLabel,
    FormLabel, Radio,
    RadioGroup,
    TextField
} from "@mui/material";
import Wave from "../models/wave";
import * as React from "react";
import styled from "styled-components";
import ScanForInputField from "./scan-for-input-field";
import {KeyChord} from "./util/user-input";
import SettingsService, {DomainPaths, SettingsDAOInterface} from "../services/settings";

type SettingsProps = {
    initialSettings: Options;
    onUpdateSettings: {( settings: Options ): void},
    domain: string,
    path: string,
    onDomainPathChange: {(domain: string, path: string): void}
    settingsService: SettingsDAOInterface
}

const SettingsStyleContainer = styled.div`
  width: 100%;
  padding: 0;
  margin: 0;
  
  .form-control {
    display: flex!important;
    width: ${WindowDocumentWidth}px;
    max-width: ${WindowDocumentWidth}px;
    // use https://css-tricks.com/dont-overthink-flexbox-grids/ but with his
    //  method nested a couple times
    flex-basis: 100%;
    flex-wrap: wrap!important;
    flex-direction: row;
    //align-items: baseline;
    justify-content: space-between;
    //justify-content: space-evenly;
    //align-content: space-between;
    //flex-flow: column;
    //flex-direction: column;
    .item {
      flex-grow: 1;
      
      width: 200px;
      margin: 5px;
    }
    .item-wide { 
      flex-grow: 3;
      width: 800px;
    }
    
    .flex-break {
      flex-basis: 100%;
      height: 0;
    }
    
    & > * {
      margin-top: 1em!important;
      margin-bottom: 1em!important;
    }
  }
`;

const val = (fn: {(v: any): void}) => ((_: any, value: any) => fn(value));
const eventVal = (fn: {(e: any): void}) =>
    (e: React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>) => fn(e.target.value);

// This may be a bit cleaner with redux or some other data store
//  maybe it's worth while to make something like nested('property.prop.value', object)
/**
 * TODO: copy for current tab button
 *
 * todo: toggle for settings ???
 * @param initialSettings the initial settings object, use [Option.getDefaultOptions()] for defaults
 * @param onUpdateSettings evented update callback
 * @param domain the domain for the given initialSettings
 * @param path the path for the given initialSettings
 * @param onDomainPathChange domain change event
 * @param settingsService self described
 * @constructor
 */
export const Settings: FunctionComponent<SettingsProps> = ({
    initialSettings,
    onUpdateSettings,
    domain,
    path,
    onDomainPathChange,
    settingsService = new SettingsService()
}: SettingsProps) => {

    const [settings, setSettings] = useState(new Options(initialSettings));
    const typedSetSettings = (deltaSettings: Partial<Options> = settings) => setSettings(new Options(deltaSettings));
    const [saved, setSaved] = useState(true);

    const [domainPaths, setDomainPaths] = useState<DomainPaths[]>([])
    const [currentPath, setCurrentPath] = useState(path)
    const [currentDomain, setCurrentDomain] = useState(domain)
    const [editingDomain, setEditingDomain] = useState(domain)

    const [waveAnimationControl, setWaveAnimationControl] = useState(initialSettings.waveAnimationControl)
    const [textColor, setTextColor] = useState(initialSettings.wave.text.color);
    const [textSize, setTextSize] = useState(initialSettings.wave.text.size);
    const [selector, setSelector] = useState(initialSettings.wave.selector);
    const [cssTemplate, setCssTemplate] = useState(initialSettings.wave.cssTemplate);
    const [cssMouseTemplate, setCssMouseTemplate] = useState(initialSettings.wave.cssMouseTemplate);
    const [waveSpeed, setWaveSpeed] = useState(initialSettings.wave.waveSpeed);
    const [axisTranslateAmountXMax, setAxisTranslateAmountXMax] = useState(initialSettings.wave.axisTranslateAmountXMax);
    const [axisTranslateAmountXMin, setAxisTranslateAmountXMin] = useState(initialSettings.wave.axisTranslateAmountXMin);
    const [axisRotationAmountYMax, setAxisRotationAmountYMax] = useState(initialSettings.wave.axisRotationAmountYMax);
    const [axisRotationAmountYMin, setAxisRotationAmountYMin] = useState(initialSettings.wave.axisRotationAmountYMin);
    const [showNotifications, setShowNotifications] = useState(initialSettings.showNotifications);
    const [toggleKeys, setToggleKeys] = useState(initialSettings.toggleKeys)

    useEffect(() => {
        settingsService.getDomainsAndPaths().then(setDomainPaths)
    }, [])

    useEffect(() => {
        if (domainPaths.length == 0) {
            return;
        }
        const s: any = {
            ...initialSettings,
            showNotifications,
            going: settings.going,
            waveAnimationControl,
            toggleKeys,
            wave: new Wave({
                text: new Text({
                    color: textColor,
                    size: textSize
                }),
                selector,
                cssTemplate, cssMouseTemplate,
                waveSpeed,
                axisTranslateAmountXMax,
                axisTranslateAmountXMin,
                axisRotationAmountYMax,
                axisRotationAmountYMin,
            })
        }

        if (!Options.OptionsEqual(new Options(s), initialSettings)) {
            typedSetSettings(s);
            setSaved(false);
        }

        setEditingDomain(currentDomain)
        console.log(`editingDomain ${editingDomain}`)
     }, [
        waveAnimationControl,
        showNotifications,
        textColor, textSize,
        selector,
        cssTemplate, cssMouseTemplate,
        waveSpeed,
        axisTranslateAmountXMax,
        axisTranslateAmountXMin,
        axisRotationAmountYMax,
        axisRotationAmountYMin,
        toggleKeys,
        domainPaths
    ]);

    const resetSettings = () => {
        if (window.confirm("Are you sure you want to reset the settings?")) {
            const defaultSettings = Options.getDefaultOptions();
            saveSettings(defaultSettings);
        }
    }

    const saveSettings = (deltaSettings?: Partial<Options>) => {
        const settingsToSave: Options = new Options({
                    showNotifications,
                    going: settings.going || false,
                    waveAnimationControl,
                    toggleKeys,
                    wave: new Wave({
                        text: new Text({
                            color: textColor,
                            size: textSize
                        }),
                        selector,
                        cssTemplate, cssMouseTemplate,
                        waveSpeed,
                        axisTranslateAmountXMax,
                        axisTranslateAmountXMin,
                        axisRotationAmountYMax,
                        axisRotationAmountYMin,
                    }),
            ...deltaSettings});

        setSettings(settingsToSave);
        onUpdateSettings(settingsToSave);
        setSaved(true);
    }

    const onToggleScan = (keyChord: KeyChord) => {
        setToggleKeys(new WaveToggleConfig({
            keyChord
        }))
    }

    const onCancelToggleScan = (keyChord: KeyChord) => {
        // maybe unnecessary
        setToggleKeys(new WaveToggleConfig({
            keyChord
        }))
    }

    const onDomainChange = (event: any, newValue: string | null) => {
        if (newValue && newValue !== currentDomain) {
            setCurrentDomain(newValue);
            onDomainPathChange(newValue, currentPath);
        }
    }

    const onPathChange = (event: any, newValue: string | null) => {
        if (newValue && (newValue !== currentPath || (newValue === currentPath && currentDomain != domain))) {
            setCurrentPath(newValue);
            onDomainPathChange(currentDomain, newValue);
        }
    }

    // for the css template to work, we need to switch over to replacement templates instead of runtime.
    return (
        <SettingsStyleContainer>
            { saved ? <span>✅</span> : <span>🌊</span> }
            <FormControl className={"form-control"}>

                <span className={"item"}>
                    <FormLabel id={"notifications-checkbox-label"}>Show Notifications</FormLabel>
                </span>
                <Checkbox aria-labelledby="notifications-checkbox-label" checked={showNotifications}
                          onChange={val(setShowNotifications)}  className={"item"} />
                <ScanForInputField actionType={"Wave Toggle"}
                                   keyLimit={4}
                                   shortcut={toggleKeys.keyChord}
                                   onScan={onToggleScan}
                                   onCancelScan={onCancelToggleScan} />

                <span className={"item"}>
                    <FormLabel id="wave-control-radio-buttons-group-label">Wave Control</FormLabel>
                </span>
                <RadioGroup
                    aria-labelledby="wave-control-radio-buttons-group-label"
                    defaultValue={WaveAnimationControl.CSS}
                    name="radio-buttons-group"
                    value={waveAnimationControl}
                    onChange={val(setWaveAnimationControl)}
                    className={"item"}
                >
                    <FormControlLabel value={WaveAnimationControl.CSS} control={<Radio />} label="CSS Animation" />
                    <FormControlLabel value={WaveAnimationControl.MOUSE} control={<Radio />} label="Mouse" />
                </RadioGroup>

                <TextField id="settings__text-color"
                           className={"item"}
                           value={textColor}
                           onChange={eventVal(setTextColor)}
                           placeholder={"initial"}
                           label="Text Color"
                           variant="outlined"/>
                <TextField id="settings__text-size"
                           className={"item"}
                           value={textSize}
                           onChange={eventVal(setTextSize)}
                           placeholder={"initial"}
                           label="Text Size"
                           variant="outlined"/>
                <TextField id="settings__selector"
                           className={"item"}
                           value={selector}
                           onChange={eventVal(setSelector)}
                           placeholder={"initial"}
                           label="Text CSS Selector"
                           variant="outlined"/>
                <TextField id="settings__css-template"
                    className={"item"}
                    value={cssTemplate}
                    onChange={eventVal(setCssTemplate)}
                    multiline
                    rows={10}
                    placeholder={"initial"}
                    label="Text CSS Selector"
                    variant="outlined" />
                <TextField id="settings__css-template"
                    className={"item"}
                    value={cssMouseTemplate}
                    onChange={eventVal(setCssMouseTemplate)}
                    multiline
                    rows={10}
                    placeholder={"initial"}
                    label="Text CSS Selector"
                    variant="outlined" />
                <TextField id="settings__wave-speed"
                    className={"item"}
                    label="Wave Speed"
                    type="number"
                    value={waveSpeed}
                    onChange={eventVal(setWaveSpeed)}
                    InputLabelProps={{
                        shrink: true,
                    }} />
                <TextField id="settings__wave-translate-x-max"
                    className={"item"}
                    label="Axis Translation Amount X Max"
                    type="number"
                    value={axisTranslateAmountXMax}
                    onChange={eventVal(setAxisTranslateAmountXMax)}
                    InputLabelProps={{
                        shrink: true,
                    }} />
                <TextField id="settings__wave-translate-x-min"
                    className={"item"}
                    label="Axis Translation Amount X Min"
                    type="number"
                    value={axisTranslateAmountXMin}
                    onChange={eventVal(setAxisTranslateAmountXMin)}
                    InputLabelProps={{
                        shrink: true,
                    }} />
                <TextField id="settings__wave-rotation-y-max"
                    className={"item"}
                    label="Axis Rotation Amount Y Max"
                    type="number"
                    value={axisRotationAmountYMax}
                    onChange={eventVal(setAxisRotationAmountYMax)}
                    InputLabelProps={{
                        shrink: true,
                    }} />
                <TextField id="settings__wave-rotation-y-min"
                    className={"item"}
                    label="Axis Rotation Amount Y Min"
                    type="number"
                    value={axisRotationAmountYMin}
                    onChange={eventVal(setAxisRotationAmountYMin)}
                    InputLabelProps={{
                        shrink: true,
                    }} />
                <Autocomplete id="domain-settings-dropdown"
                    className={"item"}
                    disablePortal
                    value={currentDomain}
                    onChange={onDomainChange}
                    options={(domainPaths && domainPaths.map(dp => dp.domain)) || []}
                    sx={{ width: "50%" }}
                    renderInput={(params) => <TextField {...params} label={currentDomain} />} />

                <Autocomplete id="path-settings-dropdown"
                    className={"item"}
                    disablePortal
                    value={currentPath}
                    onChange={onPathChange}
                    options={(domainPaths && domainPaths.find((dp: DomainPaths) => dp.domain === currentDomain)?.paths as string[]) || []}
                    sx={{ width: "50%" }}
                    renderInput={(params) => <TextField {...params} label={currentPath} />} />

            </FormControl>
            <ButtonGroup variant="text" aria-label="text button group">
                <Button onClick={() => saveSettings()}>Save Settings</Button>
                <Button onClick={resetSettings}>Reset</Button>
            </ButtonGroup>
        </SettingsStyleContainer>
    )
};

export const LoadSettings = (settingsService: SettingsDAOInterface) : Promise<Options> => {
        try {
            return settingsService.getCurrentSettings()
        } catch (e) {
            console.error(`cannot load options with exception: ${e}`);
            //throw(new Error(`cannot load options with exception: ${e}`))
            const defaultSettings = Options.getDefaultOptions()
            defaultSettings.defaultSettings = true;
            return Promise.resolve(defaultSettings)
        }
}
import {Observable, Subscriber} from 'rxjs';

export type WindowKeyDownKeyObserverDefinition = {
    (
        listenerReturn: { (eventListener: { (event: KeyboardEvent): void }): void },
        preventDefault: boolean
    ): Observable<string>
};

/**
 * a keydown event listener returning an [Observable<string>] of [event.key]
 * @param listenerReturn probably YAGNI but a function to return the closure scoped event listener \
 *    so you can extract the listener from the listenerReturn lambda and call [window.removeEventListener()] \
 *    maybe just return a [Pair<>] idk
 * @param preventDefault calls event.preventDefault() optionally a key is detected, useful for scanning, bad for shortcuts
 */
export const WindowKeyDownKey: WindowKeyDownKeyObserverDefinition = (listenerReturn: {(eventListener: {(event: KeyboardEvent): void}): void},
                                                                     preventDefault = true): Observable<string> => {
    return new Observable((subscriber: Subscriber<string>) => {
        const listener = (event: KeyboardEvent) => {
            if (event.defaultPrevented) {
                return; // Should do nothing if the default action has been cancelled
            }

            if (event.key) {
                // Handle the event with KeyboardEvent.key
                subscriber.next(event.key);
                if (preventDefault) event.preventDefault();
            }
        };
        listenerReturn(listener);
        window.addEventListener(
            "keydown",
            listener,
            true,
        );
    });
}


/**
 * a 1-4ish length array of keys
 */
export type KeyChord = string[]
/**
 * Observes keyboard key events and returns an Observable that calls next(true) if the shortcut is matched
 * Calls, next(false) if not
 * @param shortcut
 * @param keysObservable
 * @param stop
 * @constructor
 */
export const FollowKeyChordObserver = (shortcut: KeyChord,
                                       keysObservable: Observable<string>,
                                       stop: {(): boolean}): Observable<boolean> => {
    return new Observable((subscriber: Subscriber<boolean>) => {
        let typed: KeyChord = []
        const join = (shortcut: string[]) => shortcut.join(', ').toLowerCase()
        const joined = join(shortcut)
        let complete = false;
        keysObservable.subscribe((key: string) => {
            if (stop()) {
                if (!complete) {
                    complete = true;
                    subscriber.complete()
                }
                return;
            }

            // typed.unshift(key);
            // todo: review: should shift, meta, and control reduce to 1 and stick until keyup?
            //        so you can hold shift, and toggle with 'w'
            typed = [key].concat(typed).slice(0, shortcut.length)

            if (join(typed) === joined) {
                subscriber.next(true);
            } else {
                subscriber.next(false);
            }
        })
    });
}
import React, {FunctionComponent, ReactNode, useEffect, useRef, useState} from "react";
import styled from "styled-components";
import {Button} from "@mui/material";

type SelectorProps = {
    going: boolean,
    onGo: () => void
    onStop: () => void
}

export const Go = styled(Button)`
    height: 4rem;
    width: 8rem;
    font-family: "Roboto","Helvetica","Arial",sans-serif;
    text-transform: uppercase;
  
`;
const WaveTypography = styled.h2`
  display: inline;
  font-size: 5rem!important;
  margin-right: 0.1rem;
  border-right: 0.1rem transparent;
  border-radius: 1rem;
  transition:font-size 3s;
  
  .wave {
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    width: 1em;
    height: 1em;
    display: inline-block;
    fill: currentColor;
    -webkit-flex-shrink: 0;
    -ms-flex-negative: 0;
    flex-shrink: 0;
  }
  
  .shrink {
    font-size: 2rem;
    transition:font-size 12s;
  }
`;

type WaveProps = {
    children?: ReactNode
}

/* eslint-disable  @typescript-eslint/no-unused-vars */
const WaveSymbol = ({
 children
}: WaveProps) => {
    return <WaveTypography>{children}</WaveTypography>;
}


const GoButton: FunctionComponent<SelectorProps> = ({ going, onGo, onStop }: SelectorProps) => {
    const [goDisplayText, setGoDisplayText] = useState('go!');
    const goButtonRef = useRef<HTMLElement | null>();

    useEffect(() => {
        if (going) {
            setGoDisplayText("waving"); // 🌊
        } else {
            setGoDisplayText("go!")
        }
    }, [going]);

    useEffect(() => {
        if ((goButtonRef.current as HTMLElement | null) !== null) {
            setTimeout(() => {
                (goButtonRef.current as unknown as HTMLElement).classList.add("shrink");
            }, 0);
        }
    }, [goButtonRef])

    const goClicked = () => {
        if (going) {
            // we want to stop if we're going
            onStop();
        } else {
            onGo();
        }
        going = !going;
    }

    return (
        <Go variant="outlined" startIcon={<WaveSymbol><span className={'wave'} ref={el => goButtonRef.current = el}>🌊</span></WaveSymbol>}
            type={"button"} onClick={goClicked}>{goDisplayText}</Go>
    );
}

export default GoButton;
import { FunctionComponent, useEffect, useState } from "react";
import { FormLabel } from "@mui/material";
import * as React from "react";
import { KeyChord, WindowKeyDownKey, WindowKeyDownKeyObserverDefinition } from "./util/user-input";
import styled from "styled-components";
import { CState, NameAccessMapInterface, Named, State, StateNames } from "../util/state";
import StateMachine from "../util/state-machine";

//const val = (fn: {(v: any): void}) => ((_: any, value: any) => fn(value));
//const eventVal = (fn: {(e: any): void}) =>
//    (e: React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>) => fn(e.target);

export type ActionType = string | undefined;
type ScanForInputProps = {
    actionType: ActionType | string
    shortcut: KeyChord
    keyLimit: number
    onScan: {(keyChord: KeyChord): void}
    onCancelScan: {(keyChord: KeyChord): void}
}

type VisibilityProps = {
    visible: boolean
}

const ScanTextInput = styled.input`
  display: ${((props: VisibilityProps) => props.visible ? 'inline' : 'none')};
  // should not accept text input
  pointer-events: none;
`;

const SaveButton = styled.input`
    display: ${((props: VisibilityProps) => props.visible ? 'inline' : 'none')}
`;

const RevertButton = styled.input`
  display: ${((props: VisibilityProps) => props.visible ? 'inline' : 'none')}
`;

const ScanTextDisplay = styled.div`
  display: ${((props: VisibilityProps) => props.visible ? 'inline' : 'none')}
`;

const ScanNote = styled.div`
  color: #333;
  display: ${((props: VisibilityProps) => props.visible ? 'inline' : 'none')};
`;

const ClearButton = styled.input`
  display: ${((props: VisibilityProps) => props.visible ? 'inline' : 'none')}
`

const ClickableScanTextContainer = styled.div`
  display: inline;
`;

const ScanForInput = styled.div``;

type EventListener = {(event: KeyboardEvent): void} | undefined;

/**
 * truncating limited unshift, this returns:
 *   [] for Escape
 *   [key] for key limit exceeded
 *   [..., key] for under limit
 * @param keyChord [KeyChord | string[]] the typed keychord so far
 * @param key [string] the key typed
 * @param keyLimit [number] the limit of keys in this keychord
 */
type KeyChordAssignment = {
    keyChord: KeyChord
    escapeCalled: boolean
}
export const assignKeyChord = (keyChord: KeyChord, key: string, keyLimit: number): Partial<KeyChordAssignment> => {
    if (key === "Escape") {
        // TODO: REVIEW: international keyboard key names?
        return { keyChord: [], escapeCalled: true };
    }
    if (keyChord.length === keyLimit) {
        return { keyChord: [key], escapeCalled: false };
    } else {
        return { keyChord: [key].concat(keyChord), escapeCalled: false };
    }
}

/**
 * Presents a clickable label and an input scanning text box.
 * The returned is an array of keys [KeyChord] typed.
 *
 * @param actionType the name of the event you're scanning keys for, e.x. "Toggle"
 * @param shortcut [string[] | KeyChord] an array of key names
 * @param keyLimit the length of the key chord
 * @param onScan [{(keys: KeyChord): void}] saved! Passes the new shortcut KeyChord
 * @param onCancelScan [{(keys: KeyChord): void}] cancelled! Passes the old shortcut KeyChord
 * @constructor see [ScanForInputProps]
 */
const ScanningMap: Map<ActionType, KeyChord> = new Map<ActionType, KeyChord>();
const ListenerMap: Map<ActionType, EventListener> = new Map<ActionType, EventListener>();

export const ClearScanningMap = () => {
    ScanningMap.clear();
}

type ScanForInputStatesProps = {
    map: Map<ActionType, State>
    stateMachineMap: Map<ActionType, StateMachine>
    listenerMap: Map<ActionType, EventListener>
    scanningMap: Map<ActionType, KeyChord>
    actionType: ActionType
    keyLimit: number
    shortcut: KeyChord
    setScanning: { (scanning: boolean): void }
    setKeyChord: { (keyChord: KeyChord): void }
    onScan: { (keyChord: KeyChord): void }
    onCancelScan: { (keyChord: KeyChord): void }
    windowKeyDownObserver: WindowKeyDownKeyObserverDefinition
    shouldPreventDefault: boolean
    window: Window & typeof globalThis;
}

// type WindowMethods = {
//     addEventListener: { (eventName: string, listener: EventListener): void }
//     removeEventListener: { (eventName: string, listener: EventListener): void }
// }
type WindowLike = Window & typeof globalThis;
// type WindowMock = WindowLike & WindowMethods;

    //typeof window !== undefined ? window as (Window & typeof globalThis) : {
//     addEventListener: (eventName: string, listener: EventListener) => { console.error("window mock was instantiated during runtime"); },
//     removeEventListener: (eventName: string, listener: EventListener) => { console.error("window mock was instantiated during runtime"); }
// } as unknown as WindowMock;
const _window = window as unknown as WindowLike
export const ScanForInputStates = ({
       map,
       stateMachineMap,
       listenerMap,
       scanningMap,
       actionType,
       keyLimit,
       shortcut,
       setScanning,
       setKeyChord,
       onScan,
       onCancelScan,
       windowKeyDownObserver = WindowKeyDownKey,
       shouldPreventDefault = true,
       window = _window
    }: ScanForInputStatesProps): NameAccessMapInterface =>  {
    // TODO: shortcut is still getting passed in from settings as the previous value:
    //   after a "click", "start scanning" "save", save settings -> "click", "save" ...
    //   observed: back to the value saved before saving settings
    //   expected: saves the new value scanned
    // theory: settings isn't matriculating through properly?

    /* eslint-disable  @typescript-eslint/no-unused-vars */
    const states: StateNames = {
        "base": CState("base", ["start scanning", "base"], true, async (message, state, previousState): Promise<State | undefined> => {
            if (listenerMap.has(actionType)) {
                scanningMap.delete(actionType)
                window.removeEventListener("keydown", listenerMap.get(actionType)!, true);
                listenerMap.delete(actionType)
            }
            return map.get("base");
        }),
        "start scanning": CState("start scanning", ["scanning", "stop scanning"], false, async (message, state, previousState): Promise<State | undefined> => {
            setScanning(true);
            // maybe add a useState "started editing" variable, and keep the scanningMap defaulted to shortcut
            //  then when we get any events from subscribe, clear it and accept the new input
            //   - or -
            //  alternatively, we may want to change the value type for scanningMap to include a "started editing" property
            scanningMap.set(actionType, []);

            windowKeyDownObserver((e: {(event: KeyboardEvent): void}) => {
                listenerMap.set(actionType, e);
            }, shouldPreventDefault).subscribe((key: string) => {
                if (!scanningMap.has(actionType)) {
                    console.log("no scanning map found, inspect previous state!");
                    return;
                }

                const assignment = assignKeyChord(scanningMap.get(actionType) || [], key, keyLimit)
                if (assignment.escapeCalled) {
                    // defer the current frame
                    // setTimeout(() => , 0)
                    stateMachineMap.get(actionType)?.handleState({ name: "stop scanning" } as Named)
                } else {
                    scanningMap.set(actionType, assignment.keyChord || [])
                    setKeyChord(assignment.keyChord || []);
                }
            })
            return map.get("scanning");
        }),
        "scanning": CState("scanning", ["save", "revert", "clear", "stop scanning"], false),
        "save": CState("save", ["base"], false, async (message, state, previousState): Promise<State | undefined> => {
            if (listenerMap.has(actionType)) {
                window.removeEventListener("keydown", listenerMap.get(actionType)!, true);
                listenerMap.delete(actionType)
            }
            setScanning(false)
            const update = scanningMap.get(actionType) || [];
            scanningMap.delete(actionType);
            setKeyChord(update);
            onScan(update);
            return map.get("base");
        }),
        "clear": CState("clear", ["scanning"], false, async (message, state, previousState): Promise<State | undefined> => {
            scanningMap.set(actionType, []);
            setKeyChord([]);
            return map.get("scanning")
        }),
        "revert": CState("revert", ["scanning"], false, async (message, state, previousState): Promise<State | undefined> => {
            // revert
            setKeyChord(shortcut);
            return previousState;
        }),
        "stop scanning": CState("base", ["base"], false, async (message, state, previousState): Promise<State | undefined> => {
            if (listenerMap.has(actionType)) {
                window.removeEventListener("keydown", listenerMap.get(actionType)!, true);
                listenerMap.delete(actionType)
            }
            setScanning(false)
            setKeyChord(shortcut);
            scanningMap.delete(actionType);
            onCancelScan(shortcut);
            return map.get("base");
        })
    }

    Object.keys(states).forEach(key => {
        map.set(key, states[key]);
    })

    return {
        map,
        getState(name: string): State | undefined {
            return map.get(name);
        }
    } as NameAccessMapInterface;
}

const StateMachineMap = new Map<ActionType, StateMachine>()

const ScanForInputField: FunctionComponent<ScanForInputProps> = ({
        actionType = "Toggle",
        shortcut,
        keyLimit = 4,
        onScan,
        onCancelScan
    }: ScanForInputProps) => {

    // display with "shift + space" etc
    // modifiers, shift, control, alt/option, maybe command, maybe just last key chords and see what happens?
    const [keyChord, setKeyChord] = useState<KeyChord>(shortcut);
    const [scanning, setScanning] = useState(false);
    // refresh the states with each re-render
    const scanForInputStateMap = ScanForInputStates({
        map: new Map<ActionType, State>(),
        stateMachineMap: StateMachineMap,
        listenerMap: ListenerMap,
        scanningMap: ScanningMap,
        actionType: actionType,
        keyLimit,
        shortcut,
        setScanning,
        setKeyChord,
        onScan,
        onCancelScan,
        windowKeyDownObserver: WindowKeyDownKey,
        shouldPreventDefault: true,
        window: _window
    });

    const stateMachine = () => { return StateMachineMap.get(actionType); }
    const handleState = async (name: string): Promise<State | undefined> => {
        const machine = stateMachine();

        return machine?.handleState(machine.getState(name) as State)
    }

    useEffect(() => {
        if (!StateMachineMap.has(actionType)) {
            const machine = new StateMachine();
            StateMachineMap.set(actionType, machine);
            machine.initialize(scanForInputStateMap, scanForInputStateMap.getState("base") as State);
        } else {
            StateMachineMap.get(actionType)?.handleState({ name: "base" } as Named);
        }
    }, [])

    const saveClicked = () => {
        handleState("save");
    }

    const cancelClicked = () => {
        // revert
        handleState("revert");
        handleState("stop scanning");
    }

    const clearClicked = () => {
        handleState("clear");
    }

    const scanClicked = () => {
        handleState("start scanning");
    }

    // TODO: the ClickableScanTextContainer and the ScanTextInput components present reversed keyChords from one another
    // TODO: and while reversed keyChords is cool, its confusing, as assignment to the WaveToggleConfig apparently does that
    return (
        <ScanForInput data-testid={"scan-for-input-field"}>
            <FormLabel id={"scan-text-label"}>{actionType}</FormLabel>
            <div />
            <ClickableScanTextContainer
                data-testid={"clickable-text-container"}
                aria-labelledby="scan-text-label"
                onClick={scanClicked}>
                <ScanTextDisplay data-testid={"scan-text-display"} visible={!scanning}>{ keyChord.reverse().join(", ") }</ScanTextDisplay>
                <ScanNote visible={!scanning}>&nbsp;(click to set {actionType})</ScanNote>
            </ClickableScanTextContainer>
            <ScanTextInput
                data-testid={"scan-text-input"}
                aria-labelledby="scan-text-label"
                visible={scanning} type="text"
                value={keyChord.reverse().join(", ")}
                onChange={() => {}}/>
            <SaveButton data-testid={"save-button"} visible={scanning} type="button" value={"Save"} onClick={saveClicked} />
            <RevertButton data-testid={"revert-button"} visible={scanning} type="button" value={"Cancel"} onClick={cancelClicked} />
            <ClearButton data-testid={"revert-button"} visible={scanning} type="button" value={"Clear"} onClick={clearClicked} />
        </ScanForInput>
    );
}

export default ScanForInputField;
import {
    ComponentLog,
    log,
    MachineComponentProps,
    ReactMachine,
    ReactMachineFunction,
    view,
    View,
    Clean,
    ClearViews, _Clean_, _ClearViews_
} from '../util/react-machine';

import { FunctionComponent, useEffect, useState } from "react";
import { FormLabel } from "@mui/material";
import * as React from "react";
import { KeyChord, WindowKeyDownKey, WindowKeyDownKeyObserverDefinition } from "./util/user-input";
import styled from "styled-components";
import { CState, NameAccessMapInterface, Named, State, StateNames } from "../util/state";
import StateMachine, {Client, ClientMessage} from "../util/state-machine";
import Message from "../models/message";

//const val = (fn: {(v: any): void}) => ((_: any, value: any) => fn(value));
//const eventVal = (fn: {(e: any): void}) =>
//    (e: React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>) => fn(e.target);

export type ActionType = string | undefined;
export type ScanForInputProps = {
    actionType: ActionType | string
    shortcut: KeyChord
    keyLimit: number
    onScan: {(keyChord: KeyChord): void}
    onCancelScan: {(keyChord: KeyChord): void}
}

type VisibilityProps = {
    visible?: boolean
}

const ScanTextInput = styled.input`
  display: ${((props: VisibilityProps) => props.visible ? 'inline' : 'none')};
  // should not accept text input
  pointer-events: none;
`;

const SaveButton = styled.input`
    display: ${((props: VisibilityProps) => props.visible ? 'inline' : 'none')}
`;

const RevertButton = styled.input`
  display: ${((props: VisibilityProps) => props.visible ? 'inline' : 'none')}
`;

const ScanTextDisplay = styled.div`
  display: ${((props: VisibilityProps) => props.visible ? 'inline' : 'none')}
`;

const ScanNote = styled.div`
  color: #333;
  display: ${((props: VisibilityProps) => props.visible ? 'inline' : 'none')};
`;

const ClearButton = styled.input`
  display: ${((props: VisibilityProps) => props.visible ? 'inline' : 'none')}
`

const ClickableScanTextContainer = styled.div`
  display: inline;
`;

const ScanForInput = styled.div``;

type EventListener = {(event: KeyboardEvent): void} | undefined;

/**
 * truncating limited unshift, this returns:
 *   [] for Escape
 *   [key] for key limit exceeded
 *   [..., key] for under limit
 * @param keyChord [KeyChord | string[]] the typed keychord so far
 * @param key [string] the key typed
 * @param keyLimit [number] the limit of keys in this keychord
 */
type KeyChordAssignment = {
    keyChord: KeyChord
    escapeCalled: boolean
}
export const assignKeyChord = (keyChord: KeyChord, key: string, keyLimit: number): Partial<KeyChordAssignment> => {
    if (key === "Escape") {
        // TODO: REVIEW: international keyboard key names?
        return { keyChord: [], escapeCalled: true };
    }
    if (keyChord.length === keyLimit) {
        return { keyChord: [key], escapeCalled: false };
    } else {
        return { keyChord: [key].concat(keyChord), escapeCalled: false };
    }
}

/**
 * Presents a clickable label and an input scanning text box.
 * The returned is an array of keys [KeyChord] typed.
 *
 * @param actionType the name of the event you're scanning keys for, e.x. "Toggle"
 * @param shortcut [string[] | KeyChord] an array of key names
 * @param keyLimit the length of the key chord
 * @param onScan [{(keys: KeyChord): void}] saved! Passes the new shortcut KeyChord
 * @param onCancelScan [{(keys: KeyChord): void}] cancelled! Passes the old shortcut KeyChord
 * @constructor see [ScanForInputProps]
 */
const ScanningMap: Map<ActionType, KeyChord> = new Map<ActionType, KeyChord>();
const ListenerMap: Map<ActionType, EventListener> = new Map<ActionType, EventListener>();

export const ClearScanningMap = () => {
    ScanningMap.clear();
}

type ScanForInputStatesProps = {
    map: Map<ActionType, State>
    stateMachineMap: Map<ActionType, StateMachine>
    listenerMap: Map<ActionType, EventListener>
    scanningMap: Map<ActionType, KeyChord>
    actionType: ActionType
    keyLimit: number
    shortcut: KeyChord
    setScanning: { (scanning: boolean): void }
    setKeyChord: { (keyChord: KeyChord): void }
    onScan: { (keyChord: KeyChord): void }
    onCancelScan: { (keyChord: KeyChord): void }
    windowKeyDownObserver: WindowKeyDownKeyObserverDefinition
    shouldPreventDefault: boolean
    window: Window & typeof globalThis;
}

// type WindowMethods = {
//     addEventListener: { (eventName: string, listener: EventListener): void }
//     removeEventListener: { (eventName: string, listener: EventListener): void }
// }
type WindowLike = Window & typeof globalThis;
// type WindowMock = WindowLike & WindowMethods;

//typeof window !== undefined ? window as (Window & typeof globalThis) : {
//     addEventListener: (eventName: string, listener: EventListener) => { console.error("window mock was instantiated during runtime"); },
//     removeEventListener: (eventName: string, listener: EventListener) => { console.error("window mock was instantiated during runtime"); }
// } as unknown as WindowMock;
const _window = window as unknown as WindowLike

const StateMachineMap = new Map<ActionType, StateMachine>()
// todo: service discovery for clients to prevent duplication
const PopupClient = new Client<Message<any>>()
export const ScanForInputFieldMachine: ReactMachineFunction<ScanForInputProps> = ReactMachine<ScanForInputProps>({
    client: PopupClient,
    initialState: "initialize",
    states: {
        initialize: ({state, machine}: Partial<MachineComponentProps>): Promise<ComponentLog> => {
            if(!StateMachineMap.has(state?.props?.actionType)) {
                const machine = new StateMachine();
                StateMachineMap.set(state?.props?.actionType, machine);
                machine.initialize(state?.props?.scanForInputStateMap, state?.props?.scanForInputStateMap.getState("base") as State);
            } else {
                StateMachineMap.get(state?.props?.actionType)?.handleState({name: "base"} as Named);
            }
            return Promise.resolve(log("base", _Clean_))
        },
        base: ({state, machine}: Partial<MachineComponentProps>): Promise<ComponentLog> => {
            const [actionType, setActionType] = state?.useState("actionType", "unassigned") || [undefined, undefined]
            // todo: review: replace log and view with a deconstructor like useState and useReducer?
            return Promise.resolve(log("base",
                <ScanForInput data-testid={"scan-for-input-field"}>
                    <FormLabel id={"scan-text-label"}>{actionType}</FormLabel>
                    <div />
                    <ClickableScanTextContainer
                        data-testid={"clickable-text-container"}
                        aria-labelledby="scan-text-label"
                        onClick={() => machine?.handleState({ name: "start scanning" } as Named)}>
                        <ScanTextDisplay data-testid={"scan-text-display"}>{ state?.props?.keyChord.reverse().join(", ") }</ScanTextDisplay>
                        <ScanNote>&nbsp;(click to set {actionType})</ScanNote>
                    </ClickableScanTextContainer>
                </ScanForInput>));
        },
        scanning: ({state, machine}: Partial<MachineComponentProps>): Promise<ComponentLog> => {
            return Promise.resolve(log("scanning",
                <ScanForInput data-testId={"scan-for-input-field"}>
                    <ScanTextInput
                        data-testid={"scan-text-input"}
                        aria-labelledby="scan-text-label"
                        type="text"
                        value={state?.props?.keyChord.reverse().join(", ")}
                        onChange={() => {}}/>
                    <SaveButton data-testid={"save-button"} type="button" value={"Save"} onClick={() => machine?.handleState({ name: "save" } as Named)} />
                    <RevertButton data-testid={"revert-button"} type="button" value={"Cancel"} onClick={() => {
                        machine?.handleState({ name: "revert" } as Named)
                        machine?.handleState({ name: "stop scanning" } as Named)
                    }} />
                    <ClearButton data-testid={"revert-button"} type="button" value={"Clear"} onClick={() => machine?.handleState({ name: "clear" } as Named)} />
                </ScanForInput>))
        },
        "start scanning":  ({state, machine}: Partial<MachineComponentProps>): Promise<ComponentLog> => {
            state?.props?.setScanning(true);
            // maybe add a useState "started editing" variable, and keep the scanningMap defaulted to shortcut
            //  then when we get any events from subscribe, clear it and accept the new input
            //   - or -
            //  alternatively, we may want to change the value type for scanningMap to include a "started editing" property
            state?.props?.scanningMap.set(state?.props?.actionType, []);

            state?.props?.windowKeyDownObserver((e: {(event: KeyboardEvent): void}) => {
                state?.props?.listenerMap.set(state?.props?.actionType, e);
            }, state?.props?.shouldPreventDefault).subscribe((key: string) => {
                if (!state?.props?.scanningMap.has(state?.props?.actionType)) {
                    console.log("no scanning map found, inspect previous state!");
                    return;
                }

                const assignment = assignKeyChord(state?.props?.scanningMap.get(state?.props?.actionType) || [], key, state?.props?.keyLimit)
                if (assignment.escapeCalled) {
                    // defer the current frame
                    // setTimeout(() => , 0)
                    state?.props?.stateMachineMap.get(state?.props?.actionType)?.handleState({ name: "stop scanning" } as Named)
                } else {
                    state?.props?.scanningMap.set(state?.props?.actionType, assignment.keyChord || [])
                    state?.props?.setKeyChord(assignment.keyChord || []);
                }
            })
            return Promise.resolve(log("scanning", _ClearViews_));
        },
        "clear views": ({previousState}: Partial<MachineComponentProps>): Promise<ComponentLog> => {
            return Promise.resolve(log(previousState || "base", _ClearViews_))
        },
        "clean": ({previousState}: Partial<MachineComponentProps>): Promise<ComponentLog> => {
            return Promise.resolve(log(previousState || "base", _Clean_))
        },
        "save":  async ({state, machine}: Partial<MachineComponentProps>): Promise<ComponentLog> => {
            if (state?.props?.listenerMap.has(state?.props?.actionType)) {
                window.removeEventListener("keydown", state?.props?.listenerMap.get(state?.props?.actionType)!, true);
                state?.props?.listenerMap.delete(state?.props?.actionType)
            }
            state?.props?.setScanning(false)
            const update = state?.props?.scanningMap.get(state?.props?.actionType) || [];
            state?.props?.scanningMap.delete(state?.props?.actionType);
            state?.props?.setKeyChord(update);
            state?.props?.onScan(update);

            await machine?.handleState({ name: "clean" })

            return Promise.resolve(log("base", <span>Saved!</span>));
        },
        "clear":  ({state, machine}: Partial<MachineComponentProps>): Promise<ComponentLog> => {
            state?.props?.scanningMap.set(state?.props?.actionType, []);
            state?.props?.setKeyChord([]);
            return Promise.resolve(log("scanning", _ClearViews_))
        },
        "revert":  ({state, machine, previousState}: Partial<MachineComponentProps>): Promise<ComponentLog> => {
            // revert
            state?.props?.setKeyChord(state?.props?.shortcut);
            return Promise.resolve(log(previousState || "base", _ClearViews_));
        },
        "stop scanning":  ({state, machine}: Partial<MachineComponentProps>): Promise<ComponentLog> => {
            if (state?.props?.listenerMap.has(state?.props?.actionType)) {
                window.removeEventListener("keydown", state?.props?.listenerMap.get(state?.props?.actionType)!, true);
                state?.props?.listenerMap.delete(state?.props?.actionType)
            }
            state?.props?.setScanning(false)
            state?.props?.setKeyChord(state?.props?.shortcut);
            state?.props?.scanningMap.delete(state?.props?.actionType);
            state?.props?.onCancelScan(state?.props?.shortcut);
            return Promise.resolve(log("base", _Clean_))
        }
    }
});
import React, {FunctionComponent, useEffect, useState} from "react";
import {
    ColorGeneratorServiceInterface,
    ColorSelection,
    ForThoustPanel,
    HtmlElement, HtmlSelection, Selector,
    SelectorHierarchy,
    SelectorHierarchyServiceInterface,
    SizeFunctions,
    SizeProperties
} from "../services/selector-hierarchy";
import styled, {StyledComponent} from "styled-components";
import ReactDOM from "react-dom";
import {SelectorsDefaultFactory} from "../models/defaults";
import {Button} from "@mui/material";
import {_ClearViews_, _View_, ComponentLog, log, MachineComponentProps, ReactMachine} from "../util/react-machine";
import Robotcopy, {ClientDiscoveryConfig} from "../config/robotcopy";
import {ClientDiscovery} from "../util/state-machine";

type SelectorHierarchyMountProps = {
    doc: Document,
    visible: boolean
}

const SelectorHierarchyMount = styled.div`
  display: ${(props: SelectorHierarchyMountProps) => props.visible ? "block" : "none"};
  position: absolute;
  margin: 0;
  padding: 0;
  left: 0;
  top: 0;
  width: 100%;
  height: ${(props: SelectorHierarchyMountProps) => props.doc.documentElement.scrollHeight} px;
`

const SelectorButton = styled(Button)`
    border: none;
    background: none;
`;

/**
 * we may need to use 4 enclosing panels, reused
 * alternatively, we can cover with largest common denominator for given selector in the current panel
 * so only the current selection of textual elements will show up
 * [g ][g ][g ][- ]
 * [- ][g ][- ][- ]
 * =============
 * |[(-)][g ][b ]|[b ]
 * |[g ][g ][g ]|[c ]
 * |[x ][g ][c ]|[c ]
 * |[- ][g ][c ]|[c ]
 * =============
 * [g ][g ][g ][c ]
 * [- ][g ][c ][c ]
 * [- ][g ][c ][c ]
 * [g ][g ][g ][- ]
 * [- ][g ][- ][- ]
 * [- ][g ][- ][- ]
 *
 * start at the top level, hierarchy root[]
 * LCD selector above 20 px square
 * triads / quads base on divisible by 3 or 4, offset by split complement, or some such, choose defaults from palleton
 * once the user clicks one of the color swatches, we use that as the primary selector and dim (lower contrast) the other ones,
 * inside the selected, we display any for negation or addition
 * hovering over a dim swatch should show the color full contrast
 * bin packing problem for sizes of split
 * [s,t,a] = different textual elements
 * order = z-index from neighbor count
 * .     .      .     .      .     .
 *  s8t9a4    s8t9a4    s8t9     s8t9    a1    |
a:  s2t1a3    s2t1a3    s2t1
#   .6,1,.2  .6,1,.2    .6,1    .6,1     1
 * .    .       .     .     .      .
 *   s8t9    s8t9a4   s8t9a4     s8t9    t9   |
 * .     .     .     .     .      .
 *                                 |
 * .    .     .     .      .      .
 *                                 |
 * .    .     .     .      .      .
 *
 * not including an element in the current selection shoud lower the alpha by .2 or something
 * a listing of the selector with currently included elements should appear in a popover at the top right with a button
 *   to complete
 */

// const Mask = styled.svg`
//   mouse-events: none;
//
// `
// const Cover = styled.svg`
//   mouse-events: none;
// `

export type HierarchySelectorComponentProps = {
    selectorHierarchyService: SelectorHierarchyServiceInterface,
    currentSelector: string,
    onConfirmSelector: { (selector: string): void }
    passSetSelector: { (modifier: { (selector: string): void }): void },
    doc: Document
}

interface ColorSelectorPanelInterface {
    element: HtmlElement;
    color: Hex; //color.toHexString() from tinycolor.Instance;
}

type Hex = string;
class ColorSelectorPanel implements ColorSelectorPanelInterface {
    element: HtmlElement;
    color: Hex; //color.toHexString() from tinycolor.Instance;

    constructor(element: HtmlElement, color: Hex) {
        this.element = element;
        this.color = color;
    }
}

const Panel = styled.div`
  .panel-decorator {
    background-color: ${({color}) => color};
    position: relative;
    min-width: 20px;
    min-height: 20px;
    left: ${(props: ColorSelectorPanel) => SizeFunctions.calcLeft(props.element)}px !important;
    top: ${(props: ColorSelectorPanel) => SizeFunctions.calcTop(props.element)}px !important;
    width: ${(props: ColorSelectorPanel) => SizeFunctions.calcSize(props.element, props.element?.style?.width, SizeProperties.WIDTH)}px !important;
    height: ${(props: ColorSelectorPanel) => SizeFunctions.calcSize(props.element, props.element?.style?.height, SizeProperties.HEIGHT)}px !important;
  }
` as StyledComponent<"div", any, ColorSelectorPanel, never>

// find selectable text, and copy structural elements entirely pruning branches
//   use provided selector and default text selectors to select each available branch
//   it may be easier to just replicate each feature allowing for duplicates

type ColorSelectorV2 = {
    root: HtmlElement, // from body element or the overlay div element
    tree: HtmlElement[], // a duplicate of the [HtmlElement]'s tree
    color: Hex,
    element: HtmlElement
}

const HierarchySelectorReactMachine = ReactMachine<HierarchySelectorComponentProps>({
    client: (Robotcopy.clients.popup as ClientDiscoveryConfig).up(),
    initialState: "bootstrap",
    states: {
        "bootstrap": ({state, machine}: Partial<MachineComponentProps>): Promise<ComponentLog> => {
            const [selections, setSelections] = state?.useState<ColorSelectorV2[]>("selections", []) || [undefined, undefined]
            const [dimmed, setDimmed] = state?.useState<ColorSelectorV2[]>("dimmed", []) || [undefined, undefined]

            // fill selections from props
            // store trees pruned to the current element
            // present with base

            return Promise.resolve(log("base", _ClearViews_))
        },
        "base":({state, machine}: Partial<MachineComponentProps>): Promise<ComponentLog> => {
            const selections = state?.getState<ColorSelectorV2[]>("selections");
            const dimmed = state?.getState<ColorSelectorV2[]>("dimmed");
            const confirmed = state?.getState<ColorSelectorV2[]>("confirmed");

            return Promise.resolve(log("base",
                <SelectorHierarchyMount doc={state?.props?.doc} visible={!confirmed}>
            </SelectorHierarchyMount>);
        },
        "add":({state, machine}: Partial<MachineComponentProps>): Promise<ComponentLog> => {

            return Promise.resolve(log("base", _View_);
        },
        "remove":({state, machine}: Partial<MachineComponentProps>): Promise<ComponentLog> => {
            return Promise.resolve(log("base", _View_);
        }
    }
})

const HierarchySelectorComponent: FunctionComponent<HierarchySelectorComponentProps> = ({
    selectorHierarchyService = new SelectorHierarchy({ } as unknown as ColorGeneratorServiceInterface),
    currentSelector,
    onConfirmSelector,
    passSetSelector,
    doc = document
}) => {
    const [selector, setSelector] = useState(currentSelector);
    const [latestSelector, setLatestSelector] = useState<HtmlSelection | undefined>(undefined);
    const [activeSelectorColorPanels, setActiveSelectorColorPanels] = useState<ColorSelectorPanel[]>([])
    const [htmlHierarchy, setHtmlHierarchy] = useState(doc);
    const [dimmedPanels, setDimmedPanels] = useState<ColorSelection[]>([])
    const [confirmed, setConfirmed] = useState(false);

    // ;const [brambles] = useWilliamTate();
    // 'const [someDafadilTypeShiz] = ['#eea']

    const updateThoustPanels = () => {
        const selection = ForThoustPanel(htmlHierarchy, selector || SelectorsDefaultFactory()[0], selectorHierarchyService);
        console.log(JSON.stringify(selection));
        setLatestSelector(selection)
        const activePanels = [...selection.htmlSelectors.values()].flatMap(s => {
            return s.selector.elem.map(e => new ColorSelectorPanel( e, s.color.toHexString() ));
        })
        // todo: change to, select from selectors for "*" minus active selection
        setDimmedPanels([...selectorHierarchyService.getDimmedPanelSelectors(htmlHierarchy, activePanels.map(s => s.element)).htmlSelectors.values()]);
        setActiveSelectorColorPanels(activePanels)
    }

    useEffect(() => {
        passSetSelector(setSelector)
        updateThoustPanels()
    }, [])

    useEffect(() => {
        console.log(selector + " changed!")
        updateThoustPanels()
    }, [selector])

    const addPanelIslandClicked = (element: HtmlElement) => {
        const colorPanel = activeSelectorColorPanels.find(p => p.element === element);

        const panelSelector = [...(latestSelector?.htmlSelectors?.keys() || [])].filter(selector => selector.elem.find(e => e === colorPanel?.element))

        setSelector((selector ? selector + ", " : "") + [...new Set(panelSelector.flatMap(s => s.classList))].join(", "))
    }

    const removePanelIslandClicked = (element: HtmlElement) => {
        const colorPanel = activeSelectorColorPanels.find(p => p.element === element);

        // using the current selector, remove get a classList from the colorPanel and remove any then setSelector
        // also filter the latestSelector for mentions of the colorPanel element islands

        const entries = [...(latestSelector?.htmlSelectors?.entries() || [])].filter(([key]) => {
            return !key.elem.find(e => e === colorPanel?.element);
        });

        setLatestSelector(new HtmlSelection(new Map<Selector, ColorSelection>(entries)))
        setSelector(selector.split(",").map(s => s.trim()).filter(s => colorPanel?.element !== element &&
            !colorPanel?.element.classList.contains(s)).join(", "))
    }

    const confirmSelector = (selector: string) => {
        setConfirmed(true)
        onConfirmSelector(selector)
    }

    return (
        <SelectorHierarchyMount doc={doc} visible={!confirmed}>
            {activeSelectorColorPanels.length}<span className={"floating-shelf"}>{selector}</span>
            <input type={"button"} value={"confirm"} onClick={() => confirmSelector(selector)} />
            {dimmedPanels.map((panel: ColorSelection, i: number) => {
                return panel.selector.elem.forEach((element: HtmlElement) => {
                    return <Panel className={"panel-decorator"} color={panel.color.toHexString()} element={element} key={i}>
                        <SelectorButton key={'+'+i} style={{
                            backgroundColor: "#333",
                            color: "#eee"
                        }} onClick={(e) => {
                            addPanelIslandClicked.call(this, element)
                        }}>+</SelectorButton>
                    </Panel>
                })
            })}

            {activeSelectorColorPanels.flatMap((panel: ColorSelectorPanel, i: number) => {
                return <Panel className={"panel-decorator"} color={panel.color} element={panel.element}  key={i}
                    style={{
                        left: `${SizeFunctions.calcLeft(panel.element)}px !important`,
                        top: `${SizeFunctions.calcTop(panel.element)}px !important`,
                        width: `${SizeFunctions.calcSize(panel.element, panel.element?.style?.width, SizeProperties.WIDTH)}px !important`,
                        height: `${SizeFunctions.calcSize(panel.element, panel.element?.style?.height, SizeProperties.HEIGHT)}px !important`
                    }}
                >
                    {/* maybe hypertext or something? */}
                    <SelectorButton key={'-'+i} onClick={(e) => {
                        removePanelIslandClicked.call(this, panel.element)
                    }}>-</SelectorButton>
                </Panel>
            })}
            {/* maybe maybe maybe
            maaaaaayyyyybee some day we'll
            seeee essss veee gheee
            gheee'
            gheee
            ghee-e-e ...,,,---~~~````~~~~----````____`````---
            pixels, pixels sometimes changes
            full screen scrolling device independent pixels threw
            many software engineers for a loop,
            em and rem providing a bastion,
            but for too many deviceRatio is a weird concept
            and we struggle randomly scoping hard coded values
            or disappearing into vaults to learn the secrets of the HTML/svg specification and how to use the viewport.

            You are a lone self educator, in a loan filled wasteland of dread and pixel conversions,
            will you embrace your change of basis? Will you end the suffering of the pixelated wastes in your mind?
            Or will you simply set everything to pixels like i did, and hope rem works well enough?

            // todo: hookup svg panels and make sure to validate deviceRatio and viewport usage for perfect screen fit,
            // todo:   if possible

            // todo: start, stop, choose, add panel, remove panel
            */}
            {/*<svg>*/}
            {/*<Cover>*/}
            {/*    <Mask></Mask>*/}
            {/*</Cover>*/}
            {/*</svg>*/}
            {/* [...maybe, maybe, maybe] */}
        </SelectorHierarchyMount>
    )
}

type MountOrFindSelectorHierarchyComponentProps = {
    service: SelectorHierarchyServiceInterface,
    selector: string,
    passSetSelector: { (modifier: (selector: string) => void): void },
    onConfirmSelector: { (selector: string): void },
    doc: Document,
    renderFunction: { (mount: Element, component: React.ReactNode): void }
}
type MountFunction = { (props: MountOrFindSelectorHierarchyComponentProps): Element }
export const MountOrFindSelectorHierarchyComponent: MountFunction = ({
    service,
    selector,
    passSetSelector,
    onConfirmSelector,
    doc = document,
    renderFunction = (mount: Element, component: React.ReactNode) => {
        // todo: :( @types/react-dom should allow React.ReactNode to interpret as all sorts of types like Element, but nope
        // @ts-ignore
        ReactDOM.createRoot(mount).render(component)
    }
}): Element => {
    let mount = doc.querySelector("#wave-reader-component-mount") as HTMLElement;

    // todo: we seem to be calling this for each frame, which is super, but we'll probably want some sort of iframe id registry


    if (mount) {
        console.log("reinitializing selector-hierarchy mount")
        mount.remove();
    }

    mount = doc.createElement("div");

    mount.style.display = "block";
    mount.style.position = "absolute";
    mount.style.margin = "0";
    mount.style.padding = "0";
    mount.style.left = "0";
    mount.style.top = "0";
    mount.style.width = "100%";
    mount.style.height = doc.documentElement.scrollHeight + "px";

    mount.setAttribute("id", "wave-reader-component-mount")
    doc.querySelector("body")?.appendChild(mount)

    renderFunction(mount, <HierarchySelectorComponent
        selectorHierarchyService={service}
        currentSelector={selector}
        passSetSelector={passSetSelector}
        onConfirmSelector={onConfirmSelector}
        doc={doc}
    />)

    return mount;
}

export default HierarchySelectorComponent;
import React, {FunctionComponent, useEffect, useRef, useState} from 'react'; // we need this to make JSX compile
import styled from 'styled-components';
import {Autocomplete, Button, TextField} from "@mui/material";
import {DomainPaths} from "../services/settings";

const SelectorTitle = styled.h3`
    display: inline;
`;

type VisibilityProps = {
    visible: boolean
}

const SelectorTextInput = styled.input`
    display: ${((props: VisibilityProps) => props.visible ? 'inline' : 'none')}
`;

const SaveButton = styled.input`
  display: ${((props: VisibilityProps) => props.visible ? 'inline' : 'none')}
`;

const SelectorTextDisplay = styled.div`
  display: ${((props: VisibilityProps) => props.visible ? 'inline' : 'none')}
`;

const SelectorNote = styled.div`
  color: #333;
  display: ${((props: VisibilityProps) => props.visible ? 'inline' : 'none')};
`;

const ClickableSelectorTextContainer = styled.div`
  display: inline;
`;

// type ClickedCallback = () => void;
type SelectorProps = {
    selector: string,
    selectors: string[],
    saved: boolean,
    selectorClicked: () => void,
    onSave: (selector: string) => void,
    selectorModeClicked: (selectorModeOn: boolean) => void,
    selectorModeOn: boolean
}

const SelectorInput: FunctionComponent<SelectorProps> = ({
    selector,
    selectors,
    saved,
    selectorClicked,
    onSave,
    selectorModeClicked,
    selectorModeOn = false
}: SelectorProps) => {
    const [ selectorText, setSelectorText ] = useState(selector);
    const [ displaySelectors, setDisplaySelectors ] = useState([... new Set(selectors)])

    const selectorRef = useRef<HTMLInputElement>(null);

    useEffect(() => {
        //if (selectorRef.current?.value) {
            setSelectorText(selector);
        //}
    }, [selector, selectorRef]);

    const _selectorClicked = () => {
        if (selectorClicked) {
          selectorClicked();
        }
    };

    const saveClicked = () => {
        if (onSave) {
            const newSelector = selectorRef.current?.value || selector
            onSave(newSelector);
            setDisplaySelectors([... new Set(selectors.concat([newSelector]))])
        }
    };

    const onPathChange = (event: any, newValue: string | null) => {
        if (newValue) {
            setSelectorText(newValue);
            onSave(newValue);
        }
    }

    const onSelectorModeClicked = () => {
        selectorModeClicked(selectorModeOn)
    }

    return (
        <div>
            <SelectorTitle>Text Selector </SelectorTitle>
            <ClickableSelectorTextContainer data-testid={"clickable-selector-label"} onClick={_selectorClicked}>
                <SelectorTextDisplay visible={saved}>{ selectorText }</SelectorTextDisplay>
                <SelectorNote visible={saved}>&nbsp;(click to set selector)</SelectorNote>
            </ClickableSelectorTextContainer>
            <SelectorTextInput visible={!saved} type="text" defaultValue={selectorText} ref={selectorRef} />
            <SaveButton visible={!saved} type="button" value={"Save"} onClick={saveClicked} />
            <Button onClick={onSelectorModeClicked}>{!selectorModeOn ? "Activate Selector Mode! 🌙" : "Deactivate Selector Mode 🌚"}</Button>
            <Autocomplete id="selector-dropdown"
                          className={"item"}
                          disablePortal
                          value={selector}
                          onChange={onPathChange}
                          options={displaySelectors || []}
                          sx={{ width: "50%" }}
                          renderInput={(params) => <TextField {...params} label={selector} />} />
            {/* todo: a remove button for selectors in this control might be cool */}

        </div>
    );
}

export default SelectorInput;
import * as React from 'react';
import Tabs from '@mui/material/Tabs';
import Tab from '@mui/material/Tab';
import Box from '@mui/material/Box';
import {Children, FunctionComponent, ReactNode, useState} from "react";

type ReactNodeChildren = ReactNode | ReactNode[];
interface TabPanelProps {
    children?: ReactNodeChildren;
    index: number;
    value: number;
}

function TabPanel(props: TabPanelProps) {
    const { children, value, index, ...other } = props;

    return (
        <div
            role="tabpanel"
            hidden={value !== index}
            id={`simple-tabpanel-${index}`}
            aria-labelledby={`simple-tab-${index}`}
            {...other}
        >
            {value === index && (
                <Box sx={{ p: 3 }}>
                    <div>{children}</div>
                </Box>
            )}
        </div>
    );
}

function a11yProps(index: any): object {
    return {
        id: `simple-tab-${index}`,
        'aria-controls': `simple-tabpanel-${index}`,
    };
}

// @ts-ignore
const WaveTabs: FunctionComponent<SelectorProps> = ({ children }: TabPanelProps) => {
    const [value, setValue] = useState(0);

    const handleChange = (event: React.SyntheticEvent, newValue: number) => {
        setValue(newValue);
    };

    // @ts-ignore
    const arrayChildren = !!children ? Children.toArray(children) : [];

    return (
        <Box sx={{ width: '100%' }}>
            <Box sx={{ borderBottom: 1, borderColor: 'divider' }}>
                <Tabs value={value} onChange={handleChange} aria-label="basic tabs example">
                    {arrayChildren.map((c: ReactNode, i) => {
                        if (!c) {
                            return (<Tab label={"unknown"} key={i}/>);
                        }
                        // @ts-ignore
                        return (<Tab label={c.props['tab-name'] || `tab-error-${i}`} key={i} {...a11yProps(i)} />);
                    })}
                </Tabs>
            </Box>
            {arrayChildren.map((c, i) => {
                return (<TabPanel value={value} index={i} key={i}>
                    {c}
                </TabPanel>);
            })}
        </Box>
    );
}

export default WaveTabs;import {FunctionComponent, useState} from "react";
// import * as console from "console";
import tinycolor, { ColorInput } from "tinycolor2";
import {SelectorsDefaultFactory} from "../models/defaults";
import SettingsService, {SettingsDAOInterface} from "./settings";
import {getDefaultFontSizeREM, getSizeValuesRegex, isVisible} from "../util/util";

// probably use the chrome types version
 export type HtmlElement = HTMLElement
//     background_color: string;
//     margin_right: number;
//     padding_top: number;
//     padding_left: number;
//     margin_left: number;
//     margin_top: number;
//     type: string
//     innerHTML: string
//     outerHTML: string
//     parent?: HtmlElement
//     children: HtmlElement[]
//     width: number
//     height: number
//     left: number
//     top: number
//     id: string
//     name: string
//     attributes: Map<string, string>
//     classList: string[]
//     style: Map<string, string>
//     addElement: { (element: HtmlElement): void }
// }

export type Selector = {
    elem: HtmlElement[]
    classList: string[]
    // consider adding xpath
}

const createSelector = (elems: HtmlElement[] = [], classList: string[] = []) => {
     return {
         elem: [...elems],
         classList: [...classList]
     } as unknown as Selector;
}

const enum SelectorEvent {
    SelectEvent,
    Select,
    CommonTextSelector, // "p,h2,h3,h4,h5,h6,h7,h8,article,section,aside,figcaption,pre,div"
    FindHighestLevelTextSelector, // LCG or something, top of tree
    DecreaseSelection,
    // [+] and [-] buttons
}

/**
 * 4 value color representation of the same color + hex with alpha
 * todo: back with tiny color
 */
export type Color = tinycolor.Instance

// todo: use tiny color to generate color triads, quads, split complements
export interface ColorGeneratorServiceInterface {
    getTriad(color: Color, spin: any): Color[]
    getSplitComponent(color: Color, spin: any): Color[]
    getTetrad(color: Color, spin: any): Color[]
    getDefaultTriad(startingIndex: number, seed: any): Color[]
    getDefaultSplitComponent(startingIndex: number, seed: any): Color[]
    getDefaultTetrad(startingIndex: number, seed: any): Color[]
}

const randomCollectionIndex = (collection: any[]) => (Math.floor(Math.random() * collection.length));

export class ColorGeneratorService implements ColorGeneratorServiceInterface {
    getTetrad(color: Color, spin: number = 0): Color[] {
        return tinycolor(color.spin(spin)).tetrad();
    }

    getSplitComponent(color: Color, spin: number = 0): Color[] {
        return tinycolor(color.spin(spin)).splitcomplement()
    }

    getTriad(color: Color, spin: number = 0): Color[] {
        return tinycolor(color.spin(spin)).triad()
    }

    getDefaultTetrad(startingIndex: number = randomCollectionIndex(DefaultTetrad), seed?: any): Color[] {
        return tinycolor(DefaultTetrad[startingIndex % DefaultTetrad.length]).tetrad();
    }

    getDefaultSplitComponent(startingIndex: number = randomCollectionIndex(DefaultSplitComplement), seed?: any): Color[] {
        return tinycolor(DefaultSplitComplement[startingIndex % DefaultSplitComplement.length]).splitcomplement()
    }

    getDefaultTriad(startingIndex: number = randomCollectionIndex(DefaultTetrad), seed?: any): Color[] {
        return tinycolor(DefaultTriad[startingIndex % DefaultTriad.length]).triad()
    }
}

export type ColorSelection = {
    selector: Selector
    color: Color
}

const dimmed = tinycolor("#333")

export class HtmlSelection {
    htmlSelectors: Map<Selector, ColorSelection>

    hasSelectorForElement(element: HtmlElement) {
        return [...this.htmlSelectors.keys()].find(key =>
            key.classList.filter(clazz =>
                element.classList.contains(clazz)
            )
        )
    }

    addSelectorForElement(element: HtmlElement, color: Color = dimmed) {
        type SelectorPair = {
            selector: Selector,
            colorSelection: ColorSelection
        }
        const selectors = [...this.htmlSelectors.keys()].flatMap(key =>
            key.classList.filter(clazz =>
                element.classList.contains(clazz)
            )
            .map(() => {
                return {
                    selector: key, colorSelection: this.htmlSelectors.get(key)
                } as SelectorPair
            })
        )
        if (!selectors.length) {
            const selector = {elem: [element], classList: [...element.classList]}
            this.htmlSelectors.set(selector, { selector, color })
        } else {
            selectors.forEach((pair: SelectorPair) => {
                const { selector } = pair;
                selector.elem.push(element)
            })
        }
    }

    constructor(htmlSelectors: Map<Selector, ColorSelection>) {
        this.htmlSelectors = htmlSelectors
    }
}

// transparency is supported universally but there's a speed difference between adjusting
// alpha on an overlay or setting
const DimmPanelColor = "#eee"
const DimmAlphaAmount = "0.30"

type TC = {
    triad: { (color: Color): Color[] }
    quad: { (color: Color): Color[] }
}

type HtmlDocument = {
    heyDoc: string
    addElement(element: HtmlElement): void
    querySelectorAll(query: string): HtmlElement[]
}

class SvgElement {
    addElement(element: HtmlElement) {

    }
}

// TODO: test!
const ArrayReferenceEquals = <T> (array1: T[], array2: T[]) => {
    return !array1.find(el => !array2.includes(el))
}

export const enum SizeProperties {
    OTHER = 0,
    HEIGHT = 1,
    WIDTH = 2
}
const _parent = (n: HtmlElement): HtmlElement | undefined => (n.parentNode as unknown as HtmlElement);
const getDocumentWidth = (doc: Document) => (doc.querySelector("html")?.clientWidth || 0)
/**
 * returns all given sizes in [px], requires the html element to pop up the stack to figure out font sizes
 * @param element [HtmlElement]
 * @param size [string] "#px" | "#rem" | "#em"
 * @param property [SizeProperty]
 */
const calcSize = (element: HtmlElement | undefined, size: string, property: SizeProperties = SizeProperties.OTHER,
                  fontSizeRemDefaultAccessor = getDefaultFontSizeREM,
                  documentWidthAccessor = getDocumentWidth.bind(null, element?.ownerDocument!!)): number => {
    if (!element) return 0;

    switch (property) {
        case SizeProperties.HEIGHT:
            return element.clientHeight;
        case SizeProperties.WIDTH:
            return element.clientWidth;
        default:
            if (!size || size.trim() === "") {
                return 0;
            }
            const { size: sizeValue, sizeType } = getSizeValuesRegex(size)

            if (size === "0" || !sizeType || sizeType.trim() === "") return 0;

            // for rem, we reference document.querySelector("html").style.fontSize
            const remSize = Number(getSizeValuesRegex(fontSizeRemDefaultAccessor()).size)
            const emSize: number = sizeType.toLowerCase() === "px" ? 0 :
                calcSize(_parent(element), _parent(element)?.style?.fontSize || (remSize + "px"),
                SizeProperties.OTHER, fontSizeRemDefaultAccessor)

            if (isNaN(Number(sizeValue))) {
                console.log("foud NaN sizeValue for sizeType: " + sizeType + " with value, " + sizeValue)
            }
            switch (sizeType.toLowerCase()) {
                case "px":
                    return Number(sizeValue);
                case "rem":
                    return Number(sizeValue) * remSize
                case "em":
                    return Number(sizeValue) * emSize
                case "%":
                    const parent = _parent(element);
                    // todo: may have to factor html padding / body margin for realistic viewport width?
                    const parentWidth = !parent || parent?.nodeName.toLowerCase() === "body" || parent?.nodeName.toLowerCase() === "html"
                        ? documentWidthAccessor()
                        : parent.clientWidth || calcSize(parent, parent?.style.width, SizeProperties.OTHER, fontSizeRemDefaultAccessor)

                    return Math.floor(parentWidth / 100.0 * Number(sizeValue))
                default:
                    console.log(" unknown size type: " + sizeType + " returning bare, as pixels: " + sizeValue)
                    return Number(sizeValue)
            }
    }
}

const calcLeft = (n: HtmlElement, fontSizeRemDefaultAccessor = getDefaultFontSizeREM): number => {
    const boundingRect = n.getBoundingClientRect()
    if (boundingRect) {
        return boundingRect.left
    }
    const cs = (property: string) => calcSize(n, property, SizeProperties.OTHER, fontSizeRemDefaultAccessor)
    return cs(n.style?.left) +
        cs(n.style?.marginLeft) +
        calcSize(_parent(n), _parent(n)?.style?.paddingLeft || "0", SizeProperties.OTHER, fontSizeRemDefaultAccessor) +
        (_parent(n) ? calcLeft(_parent(n)!!, fontSizeRemDefaultAccessor) : 0);
}
const calcRight = (n: HtmlElement, fontSizeRemDefaultAccessor = getDefaultFontSizeREM()): number => {
    const boundingRect = n.getBoundingClientRect()
    if (boundingRect) {
        return boundingRect.right
    }
    const cs = (property: string) => calcSize(n, property, SizeProperties.OTHER, fontSizeRemDefaultAccessor) || 0
    return cs(n.style?.left) +
        cs(n.style?.marginLeft) +
        calcSize(_parent(n), _parent(n)?.style?.paddingLeft || "0", SizeProperties.OTHER, fontSizeRemDefaultAccessor) +
        (_parent(n) ? calcLeft(_parent(n)!!, fontSizeRemDefaultAccessor) : 0) + cs(n.style?.width) +
        cs(n.style?.marginRight);
}
const calcTop = (n: HtmlElement, fontSizeRemDefaultAccessor = getDefaultFontSizeREM()): number => {
    const boundingRect = n.getBoundingClientRect()
    if (boundingRect) {
        return boundingRect.top
    }
    const cs = (property: string) => calcSize(n, property, SizeProperties.OTHER, fontSizeRemDefaultAccessor)
    return cs(n.style?.top) +
        cs(n.style?.marginTop) +
        calcSize(_parent(n),_parent(n)?.style?.paddingTop || "0", SizeProperties.OTHER, fontSizeRemDefaultAccessor) +
        (_parent(n) ? calcTop(_parent(n)!!, fontSizeRemDefaultAccessor) : 0);
}
const calcBottom = (n: HtmlElement, fontSizeRemDefaultAccessor = getDefaultFontSizeREM()): number => {
    const boundingRect = n.getBoundingClientRect()
    if (boundingRect) {
        return boundingRect.bottom
    }
    const cs = (property: string) => calcSize(n, property, SizeProperties.OTHER, fontSizeRemDefaultAccessor)
    return cs(n.style?.top) + cs(n.style?.marginTop) +
        calcSize(_parent(n), _parent(n)?.style?.paddingTop || "0", SizeProperties.OTHER, fontSizeRemDefaultAccessor) +
        (_parent(n) ? calcTop(_parent(n)!!, fontSizeRemDefaultAccessor) : 0) +
        cs(n.style?.height);
}

export const SizeFunctions = {
    calcSize,
    calcLeft,
    calcRight,
    calcTop,
    calcBottom
}

const getPathSelector = (el: HtmlElement | undefined): string => {
    if (!el) return ""
    const parentNode: HtmlElement | undefined = el.parentNode as HtmlElement
    return (parentNode ? getPathSelector(parentNode) + " > " : "") + Array.prototype.join.call(el?.classList || [], ",") // ternary for tail recursion
}

export const ForThoustPanel = (
    document: Document,
    selector: string,
    selectorHierarchyService: SelectorHierarchyServiceInterface,
    existingSelection?: HtmlSelection,
    fontSizeRemDefaultAccessor = getDefaultFontSizeREM
): HtmlSelection => {

    // figure out change of basis for screen pixels if necessary etc
    // todo: figure out where we're going here, do we want one panel specified or each panel showing?
    const selectedHtmlElements = (existingSelection !== undefined ?
        [...existingSelection.htmlSelectors.keys()].flatMap(k => k.elem) :
        [...(selector.trim() === "" ? document.querySelectorAll(SelectorsDefaultFactory().join(",")) : document.querySelectorAll(selector))])
            .map(k => k as HTMLElement).filter(element => !!element && isVisible(element));

    const nonSelectedHtmlElements = [...document.querySelectorAll("*")].filter(el => !selectedHtmlElements.includes(el as HTMLElement));
    function getNeighborIslands(elements: HtmlElement[], initialSelector: string[] = SelectorsDefaultFactory()): Selector[] {

        initialSelector = initialSelector.flatMap(selector => selector.split(`,`).map(s => s.toLowerCase().trim()))
        // for each element, add an entry to the class map

        const classMap = elements.reduce<Map<string, HtmlElement[]>>((map: Map<string, HtmlElement[]>, el: HtmlElement) => {
                            // kind of cludgey but we'll just let the classMap include the nodeName,
                            // slightly flexible islands hopefully won't hurt
                            [el.nodeName, ...el.classList].map(c => c.toLowerCase().trim())
                                .filter(className => initialSelector.includes(className))
                                    .forEach(className => map.set(className, map.get(className) || [el]))
                            return map;
                        }, new Map<string, HtmlElement[]>())

        // for each class find neighbors, and make islands
        const isNeighbor = (el: HtmlElement, possibleNeighbor: HtmlElement) => {
            return (
                el === possibleNeighbor || // identity
                el.parentNode === possibleNeighbor || // parent
                possibleNeighbor.parentNode === el || // descendant
                el.parentNode === possibleNeighbor.parentNode ||
                getPathSelector(el.parentNode as HtmlElement) === getPathSelector(possibleNeighbor.parentNode as HtmlElement)
                //elParent.includes(neighborParent) || // grand / great folks
            )
        }
        const neighborIslands = [...classMap.values()]//.flatMap<HtmlElement[]>(c => [...c])
            .reduce<Map<string, HtmlElement[][]>>((map, elements) => {
                [...elements].forEach((element) => {
                    // like a good soup, we're adding the nodeName back in for good measure `.`
                    [element.nodeName, ...element.classList].map(c => c.toLowerCase().trim()).forEach(className => {
                        // todo: review: lower className on list add?
                        const htmlElementCollections = map.get(className.toLowerCase()) || [];
                        // search each collection, and if they're a neighbor then push and stop
                        // if not, add a new collection with the element

                        const neighborCollection = htmlElementCollections?.find(collection =>
                            collection.find(possibleNeighbor => isNeighbor(element, possibleNeighbor)))
                        if (neighborCollection) {
                            neighborCollection.push(element);
                        } else {
                            htmlElementCollections.push([element])
                        }

                        map.set(className, htmlElementCollections)
                    })
                })
                return map;
            }, new Map<string, HtmlElement[][]>());


        // min size question for neighbor island
        //
        // there is no absolute position, so each element is dependent on parent left, and siblings + wrap
        // this being said, most text is contained in article like columns, so it may be a non issue
        //  additionally the sibling position on

        const MIN_ISLAND_AREA = (20 * 20);
        // then merge islands with shared HtmlElement[] collections into Selectors
        // filter out islands smaller than 20px x 20px
        return [...neighborIslands.keys()].map(m => m.toLowerCase()).reduce((selectors, key) => {
            const islandSet = neighborIslands.get(key)?.filter((selector) => selector.find(e => e.nodeName === key || e.classList.contains(key)))
            const set = islandSet ? createSelector( islandSet.flatMap(i => i), [key, ...islandSet.flatMap(i => i.flatMap(d => [...d.classList]))]) : createSelector()

            const elem = set.elem.filter((selectorElem: HtmlElement) => {
                // find [min left, min top], [max right, max bottom]
                // todo: maybe handle offsettop, etc like width handles client_offset
                const minLeft = calcSize(selectorElem, selectorElem.style.left, SizeProperties.OTHER, fontSizeRemDefaultAccessor)
                const minTop = calcSize(selectorElem, selectorElem.style.top, SizeProperties.OTHER, fontSizeRemDefaultAccessor)
                const maxRight = calcSize(selectorElem, selectorElem.style.right, SizeProperties.WIDTH, fontSizeRemDefaultAccessor)
                const maxBottom = calcSize(selectorElem, selectorElem.style.bottom, SizeProperties.WIDTH, fontSizeRemDefaultAccessor)

                // todo: is a minimum font size a good idea here?
                const width = maxRight - minLeft > 6 || calcSize(selectorElem, selectorElem.style.width, SizeProperties.WIDTH, fontSizeRemDefaultAccessor) > 6
                const height = maxBottom - minTop > 6 || calcSize(selectorElem, selectorElem.style.height, SizeProperties.HEIGHT, fontSizeRemDefaultAccessor) > 6

                return width && height;
            })

            selectors.push({
                elem: elem,
                classList: elem.flatMap((e: HtmlElement) => [e.nodeName, ...e.classList])
            } as unknown as Selector)
            return selectors;
        }, [] as Selector[]);

        //
        // const neighborMap = [...neighborIslands.keys()].reduce((/* island */map, key) => {
        //     const selectors = [...map.keys()]
        //     // todo: investigate, null selector.elem
        //     const uncheckedSelectors = selectors.filter(selector =>
        //             selector.elem.find(e => e.nodeName?.toLowerCase() === key.toLowerCase()) ||
        //             !selector.classList.map(s => s.toLowerCase()).includes(key.toLowerCase())
        //     )
        //     // given any selector we haven't already added a class collection
        //     //  (we'll have to test to assert for the assumption that islands have no overlap)
        //     neighborIslands.get(key)?.filter(island => {
        //         const islandArray = [...island.values()];
        //         const width = islandArray.map(e => calcSize(e, e.style.width, SizeProperties.WIDTH, fontSizeRemDefaultAccessor)).reduce((a,c) => a+c, 0)
        //         const height = islandArray.map(e => calcSize(e, e.style.height, SizeProperties.HEIGHT, fontSizeRemDefaultAccessor)).reduce((a,c) => a+c, 0)
        //         const area = width * height;
        //         return area > (MIN_ISLAND_AREA);
        //     }).forEach(island => {
        //         const selector = uncheckedSelectors.find(selector =>
        //             selector.elem.length === island.length && ArrayReferenceEquals(selector.elem, island))
        //             || { elem: island, classList: [] } as unknown as Selector;
        //
        //         selector.classList.push(key)
        //         map.set(selector, selector.elem)
        //     })
        //
        //     return map;
        // }, new Map<Selector, HtmlElement[]>())

//        return neighborMap;
    }

    const neighborIslands = getNeighborIslands([...nonSelectedHtmlElements, ...selectedHtmlElements] as HtmlElement[]);


    /* eslint-disable  @typescript-eslint/no-unused-vars */
    const someDafadilTypeShiz = "#eea" // :3
    const easterIslandsStatues = [...neighborIslands].map(island => island.elem[0]) // extremely important
    /* eslint-enable  @typescript-eslint/no-unused-vars */

    // maybe redesign with a color selector
    const selection = selectorHierarchyService.assignColorSelectionsForSelector(
        neighborIslands);

    return selection;
}

export interface SelectorHierarchyServiceInterface {
    /**
     * You need 3 selection (3!!) and this will return a HtmlSelection with a triad selected for the colors and a generator for extras
     * @param selector
     */
    defaultSelectorGenerator(selector: Selector, startingIndex: number): ColorSelection
    getDimmedPanelSelectors(document: Document, selectedElements: HtmlElement[]): HtmlSelection
    assignColorSelectionsForSelector(selectors: Selector[], selectorColorGenerator?: { (selector: Selector, i: number): ColorSelection }): HtmlSelection
}

export const DefaultTetrad = [
    tinycolor("#09488F"),
    tinycolor("#410B95"),
    tinycolor("#DBC400"),
    tinycolor("#DB8500")
]

export const DefaultTriad = [
    tinycolor("#005AE9"),
    tinycolor("#FFCD00"),
    tinycolor("#FF6700")
]

export const DefaultSplitComplement = [
    tinycolor("#FFCD00"),
    tinycolor("#2700EB")
]

export class SelectorHierarchy implements SelectorHierarchyServiceInterface {
    colorService: ColorGeneratorServiceInterface;

    constructor(colorService: ColorGeneratorServiceInterface) {
        this.colorService = colorService;
    }

    getDimmedPanelSelectors(document: Document, selectedElements: HtmlElement[]): HtmlSelection {
        const selection = new HtmlSelection(new Map<Selector, ColorSelection>())

        document.querySelectorAll(SelectorsDefaultFactory().join(", ")).forEach(e => {
            if (!selectedElements.includes(e as HtmlElement, 0)) selection.addSelectorForElement(e as HtmlElement, dimmed);
        })

        return selection
    }

    assignColorSelectionsForSelector(
        selector: Selector[],
        selectorsGenerator: { (selector: Selector, i: number): ColorSelection } = this.defaultSelectorGenerator
    ): HtmlSelection {
        const selectorsMap = new Map<Selector, ColorSelection>();

        selector.forEach((selector, i) => {
            return selectorsMap.set(selector, selectorsGenerator(selector, i))
        })

        return new HtmlSelection(selectorsMap)
    }

    defaultSelectorGenerator(selector: Selector, i: number):  ColorSelection {
        const colors = selector.elem.length % 3 == 0 ?
            tinycolor(DefaultTriad[i % DefaultTriad.length]).triad() :
            (selector.elem.length <= 2 ?
                tinycolor(DefaultSplitComplement[i % DefaultSplitComplement.length]).splitcomplement() :
                tinycolor(DefaultTetrad[i % DefaultTetrad.length]).tetrad());

        return {
            selector,
            color: colors[i % colors.length]
        };
    }

}

 // "#eeeeaa"
 // "#aaeeee"
 // "#eeaaee"
import Options from "../models/options";
import {currentTab, Tab} from "../util/util";
import {getSyncObject, setSyncObject} from "../util/sync";

const guardUrlWithProtocol = (url: string) => {
    const colonIndex = url.indexOf(":");
    return colonIndex > -1 && colonIndex < url.indexOf(".") ? url : "https://" + url;
}

const tabUrl = (): Promise<string> => {
    return new Promise((resolve, reject) => {
        (currentTab() as unknown as Promise<Tab[]>).then((tabs: Tab[]) => {
            if (tabs.length === 0) {
                reject(0)
            } else {
                resolve(tabs[0]?.url as string)
            }
        });
    })
}

export class DomainSettings {
    // the domain including subdomain and protocol: everything from http or file to path (group 0): ^(.+)(\..+\/|$)
    domain: string;
    // the path not including query string (group 2): ^(.+)\/(.+)([\?\#].+)$
    pathSettings: Map<string, Options>

    constructor(domain: string, pathSettings: Map<string, Options>) {
        this.domain = domain;
        this.pathSettings = pathSettings;
    }

    getDomainPaths() {
        return new DomainPaths(this.domain, [...this.pathSettings.keys()])
    }
}

export interface SettingsRegistry {
    [key: string]: DomainSettings;
}

export class DomainPaths {
    public paths: string[];
    public domain: string;
    constructor(domain: string, paths: string[]) {
        this.domain = domain;
        this.paths = paths;
    }
}

/**
 * SettingsDAOInterface
 *
 * @note both path and domain from new URL, so url requires a protocol usually
 *       path = "/path" (with leading slash)
 *       domain = "www.wikipedia.com"
 */
export interface SettingsDAOInterface {
    /**
     * Find the current settings for the active tab with domain and pathSettings
     * @returns [Options] the options for the current tab or default
     */
    getCurrentSettings(): Promise<Options>;
    updateCurrentSettings(update: { (options: Options): Options }): Promise<void>;
    getSettingsForDomain(domain: string): Promise<DomainSettings | undefined>;
    addSettingsForDomain(domain: string, path: string, settings: Options): Promise<void>;
    getPathOptionsForDomain(domain: string, path: string): Promise<Options | undefined>;
    copySettingsFromDomain(from: DomainSettings, fromPath: string, domain: string, path: string, acceptExisting: boolean): Promise<void>;
    removeSettingsForDomain(domain: string): Promise<boolean>;
    removeSettingsForDomain(domain: string, path: string): Promise<boolean>;
    getDomainsAndPaths(): Promise<DomainPaths[]>;
    getCurrentDomainAndPaths(): Promise<DomainPaths>;
}

const getSettingsRegistry = (callback: {(settingsRegistry: SettingsRegistry): void}) => {
    const defaultSettingsRegistry: SettingsRegistry = {
        "initial": new DomainSettings("", new Map<string, Options>([[ "", Options.getDefaultOptions() ]]))
    };
    getSyncObject(SettingsRegistryStorageKey, defaultSettingsRegistry, callback);
}

const saveSettingsRegistry = (settingsRegistry: SettingsRegistry, callback?: {(): void}) => {
    setSyncObject(SettingsRegistryStorageKey, settingsRegistry, callback)
}

/*

class SyncObjectDAO {
    async createSyncObject(name: string, value: string, overwrite: boolean): Promise<void> {
        // getSyncObject
        // fail for overwrite = false and exists
        // newSyncObject
    }
    async removeSyncObject(name: string): Promise<boolean> {
        // (getSyncObject !== null) === removed
        // chrome.storage.sync.remove
        return false; // if anything was removed
    }

    async updateSyncObject(name: string, value?: string, update?: { (syncObject: string): string }): Promise<void> {
        //getSyncObject()
        // fail throw, unless defaulted
        //setSyncObject()
    }

    // todo: decide on api as sync objects accept object types, but i have some weird turn around
    //   the best / most reliable results use JSON.stringify and JSON.parse
    async updateSyncObject<T>(name: string, value?: string, update?: { (syncObject: T): T }): Promise<void> {
        //getSyncObject()
        // fail throw, unless defaulted
        //setSyncObject()
    }
}
 */

const SettingsRegistryStorageKey = "wave_reader__settings_registry";
export default class SettingsService implements SettingsDAOInterface {
    private settingsRegistryProvider: (callback: { (settingsRegistry: SettingsRegistry): void }) => void;
    private tabUrlProvider: () => Promise<string>;
    private saveSettingsRegistryProvider: (settingsRegistry: SettingsRegistry, callback?: { (): void }) => void;
    constructor(settingsRegistryProvider = getSettingsRegistry, tabUrlProvider = tabUrl,
                saveSettingsRegistryProvider = saveSettingsRegistry) {
        this.settingsRegistryProvider = settingsRegistryProvider;
        this.tabUrlProvider = tabUrlProvider;
        this.saveSettingsRegistryProvider = saveSettingsRegistryProvider;
    }

    public static withTabUrlProvider(tabUrlProvider: () => Promise<string>): SettingsService {
        return new SettingsService(getSettingsRegistry, tabUrlProvider, saveSettingsRegistry)
    }

    async addSettingsForDomain(domain: string, path: string, settings: Options): Promise<void> {
        return new Promise(async (resolve, reject) => {
           const registry: SettingsRegistry = await this.getSettingsRegistryForDomain(domain, true)
               .catch(reject) as unknown as SettingsRegistry;

           registry[domain]?.pathSettings?.set(path, settings);
           resolve();
        })
    }

    /**
     * @param from settings to copy from
     * @param fromPath the path from which to copy settings
     * @param domain copy to domain
     * @param path copy to path
     * @param acceptExisting should accept existing settings
     */
    async copySettingsFromDomain(from: DomainSettings, fromPath: string, domain: string, path: string, acceptExisting: boolean = true): Promise<void> {
        return new Promise(async (resolve, reject) => {
            if (!from.pathSettings.has(fromPath) && (!acceptExisting || from.pathSettings.size === 0)) {
                reject(fromPath)
                return;
            }
            await this.addSettingsForDomain(domain, path,
                from.pathSettings?.get(fromPath) || [...from.pathSettings?.values()][0])
            resolve();
        })
    }

    /**
     * @returns {Promise<DomainPaths>} Returns the current domain and path.
     */
    getCurrentDomainAndPaths(): Promise<DomainPaths> {
        return new Promise((resolve) => {
            this.tabUrlProvider().then(value => {
                try {
                    return new URL(guardUrlWithProtocol(value));
                } catch (e) {
                    throw e
                }
            }).then((url: URL) => {
                return {
                    domain: url.hostname,
                    paths: [url.pathname]
                } as DomainPaths
            }).then(resolve);
        });
    }

    /**
     * Retrieves the settings for the given domain, defaulting path options along the way.
     */
    async getCurrentSettings(): Promise<Options> {
        return new Promise<Options>((resolve, reject) => {
            this.tabUrlProvider().then((url) => {
                // an odd note: new URL was throwing an exception in the constructor of URL and blew up the chain
                let urlobj: URL;
                try {
                    urlobj = new URL(guardUrlWithProtocol(url));
                } catch (e) {
                    reject(e);
                    return;
                }

                this.settingsRegistryProvider(settingsRegistry => {
                    if (!(urlobj.hostname in settingsRegistry)) {
                        settingsRegistry[urlobj.hostname] = new DomainSettings(urlobj.hostname, new Map<string, Options>());
                    }

                    const domainSettings = settingsRegistry[urlobj.hostname];

                    if (!domainSettings.pathSettings.has(urlobj.pathname)) {
                        const availableOptions: Options = domainSettings.pathSettings.values().next()?.value || Options.getDefaultOptions();

                        console.log(`defaulting options for ${urlobj.hostname} with path: ${urlobj.pathname}`)
                        domainSettings.pathSettings.set(urlobj.pathname, availableOptions)
                    }

                    resolve(domainSettings.pathSettings.get(urlobj.pathname)!)
                })
            });
        });
    }

    async getSettingsRegistryForDomain(domain: string, defaultUndefined: boolean = true): Promise<SettingsRegistry | undefined> {
        const hostname = new URL(guardUrlWithProtocol(domain)).hostname;
        return new Promise((resolve) => {
            this.settingsRegistryProvider(settingsRegistry => {
                if (!(hostname in settingsRegistry)) {
                    if (defaultUndefined) {
                        console.log(`defaulting options for ${hostname} with path:`)
                        settingsRegistry[hostname] = new DomainSettings(hostname, new Map<string, Options>([["", Options.getDefaultOptions()]]))
                    } else {
                        console.log("no entry for domain in the settings registry matched the desired DomainSettings")
                        resolve(undefined);
                    }
                }


                resolve(settingsRegistry)
            })
        });
    }

    /**
     * Retrieves the domains and domain specific paths for which we have saved unique settings
     */
    async getDomainsAndPaths(): Promise<DomainPaths[]> {
        return new Promise((resolve) => {
            return this.settingsRegistryProvider((settingsRegistry: SettingsRegistry) => {
                resolve(Object.keys(settingsRegistry).map(settings => settingsRegistry[settings].getDomainPaths()))
            })
        })
    }

    async getSettingsForDomain(domain: string, defaultUndefined: boolean = true): Promise<DomainSettings | undefined> {
        const hostname = new URL(guardUrlWithProtocol(domain)).hostname;
        const settingsRegistry: SettingsRegistry = (await this.getSettingsRegistryForDomain(hostname, defaultUndefined)) as SettingsRegistry

        if (!defaultUndefined && settingsRegistry && !(hostname in settingsRegistry)) {
            return Promise.resolve(undefined)
        }

        return Promise.resolve(settingsRegistry[hostname]);
    }

    async getPathOptionsForDomain(domain: string, path: string, defaultUndefined = true, useExistingInsteadOfNew = true): Promise<Options | undefined> {
        const hostname = new URL(guardUrlWithProtocol(domain)).hostname;
        const domainSettings = await this.getSettingsForDomain(hostname, defaultUndefined);

        if (domainSettings === undefined || !defaultUndefined && !domainSettings?.pathSettings.has(path)) {
            return Promise.resolve(undefined);
        } else if (!domainSettings?.pathSettings.has(path)) {
            const availableOptions = useExistingInsteadOfNew ? domainSettings?.pathSettings.values().next()?.value || Options.getDefaultOptions() : Options.getDefaultOptions();

            console.log(`defaulting options for ${domain} with path: ${path}`)
            domainSettings?.pathSettings.set(path, availableOptions)
        }

        return Promise.resolve(domainSettings?.pathSettings.get(path));
    }

    async updateCurrentSettings(update: { (options: Options): Options }): Promise<void> {
        return this.tabUrlProvider().then(async (url) => {
            const tab = new URL(guardUrlWithProtocol(url));

            const domainSettings = await this.getCurrentSettings();
            return this.addSettingsForDomain(tab.hostname, tab.pathname, update(domainSettings))
        });
    }

    /**
     * removes the selected domain settings from the settings registry
     * @param domain the url domain to remove
     * @returns [Promise<boolean>] if true, removed, false, not present, catch, internal error
     */
    async removeSettingsForDomain(domain: string): Promise<boolean> {
        const hostname = new URL(guardUrlWithProtocol(domain)).hostname;
        return new Promise((resolve) => {
            this.settingsRegistryProvider(settingsRegistry => {
                if (hostname in settingsRegistry) {
                    delete settingsRegistry[hostname];
                    this.saveSettingsRegistryProvider(settingsRegistry, () => {
                        resolve(true);
                    })
                    return;
                }
                resolve(false);
            })
        })
    }

    async removeSettingsForDomainPath(domain: string, path: string, deleteDomainIfEmpty: boolean = true): Promise<boolean> {
        const hostname = new URL(guardUrlWithProtocol(domain)).hostname;
        return new Promise((resolve) => {
            this.settingsRegistryProvider(settingsRegistry => {
                if (hostname in settingsRegistry) {
                    const domainSettings = settingsRegistry[hostname];
                    if (domainSettings.pathSettings.has(path)) {
                        settingsRegistry[hostname].pathSettings.delete(path)
                    }

                    if (deleteDomainIfEmpty && domainSettings.pathSettings.size === 0) {
                        delete settingsRegistry[hostname]
                    }

                    this.saveSettingsRegistryProvider(settingsRegistry, () => {
                        resolve(true);
                    })
                }
                resolve(false);
            })
        })
    }
}
import { getSyncObject, setSyncObject } from '../util/sync'
import {SettingsDAOInterface} from "./settings";
import { SelectorDefault } from "../models/defaults"

export interface SelectorServiceInterface {
    addSelector(selector: string): Promise<void>;
    removeSelector(selector: string): Promise<void>;
    useSelector(selector: string): Promise<void>;
    currentSelector(): Promise<string | undefined>;
    getSelectors(): Promise<string[]>;
}

export default class SelectorService implements SelectorServiceInterface {
    settings: SettingsDAOInterface;

    constructor(saveService: SettingsDAOInterface) {
        this.settings = saveService;
    }

    async addSelector(selector: string): Promise<void> {
        // TODO: validate selector? because of how loose the selector protocol is, i'm not sure it's worth it, other than to
        // todo:  callout possibly sus selector characters, like the quotes copied in
        return this.settings.updateCurrentSettings(options => {
            options.selectors.push(selector);
            return options;
        })
    }

    async currentSelector(): Promise<string | undefined> {
        return Promise.resolve((await this.settings.getCurrentSettings()).wave.selector)
    }

    async removeSelector(selector: string): Promise<void> {
        return this.settings.updateCurrentSettings(options => {
            options.selectors.splice(options.selectors.indexOf(selector), 1);

            // if the currect selector is the one we want to remove, default gracefully
            if (options.wave.selector === selector) {
                options.wave.selector = options.selectors[options.selectors.length - 1] as unknown as string || SelectorDefault
            }
            return options;
        })
    }

    async useSelector(selector: string): Promise<void> {
        return this.settings.updateCurrentSettings(options => {
            if (!options.selectors.includes(selector)) {
                options.selectors.push(selector);
            }
            options.wave.selector = selector;
            return options;
        });
    }

    async getSelectors(): Promise<string[]> {
        return (await this.settings.getCurrentSettings())?.selectors;
    }

}